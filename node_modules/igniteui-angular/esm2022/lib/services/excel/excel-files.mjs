import { ExcelStrings } from './excel-strings';
import { strToU8 } from 'fflate';
import { yieldingLoop } from '../../core/utils';
import { ExportHeaderType, ExportRecordType, GRID_ROOT_SUMMARY, GRID_PARENT, GRID_LEVEL_COL } from '../exporter-common/base-export-service';
/**
 * @hidden
 */
export class RootRelsFile {
    writeElement(folder) {
        folder['.rels'] = strToU8(ExcelStrings.getRels());
    }
}
/**
 * @hidden
 */
export class AppFile {
    writeElement(folder, worksheetData) {
        folder['app.xml'] = strToU8(ExcelStrings.getApp(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
export class CoreFile {
    writeElement(folder) {
        folder['core.xml'] = strToU8(ExcelStrings.getCore());
    }
}
/**
 * @hidden
 */
export class WorkbookRelsFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = !worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders;
        folder['workbook.xml.rels'] = strToU8(ExcelStrings.getWorkbookRels(hasSharedStrings));
    }
}
/**
 * @hidden
 */
export class ThemeFile {
    writeElement(folder) {
        folder['theme1.xml'] = strToU8(ExcelStrings.getTheme());
    }
}
/**
 * @hidden
 */
export class WorksheetFile {
    constructor() {
        this.maxOutlineLevel = 0;
        this.sheetData = '';
        this.dimension = '';
        this.freezePane = '';
        this.rowHeight = '';
        this.mergeCellStr = '';
        this.mergeCellsCounter = 0;
        this.rowIndex = 0;
        this.pivotGridRowHeadersMap = new Map();
        this.dimensionMap = new Map();
        this.hierarchicalDimensionMap = new Map();
        this.currentSummaryOwner = '';
        this.currentHierarchicalOwner = '';
        this.firstColumn = Number.MAX_VALUE;
        this.firstDataRow = Number.MAX_VALUE;
        this.currencyStyleMap = new Map([
            ['USD', { styleXf: 5, symbol: '$' }],
            ['GBP', { styleXf: 6, symbol: '£' }],
            ['CNY', { styleXf: 7, symbol: '¥' }],
            ['EUR', { styleXf: 8, symbol: '€' }],
            ['JPY', { styleXf: 9, symbol: '¥' }],
        ]);
    }
    static { this.MIN_WIDTH = 8.43; }
    writeElement() { }
    async writeElementAsync(folder, worksheetData) {
        return new Promise(resolve => {
            this.prepareDataAsync(worksheetData, (cols, rows) => {
                const hasTable = (!worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders)
                    && worksheetData.options.exportAsTable;
                folder['sheet1.xml'] = strToU8(ExcelStrings.getSheetXML(this.dimension, this.freezePane, cols, rows, hasTable, this.maxOutlineLevel, worksheetData.isHierarchical));
                resolve();
            });
        });
    }
    prepareDataAsync(worksheetData, done) {
        this.sheetData = '';
        let cols = '';
        const dictionary = worksheetData.dataDictionary;
        this.rowIndex = 0;
        if (worksheetData.isEmpty && (!worksheetData.options.alwaysExportHeaders || worksheetData.owner.columns.length === 0)) {
            this.sheetData += '<sheetData/>';
            this.dimension = 'A1';
            done('', this.sheetData);
        }
        else {
            const owner = worksheetData.owner;
            const isHierarchicalGrid = worksheetData.isHierarchical;
            const hasMultiColumnHeader = worksheetData.hasMultiColumnHeader;
            const hasMultiRowHeader = worksheetData.hasMultiRowHeader;
            const hasUserSetIndex = owner.columns.some(col => col.exportIndex !== undefined);
            const height = worksheetData.options.rowHeight;
            this.isValidGrid = worksheetData.isHierarchical || worksheetData.isTreeGrid || worksheetData.isGroupedGrid;
            this.rowHeight = height ? ` ht="${height}" customHeight="1"` : '';
            this.sheetData += `<sheetData>`;
            let headersForLevel = [];
            for (let i = 0; i <= owner.maxRowLevel; i++) {
                headersForLevel = owner.columns.filter(c => c.level === i && c.rowSpan > 0 && !c.skip);
                this.printHeaders(worksheetData, headersForLevel, i, true);
                this.rowIndex++;
            }
            this.rowIndex = 0;
            for (let i = 0; i <= owner.maxLevel; i++) {
                this.rowIndex++;
                const pivotGridColumns = this.pivotGridRowHeadersMap.get(this.rowIndex) ?? "";
                this.sheetData += `<row r="${this.rowIndex}"${this.rowHeight}>${pivotGridColumns}`;
                const allowedColumns = owner.columns.filter(c => c.headerType !== ExportHeaderType.RowHeader &&
                    c.headerType !== ExportHeaderType.MultiRowHeader &&
                    c.headerType !== ExportHeaderType.PivotRowHeader);
                headersForLevel = hasMultiColumnHeader ?
                    allowedColumns
                        .filter(c => (c.level < i &&
                        c.headerType !== ExportHeaderType.MultiColumnHeader || c.level === i) && c.columnSpan > 0 && !c.skip)
                        .sort((a, b) => a.startIndex - b.startIndex)
                        .sort((a, b) => a.pinnedIndex - b.pinnedIndex) :
                    hasUserSetIndex ?
                        allowedColumns.filter(c => !c.skip) :
                        allowedColumns.filter(c => !c.skip)
                            .sort((a, b) => a.startIndex - b.startIndex)
                            .sort((a, b) => a.pinnedIndex - b.pinnedIndex);
                this.printHeaders(worksheetData, headersForLevel, i, false);
                this.sheetData += `</row>`;
            }
            const multiColumnHeaderLevel = worksheetData.options.ignoreMultiColumnHeaders ? 0 : owner.maxLevel;
            const freezeHeaders = worksheetData.options.freezeHeaders ? 2 + multiColumnHeaderLevel : 1;
            if (!isHierarchicalGrid) {
                const col = worksheetData.hasSummaries ? worksheetData.columnCount + 1 : worksheetData.columnCount - 1;
                this.dimension = 'A1:' + ExcelStrings.getExcelColumn(col) + (worksheetData.rowCount);
                cols += '<cols>';
                if (!hasMultiColumnHeader) {
                    for (let j = 0; j < worksheetData.columnCount; j++) {
                        const width = dictionary.columnWidths[j];
                        // Use the width provided in the options if it exists
                        let widthInTwips = worksheetData.options.columnWidth !== undefined ?
                            worksheetData.options.columnWidth :
                            Math.max(((width / 96) * 14.4), WorksheetFile.MIN_WIDTH);
                        if (!(widthInTwips > 0)) {
                            widthInTwips = WorksheetFile.MIN_WIDTH;
                        }
                        cols += `<col min="${(j + 1)}" max="${(j + 1)}" width="${widthInTwips}" customWidth="1"/>`;
                    }
                }
                else {
                    cols += `<col min="1" max="${worksheetData.columnCount}" width="15" customWidth="1"/>`;
                }
                const indexOfLastPinnedColumn = worksheetData.indexOfLastPinnedColumn;
                const frozenColumnCount = indexOfLastPinnedColumn + 1;
                let firstCell = ExcelStrings.getExcelColumn(frozenColumnCount) + freezeHeaders;
                if (indexOfLastPinnedColumn !== undefined && indexOfLastPinnedColumn !== -1 &&
                    !worksheetData.options.ignorePinning &&
                    !worksheetData.options.ignoreColumnsOrder) {
                    this.freezePane =
                        `<pane xSplit="${frozenColumnCount}" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
                else if (worksheetData.options.freezeHeaders) {
                    firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;
                    this.freezePane =
                        `<pane xSplit="0" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
            }
            else {
                const columnWidth = worksheetData.options.columnWidth ? worksheetData.options.columnWidth : 20;
                cols += `<cols><col min="1" max="${worksheetData.columnCount}" width="${columnWidth}" customWidth="1"/>`;
                if (worksheetData.options.freezeHeaders) {
                    const firstCell = ExcelStrings.getExcelColumn(0) + freezeHeaders;
                    this.freezePane =
                        `<pane xSplit="0" ySplit="${freezeHeaders - 1}"
                         topLeftCell="${firstCell}" activePane="topRight" state="frozen"/>`;
                }
            }
            if (worksheetData.hasSummaries) {
                cols += `<col min="${worksheetData.columnCount + 2}" max="${worksheetData.columnCount + 2}" hidden="1"/>`;
            }
            cols += '</cols>';
            this.processDataRecordsAsync(worksheetData, (rows) => {
                this.sheetData += rows;
                this.sheetData += '</sheetData>';
                if ((hasMultiColumnHeader || hasMultiRowHeader) && this.mergeCellsCounter > 0) {
                    this.sheetData += `<mergeCells count="${this.mergeCellsCounter}">${this.mergeCellStr}</mergeCells>`;
                }
                done(cols, this.sheetData);
            });
        }
    }
    processDataRecordsAsync(worksheetData, done) {
        const rowDataArr = [];
        const height = worksheetData.options.rowHeight;
        this.rowHeight = height ? ' ht="' + height + '" customHeight="1"' : '';
        const isHierarchicalGrid = worksheetData.isHierarchical;
        const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);
        let recordHeaders = [];
        yieldingLoop(worksheetData.rowCount - worksheetData.multiColumnHeaderRows - 1, 1000, (i) => {
            if (!worksheetData.isEmpty) {
                if (!isHierarchicalGrid) {
                    if (hasUserSetIndex) {
                        recordHeaders = worksheetData.rootKeys;
                    }
                    else {
                        recordHeaders = worksheetData.owner.columns
                            .filter(c => c.headerType === ExportHeaderType.ColumnHeader && !c.skip)
                            .sort((a, b) => a.startIndex - b.startIndex)
                            .sort((a, b) => a.pinnedIndex - b.pinnedIndex)
                            .map(c => c.field);
                    }
                }
                else {
                    const record = worksheetData.data[i];
                    if (record.type === ExportRecordType.HeaderRecord) {
                        const recordOwner = worksheetData.owners.get(record.owner);
                        const hasMultiColumnHeaders = recordOwner.columns.some(c => !c.skip && c.headerType === ExportHeaderType.MultiColumnHeader);
                        if (hasMultiColumnHeaders) {
                            this.hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, recordOwner);
                        }
                    }
                    recordHeaders = Object.keys(worksheetData.data[i].data);
                }
                rowDataArr.push(this.processRow(worksheetData, i, recordHeaders, isHierarchicalGrid));
            }
        }, () => {
            done(rowDataArr.join(''));
        });
    }
    hGridPrintMultiColHeaders(worksheetData, rowDataArr, record, owner) {
        for (let j = 0; j < owner.maxLevel; j++) {
            const recordLevel = record.level;
            const outlineLevel = recordLevel > 0 ? ` outlineLevel="${recordLevel}"` : '';
            this.maxOutlineLevel = this.maxOutlineLevel < recordLevel ? recordLevel : this.maxOutlineLevel;
            const sHidden = record.hidden ? ` hidden="1"` : '';
            this.rowIndex++;
            let row = `<row r="${this.rowIndex}"${this.rowHeight}${outlineLevel}${sHidden}>`;
            const headersForLevel = owner.columns
                .filter(c => (c.level < j &&
                c.headerType !== ExportHeaderType.MultiColumnHeader || c.level === j) && c.columnSpan > 0 && !c.skip)
                .sort((a, b) => a.startIndex - b.startIndex)
                .sort((a, b) => a.pinnedIndex - b.pinnedIndex);
            let startValue = 0 + record.level;
            for (const currentCol of headersForLevel) {
                if (currentCol.level === j) {
                    let columnCoordinate;
                    columnCoordinate =
                        ExcelStrings.getExcelColumn(startValue) + this.rowIndex;
                    const columnValue = worksheetData.dataDictionary.saveValue(currentCol.header, true);
                    row += `<c r="${columnCoordinate}" s="3" t="s"><v>${columnValue}</v></c>`;
                    if (j !== owner.maxLevel) {
                        this.mergeCellsCounter++;
                        this.mergeCellStr += ` <mergeCell ref="${columnCoordinate}:`;
                        if (currentCol.headerType === ExportHeaderType.ColumnHeader) {
                            columnCoordinate = ExcelStrings.getExcelColumn(startValue) +
                                (this.rowIndex + owner.maxLevel - currentCol.level);
                        }
                        else {
                            for (let k = 1; k < currentCol.columnSpan; k++) {
                                columnCoordinate = ExcelStrings.getExcelColumn(startValue + k) + this.rowIndex;
                                row += `<c r="${columnCoordinate}" s="3" />`;
                            }
                        }
                        this.mergeCellStr += `${columnCoordinate}" />`;
                    }
                }
                startValue += currentCol.columnSpan;
            }
            row += `</row>`;
            rowDataArr.push(row);
        }
    }
    processRow(worksheetData, i, headersForLevel, isHierarchicalGrid) {
        const record = worksheetData.data[i];
        const rowData = new Array(worksheetData.columnCount + 2);
        const rowLevel = record.level;
        const outlineLevel = rowLevel > 0 ? ` outlineLevel="${rowLevel}"` : '';
        this.maxOutlineLevel = this.maxOutlineLevel < rowLevel ? rowLevel : this.maxOutlineLevel;
        const sHidden = record.hidden ? ` hidden="1"` : '';
        this.rowIndex++;
        const pivotGridColumns = this.pivotGridRowHeadersMap.get(this.rowIndex) ?? "";
        rowData[0] = `<row r="${this.rowIndex}"${this.rowHeight}${outlineLevel}${sHidden}>${pivotGridColumns}`;
        const keys = worksheetData.isSpecialData ? [record.data] : headersForLevel;
        const isDataRecord = record.type === ExportRecordType.HierarchicalGridRecord
            || record.type === ExportRecordType.DataRecord
            || record.type === ExportRecordType.GroupedRecord
            || record.type === ExportRecordType.TreeGridRecord;
        const isValidRecordType = isDataRecord || record.type === ExportRecordType.SummaryRecord;
        if (isValidRecordType && worksheetData.hasSummaries) {
            this.resolveSummaryDimensions(record, isDataRecord, worksheetData.isGroupedGrid);
        }
        for (let j = 0; j < keys.length; j++) {
            const col = j + (isHierarchicalGrid ? rowLevel : worksheetData.isPivotGrid ? worksheetData.owner.maxRowLevel : 0);
            const cellData = this.getCellData(worksheetData, i, col, keys[j]);
            rowData[j + 1] = cellData;
        }
        rowData[keys.length + 1] = '</row>';
        return rowData.join('');
    }
    getCellData(worksheetData, row, column, key) {
        const dictionary = worksheetData.dataDictionary;
        let columnName = ExcelStrings.getExcelColumn(column) + (this.rowIndex);
        const fullRow = worksheetData.data[row];
        const isHeaderRecord = fullRow.type === ExportRecordType.HeaderRecord;
        const isSummaryRecord = fullRow.type === ExportRecordType.SummaryRecord;
        const isValidRecordType = fullRow.type === ExportRecordType.GroupedRecord
            || fullRow.type === ExportRecordType.DataRecord
            || fullRow.type === ExportRecordType.HierarchicalGridRecord
            || fullRow.type === ExportRecordType.TreeGridRecord;
        this.firstDataRow = this.firstDataRow > this.rowIndex ? this.rowIndex : this.firstDataRow;
        const cellValue = worksheetData.isSpecialData ?
            fullRow.data :
            fullRow.data[key];
        if (cellValue === GRID_LEVEL_COL || key === GRID_LEVEL_COL) {
            columnName = ExcelStrings.getExcelColumn(worksheetData.columnCount + 1) + (this.rowIndex);
        }
        if (worksheetData.hasSummaries && (isValidRecordType || (worksheetData.isGroupedGrid && isSummaryRecord))) {
            this.setSummaryCoordinates(columnName, key, fullRow.hierarchicalOwner, worksheetData.isGroupedGrid && isSummaryRecord);
        }
        if (fullRow.summaryKey && fullRow.summaryKey === GRID_ROOT_SUMMARY && key !== GRID_LEVEL_COL && worksheetData.isGroupedGrid) {
            this.setRootSummaryStartCoordinate(column, key);
            if (this.firstColumn > column) {
                this.setRootSummaryStartCoordinate(worksheetData.columnCount + 1, GRID_LEVEL_COL);
                this.firstColumn = column;
            }
        }
        const targetColArr = Array.from(worksheetData.owners.values()).map(arr => arr.columns).find(product => product.some(item => item.field === key));
        const targetCol = targetColArr ? targetColArr.find(col => col.field === key) : undefined;
        if ((cellValue === undefined || cellValue === null) && !worksheetData.hasSummaries) {
            return `<c r="${columnName}" s="1"/>`;
        }
        else if ((worksheetData.hasSummaries && (isValidRecordType || isHeaderRecord)) || !worksheetData.hasSummaries) {
            const savedValue = dictionary.saveValue(cellValue, isHeaderRecord);
            const isSavedAsString = savedValue !== -1;
            const isSavedAsDate = !isSavedAsString && cellValue instanceof Date;
            let value = isSavedAsString ? savedValue : cellValue;
            if (isSavedAsDate) {
                const timeZoneOffset = value.getTimezoneOffset() * 60000;
                const isoString = (new Date(value - timeZoneOffset)).toISOString();
                value = isoString.substring(0, isoString.indexOf('.'));
            }
            const type = isSavedAsString ? ` t="s"` : isSavedAsDate ? ` t="d"` : '';
            const isTime = targetCol?.dataType === 'time';
            const isDateTime = targetCol?.dataType === 'dateTime';
            const isPercentage = targetCol?.dataType === 'percent';
            const isColumnCurrencyType = targetCol?.dataType === 'currency';
            const format = isPercentage ? ` s="12"` : isDateTime ? ` s="11"` : isTime ? ` s="10"` : isHeaderRecord ? ` s="3"` : isSavedAsString ? '' : isSavedAsDate ? ` s="2"` : isColumnCurrencyType ? ` s="${this.currencyStyleMap.get(targetCol.currencyCode)?.styleXf || 0}"` : ` s="1"`;
            return `<c r="${columnName}"${type}${format}><v>${value}</v></c>`;
        }
        else {
            let summaryFunc = `"${cellValue ?? ""}"`;
            if (isSummaryRecord && cellValue) {
                const dimensionMapKey = this.isValidGrid ? fullRow.hierarchicalOwner ?? GRID_PARENT : null;
                const level = worksheetData.isGroupedGrid ? worksheetData.maxLevel : fullRow.level;
                summaryFunc = this.getSummaryFunction(cellValue.label, key, dimensionMapKey, level, targetCol);
                if (!summaryFunc) {
                    const cellStr = `${cellValue.label}: ${cellValue.value}`;
                    const savedValue = dictionary.saveValue(cellStr, false);
                    return `<c r="${columnName}" t="s" s="1"><v>${savedValue}</v></c>`;
                }
                return `<c r="${columnName}"><f t="array" ref="${columnName}">${summaryFunc}</f></c>`;
            }
            return `<c r="${columnName}" s="1"><f>${summaryFunc}</f></c>`;
        }
    }
    resolveSummaryDimensions(record, isDataRecord, isGroupedGrid) {
        if (this.isValidGrid &&
            this.currentHierarchicalOwner !== '' &&
            this.currentHierarchicalOwner !== record.owner &&
            !this.hierarchicalDimensionMap.get(this.currentHierarchicalOwner)) {
            this.hierarchicalDimensionMap.set(this.currentHierarchicalOwner, new Map(this.dimensionMap));
        }
        if (isDataRecord) {
            if (this.currentSummaryOwner !== record.summaryKey || this.currentHierarchicalOwner !== record.hierarchicalOwner) {
                this.dimensionMap.clear();
            }
            this.currentSummaryOwner = record.summaryKey;
            // For grouped grid we need to reset the parent map
            // so we can change the startCoordinate for each record
            if (isGroupedGrid && this.currentHierarchicalOwner !== '' && record.hierarchicalOwner === GRID_PARENT) {
                this.hierarchicalDimensionMap.delete(GRID_PARENT);
            }
            this.currentHierarchicalOwner = record.hierarchicalOwner;
        }
    }
    setSummaryCoordinates(columnName, key, hierarchicalOwner, useLastValidEndCoordinate) {
        const targetDimensionMap = this.hierarchicalDimensionMap.get(hierarchicalOwner) ?? this.dimensionMap;
        if (!targetDimensionMap.get(key)) {
            const initialDimensions = {
                startCoordinate: columnName,
                endCoordinate: columnName
            };
            targetDimensionMap.set(key, initialDimensions);
        }
        else {
            if (useLastValidEndCoordinate) {
                this.setEndCoordinates(targetDimensionMap, true);
            }
            else {
                targetDimensionMap.get(key).endCoordinate = columnName;
                this.lastValidRow = targetDimensionMap.get(key).endCoordinate.match(/[a-z]+|[^a-z]+/gi)[1];
            }
        }
        if (this.isValidGrid && !useLastValidEndCoordinate && hierarchicalOwner !== GRID_PARENT) {
            const parentMap = this.hierarchicalDimensionMap.get(GRID_PARENT);
            this.setEndCoordinates(parentMap);
        }
    }
    setEndCoordinates(map, useLastValidEndCoordinate = false) {
        for (const a of map.values()) {
            const colName = a.endCoordinate.match(/[a-z]+|[^a-z]+/gi)[0];
            a.endCoordinate = `${colName}${useLastValidEndCoordinate ? this.lastValidRow : this.rowIndex}`;
        }
    }
    getSummaryFunction(type, key, dimensionMapKey, recordLevel, col) {
        const dimensionMap = dimensionMapKey ? this.hierarchicalDimensionMap.get(dimensionMapKey) : this.dimensionMap;
        const dimensions = dimensionMap.get(key);
        const levelDimensions = dimensionMap.get(GRID_LEVEL_COL);
        let func = '';
        let funcType = '';
        let result = '';
        const currencyInfo = this.currencyStyleMap.get(col.currencyCode);
        switch (type.toLowerCase()) {
            case "count":
                return `"Count: "&amp;_xlfn.COUNTIF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}, ${recordLevel})`;
            case "min":
                func = `_xlfn.MIN(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate}))`;
                funcType = `"Min: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "max":
                func = `_xlfn.MAX(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate}))`;
                funcType = `"Max: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "sum":
                func = `_xlfn.SUMIF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}, ${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})`;
                funcType = `"Sum: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "avg":
                func = `_xlfn.AVERAGEIF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}, ${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})`;
                funcType = `"Avg: "&amp;`;
                result = funcType + (col.dataType === 'currency' && currencyInfo
                    ? `_xlfn.TEXT(${func}, "${currencyInfo.symbol}#,##0.00")`
                    : `${func}`);
                return result;
            case "earliest":
                // TODO: get date format from locale
                return `"Earliest: "&amp;_xlfn.TEXT(_xlfn.MIN(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})), "m/d/yyyy")`;
            case "latest":
                // TODO: get date format from locale
                return `"Latest: "&amp;_xlfn.TEXT(_xlfn.MAX(_xlfn.IF(${levelDimensions.startCoordinate}:${levelDimensions.endCoordinate}=${recordLevel}, ${dimensions.startCoordinate}:${dimensions.endCoordinate})), "m/d/yyyy")`;
        }
    }
    setRootSummaryStartCoordinate(column, key) {
        const firstDataRecordColName = ExcelStrings.getExcelColumn(column) + (this.firstDataRow);
        const targetMap = this.hierarchicalDimensionMap.get(GRID_PARENT);
        if (targetMap.get(key).startCoordinate !== firstDataRecordColName) {
            targetMap.get(key).startCoordinate = firstDataRecordColName;
        }
    }
    printHeaders(worksheetData, headersForLevel, i, isVertical) {
        let startValue = 0;
        let str = '';
        const isHierarchicalGrid = worksheetData.isHierarchical;
        let rowStyle = isHierarchicalGrid ? ' s="3"' : '';
        const dictionary = worksheetData.dataDictionary;
        const owner = worksheetData.owner;
        const maxLevel = isVertical
            ? owner.maxRowLevel
            : owner.maxLevel;
        for (const currentCol of headersForLevel) {
            const spanLength = isVertical ? currentCol.rowSpan : currentCol.columnSpan;
            if (currentCol.level === i) {
                let columnCoordinate;
                const column = isVertical
                    ? this.rowIndex
                    : startValue + (owner.maxRowLevel ?? 0);
                let rowCoordinate = isVertical
                    ? startValue + owner.maxLevel + 2
                    : this.rowIndex;
                if (currentCol.headerType === ExportHeaderType.PivotRowHeader) {
                    rowCoordinate = startValue + 1;
                }
                const columnValue = dictionary.saveValue(currentCol.header, true, false);
                columnCoordinate = (currentCol.field === GRID_LEVEL_COL
                    ? ExcelStrings.getExcelColumn(worksheetData.columnCount + 1)
                    : ExcelStrings.getExcelColumn(column)) + rowCoordinate;
                rowStyle = isVertical && currentCol.rowSpan > 1 ? ' s="4"' : rowStyle;
                str = `<c r="${columnCoordinate}"${rowStyle} t="s"><v>${columnValue}</v></c>`;
                if (isVertical) {
                    if (this.pivotGridRowHeadersMap.has(rowCoordinate)) {
                        this.pivotGridRowHeadersMap.set(rowCoordinate, this.pivotGridRowHeadersMap.get(rowCoordinate) + str);
                    }
                    else {
                        this.pivotGridRowHeadersMap.set(rowCoordinate, str);
                    }
                }
                else {
                    this.sheetData += str;
                }
                if (i !== maxLevel) {
                    this.mergeCellsCounter++;
                    this.mergeCellStr += ` <mergeCell ref="${columnCoordinate}:`;
                    if (currentCol.headerType === ExportHeaderType.ColumnHeader) {
                        const col = isVertical
                            ? maxLevel
                            : startValue + (owner.maxRowLevel ?? 0);
                        const row = isVertical
                            ? rowCoordinate
                            : owner.maxLevel + 1;
                        columnCoordinate = ExcelStrings.getExcelColumn(col) + row;
                    }
                    else {
                        for (let k = 1; k < spanLength; k++) {
                            const col = isVertical
                                ? column
                                : column + k;
                            const row = isVertical
                                ? rowCoordinate + k
                                : this.rowIndex;
                            columnCoordinate = ExcelStrings.getExcelColumn(col) + row;
                            str = `<c r="${columnCoordinate}"${rowStyle} />`;
                            isVertical
                                ? this.pivotGridRowHeadersMap.set(row, str)
                                : this.sheetData += str;
                        }
                    }
                    this.mergeCellStr += `${columnCoordinate}" />`;
                }
            }
            if (currentCol.headerType !== ExportHeaderType.PivotRowHeader) {
                startValue += spanLength;
            }
        }
    }
}
/**
 * @hidden
 */
export class StyleFile {
    writeElement(folder) {
        folder['styles.xml'] = strToU8(ExcelStrings.getStyles());
    }
}
/**
 * @hidden
 */
export class WorkbookFile {
    writeElement(folder, worksheetData) {
        folder['workbook.xml'] = strToU8(ExcelStrings.getWorkbook(worksheetData.options.worksheetName));
    }
}
/**
 * @hidden
 */
export class ContentTypesFile {
    writeElement(folder, worksheetData) {
        const hasSharedStrings = !worksheetData.isEmpty || worksheetData.options.alwaysExportHeaders;
        folder['[Content_Types].xml'] = strToU8(ExcelStrings.getContentTypesXML(hasSharedStrings, worksheetData.options.exportAsTable));
    }
}
/**
 * @hidden
 */
export class SharedStringsFile {
    writeElement(folder, worksheetData) {
        const dict = worksheetData.dataDictionary;
        const sortedValues = dict.getKeys();
        const sharedStrings = new Array(sortedValues.length);
        for (const value of sortedValues) {
            sharedStrings[dict.getSanitizedValue(value)] = '<si><t>' + value + '</t></si>';
        }
        folder['sharedStrings.xml'] = strToU8(ExcelStrings.getSharedStringXML(dict.stringsCount, sortedValues.length, sharedStrings.join('')));
    }
}
/**
 * @hidden
 */
export class TablesFile {
    writeElement(folder, worksheetData) {
        const columnCount = worksheetData.columnCount;
        const lastColumn = ExcelStrings.getExcelColumn(columnCount - 1) + worksheetData.rowCount;
        const autoFilterDimension = 'A1:' + lastColumn;
        const tableDimension = worksheetData.isEmpty
            ? 'A1:' + ExcelStrings.getExcelColumn(columnCount - 1) + (worksheetData.rowCount + 1)
            : autoFilterDimension;
        const hasUserSetIndex = worksheetData.owner.columns.some(c => c.exportIndex !== undefined);
        const values = hasUserSetIndex
            ? worksheetData.rootKeys
            : worksheetData.owner.columns
                .filter(c => !c.skip)
                .sort((a, b) => a.startIndex - b.startIndex)
                .sort((a, b) => a.pinnedIndex - b.pinnedIndex)
                .map(c => c.header);
        let sortString = '';
        let tableColumns = '<tableColumns count="' + columnCount + '">';
        for (let i = 0; i < columnCount; i++) {
            const value = values[i];
            tableColumns += '<tableColumn id="' + (i + 1) + '" name="' + value + '"/>';
        }
        tableColumns += '</tableColumns>';
        if (worksheetData.sort) {
            const sortingExpression = worksheetData.sort;
            const sc = ExcelStrings.getExcelColumn(values.indexOf(sortingExpression.fieldName));
            const dir = sortingExpression.dir - 1;
            sortString = `<sortState ref="A2:${lastColumn}"><sortCondition descending="${dir}" ref="${sc}1:${sc}15"/></sortState>`;
        }
        folder['table1.xml'] = strToU8(ExcelStrings.getTablesXML(autoFilterDimension, tableDimension, tableColumns, sortString));
    }
}
/**
 * @hidden
 */
export class WorksheetRelsFile {
    writeElement(folder) {
        folder['sheet1.xml.rels'] = strToU8(ExcelStrings.getWorksheetRels());
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhjZWwtZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc2VydmljZXMvZXhjZWwvZXhjZWwtZmlsZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRy9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFDakMsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBMkMsaUJBQWlCLEVBQUUsV0FBVyxFQUFFLGNBQWMsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBRXJMOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFlBQVk7SUFDZCxZQUFZLENBQUMsTUFBYztRQUM5QixNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Q0FDSjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLE9BQU87SUFDVCxZQUFZLENBQUMsTUFBYyxFQUFFLGFBQTRCO1FBQzVELE1BQU0sQ0FBQyxTQUFTLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7SUFDMUYsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sUUFBUTtJQUNWLFlBQVksQ0FBQyxNQUFjO1FBQzlCLE1BQU0sQ0FBQyxVQUFVLENBQUMsR0FBRyxPQUFPLENBQUMsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7SUFDekQsQ0FBQztDQUNKO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sZ0JBQWdCO0lBQ2xCLFlBQVksQ0FBQyxNQUFjLEVB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LEVBQUUsQ0FBQyxDQUFDO0lBQ3pFLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElFeGNlbEZpbGUgfSBmcm9tICcuL2V4Y2VsLWludGVyZmFjZXMnO1xuaW1wb3J0IHsgRXhjZWxTdHJpbmdzIH0gZnJvbSAnLi9leGNlbC1zdHJpbmdzJztcbmltcG9ydCB7IFdvcmtzaGVldERhdGEgfSBmcm9tICcuL3dvcmtzaGVldC1kYXRhJztcblxuaW1wb3J0IHsgc3RyVG9VOCB9IGZyb20gJ2ZmbGF0ZSc7XG5pbXBvcnQgeyB5aWVsZGluZ0xvb3AgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IEV4cG9ydEhlYWRlclR5cGUsIEV4cG9ydFJlY29yZFR5cGUsIElFeHBvcnRSZWNvcmQsIElDb2x1bW5MaXN0LCBJQ29sdW1uSW5mbywgR1JJRF9ST09UX1NVTU1BUlksIEdSSURfUEFSRU5ULCBHUklEX0xFVkVMX0NPTCB9IGZyb20gJy4uL2V4cG9ydGVyLWNvbW1vbi9iYXNlLWV4cG9ydC1zZXJ2aWNlJztcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBSb290UmVsc0ZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogT2JqZWN0KSB7XG4gICAgICAgIGZvbGRlclsnLnJlbHMnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldFJlbHMoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIEFwcEZpbGUgaW1wbGVtZW50cyBJRXhjZWxGaWxlIHtcbiAgICBwdWJsaWMgd3JpdGVFbGVtZW50KGZvbGRlcjogT2JqZWN0LCB3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhKSB7XG4gICAgICAgIGZvbGRlclsnYXBwLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0QXBwKHdvcmtzaGVldERhdGEub3B0aW9ucy53b3Jrc2hlZXROYW1lKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIENvcmVGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCkge1xuICAgICAgICBmb2xkZXJbJ2NvcmUueG1sJ10gPSBzdHJUb1U4KEV4Y2VsU3RyaW5ncy5nZXRDb3JlKCkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3JrYm9va1JlbHNGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBjb25zdCBoYXNTaGFyZWRTdHJpbmdzID0gIXdvcmtzaGVldERhdGEuaXNFbXB0eSB8fCB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuYWx3YXlzRXhwb3J0SGVhZGVycztcbiAgICAgICAgZm9sZGVyWyd3b3JrYm9vay54bWwucmVscyddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0V29ya2Jvb2tSZWxzKGhhc1NoYXJlZFN0cmluZ3MpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgVGhlbWVGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCkge1xuICAgICAgICBmb2xkZXJbJ3RoZW1lMS54bWwnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldFRoZW1lKCkpO1xuICAgIH1cbn1cblxuaW50ZXJmYWNlIERpbWVuc2lvbnMge1xuICAgIHN0YXJ0Q29vcmRpbmF0ZTogc3RyaW5nXG4gICAgZW5kQ29vcmRpbmF0ZTogc3RyaW5nXG59XG5cbmludGVyZmFjZSBDdXJyZW5jeUluZm8ge1xuICAgIHN0eWxlWGY6IG51bWJlclxuICAgIHN5bWJvbDogc3RyaW5nXG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgV29ya3NoZWV0RmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHByaXZhdGUgc3RhdGljIE1JTl9XSURUSCA9IDguNDM7XG4gICAgcHJpdmF0ZSBtYXhPdXRsaW5lTGV2ZWwgPSAwO1xuICAgIHByaXZhdGUgc2hlZXREYXRhID0gJyc7XG4gICAgcHJpdmF0ZSBkaW1lbnNpb24gPSAnJztcbiAgICBwcml2YXRlIGZyZWV6ZVBhbmUgPSAnJztcbiAgICBwcml2YXRlIHJvd0hlaWdodCA9ICcnO1xuXG4gICAgcHJpdmF0ZSBtZXJnZUNlbGxTdHIgPSAnJztcbiAgICBwcml2YXRlIG1lcmdlQ2VsbHNDb3VudGVyID0gMDtcbiAgICBwcml2YXRlIHJvd0luZGV4ID0gMDtcbiAgICBwcml2YXRlIHBpdm90R3JpZFJvd0hlYWRlcnNNYXAgPSBuZXcgTWFwPG51bWJlciwgc3RyaW5nPigpO1xuXG4gICAgcHJpdmF0ZSBkaW1lbnNpb25NYXA6IE1hcDxzdHJpbmcsIERpbWVuc2lvbnM+ID0gbmV3IE1hcDxzdHJpbmcsIERpbWVuc2lvbnM+KCk7XG4gICAgcHJpdmF0ZSBoaWVyYXJjaGljYWxEaW1lbnNpb25NYXA6IE1hcDxhbnksICBNYXA8c3RyaW5nLCBEaW1lbnNpb25zPj4gPSBuZXcgTWFwPGFueSwgIE1hcDxzdHJpbmcsIERpbWVuc2lvbnM+PigpO1xuICAgIHByaXZhdGUgY3VycmVudFN1bW1hcnlPd25lciA9ICcnO1xuICAgIHByaXZhdGUgY3VycmVudEhpZXJhcmNoaWNhbE93bmVyID0gJyc7XG4gICAgcHJpdmF0ZSBmaXJzdENvbHVtbiA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgcHJpdmF0ZSBmaXJzdERhdGFSb3cgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHByaXZhdGUgaXNWYWxpZEdyaWQ6IGJvb2xlYW47XG4gICAgcHJpdmF0ZSBsYXN0VmFsaWRSb3c6IHN0cmluZztcblxuICAgIHByaXZhdGUgY3VycmVuY3lTdHlsZU1hcCA9IG5ldyBNYXA8c3RyaW5nLCBDdXJyZW5jeUluZm8+KFtcbiAgICAgICAgWydVU0QnLCB7c3R5bGVYZjogNSwgc3ltYm9sOiAnJCd9XSxcbiAgICAgICAgWydHQlAnLCB7c3R5bGVYZjogNiwgc3ltYm9sOiAnwqMnfV0sXG4gICAgICAgIFsnQ05ZJywge3N0eWxlWGY6IDcsIHN5bWJvbDogJ8KlJ31dLFxuICAgICAgICBbJ0VVUicsIHtzdHlsZVhmOiA4LCBzeW1ib2w6ICfigqwnfV0sXG4gICAgICAgIFsnSlBZJywge3N0eWxlWGY6IDksIHN5bWJvbDogJ8KlJ31dLFxuICAgIF0pO1xuXG4gICAgcHVibGljIHdyaXRlRWxlbWVudCgpIHt9XG5cbiAgICBwdWJsaWMgYXN5bmMgd3JpdGVFbGVtZW50QXN5bmMoZm9sZGVyOiBPYmplY3QsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmVwYXJlRGF0YUFzeW5jKHdvcmtzaGVldERhdGEsIChjb2xzLCByb3dzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzVGFibGUgPSAoIXdvcmtzaGVldERhdGEuaXNFbXB0eSB8fCB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuYWx3YXlzRXhwb3J0SGVhZGVycylcbiAgICAgICAgICAgICAgICAgICAgJiYgd29ya3NoZWV0RGF0YS5vcHRpb25zLmV4cG9ydEFzVGFibGU7XG5cbiAgICAgICAgICAgICAgICBmb2xkZXJbJ3NoZWV0MS54bWwnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldFNoZWV0WE1MKFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpbWVuc2lvbiwgdGhpcy5mcmVlemVQYW5lLCBjb2xzLCByb3dzLCBoYXNUYWJsZSwgdGhpcy5tYXhPdXRsaW5lTGV2ZWwsIHdvcmtzaGVldERhdGEuaXNIaWVyYXJjaGljYWwpKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmVwYXJlRGF0YUFzeW5jKHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEsIGRvbmU6IChjb2xzOiBzdHJpbmcsIHNoZWV0RGF0YTogc3RyaW5nKSA9PiB2b2lkKSB7XG4gICAgICAgIHRoaXMuc2hlZXREYXRhID0gJyc7XG4gICAgICAgIGxldCBjb2xzID0gJyc7XG4gICAgICAgIGNvbnN0IGRpY3Rpb25hcnkgPSB3b3Jrc2hlZXREYXRhLmRhdGFEaWN0aW9uYXJ5O1xuICAgICAgICB0aGlzLnJvd0luZGV4ID0gMDtcblxuICAgICAgICBpZiAod29ya3NoZWV0RGF0YS5pc0VtcHR5ICYmICghd29ya3NoZWV0RGF0YS5vcHRpb25zLmFsd2F5c0V4cG9ydEhlYWRlcnMgfHwgd29ya3NoZWV0RGF0YS5vd25lci5jb2x1bW5zLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2hlZXREYXRhICs9ICc8c2hlZXREYXRhLz4nO1xuICAgICAgICAgICAgdGhpcy5kaW1lbnNpb24gPSAnQTEnO1xuICAgICAgICAgICAgZG9uZSgnJywgdGhpcy5zaGVldERhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb3duZXIgPSB3b3Jrc2hlZXREYXRhLm93bmVyO1xuICAgICAgICAgICAgY29uc3QgaXNIaWVyYXJjaGljYWxHcmlkID0gd29ya3NoZWV0RGF0YS5pc0hpZXJhcmNoaWNhbDtcbiAgICAgICAgICAgIGNvbnN0IGhhc011bHRpQ29sdW1uSGVhZGVyID0gd29ya3NoZWV0RGF0YS5oYXNNdWx0aUNvbHVtbkhlYWRlcjtcbiAgICAgICAgICAgIGNvbnN0IGhhc011bHRpUm93SGVhZGVyID0gd29ya3NoZWV0RGF0YS5oYXNNdWx0aVJvd0hlYWRlcjtcblxuICAgICAgICAgICAgY29uc3QgaGFzVXNlclNldEluZGV4ID0gb3duZXIuY29sdW1ucy5zb21lKGNvbCA9PiBjb2wuZXhwb3J0SW5kZXggIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9ICB3b3Jrc2hlZXREYXRhLm9wdGlvbnMucm93SGVpZ2h0O1xuXG4gICAgICAgICAgICB0aGlzLmlzVmFsaWRHcmlkID0gd29ya3NoZWV0RGF0YS5pc0hpZXJhcmNoaWNhbCB8fCB3b3Jrc2hlZXREYXRhLmlzVHJlZUdyaWQgfHwgd29ya3NoZWV0RGF0YS5pc0dyb3VwZWRHcmlkO1xuICAgICAgICAgICAgdGhpcy5yb3dIZWlnaHQgPSBoZWlnaHQgPyBgIGh0PVwiJHtoZWlnaHR9XCIgY3VzdG9tSGVpZ2h0PVwiMVwiYCA6ICcnO1xuICAgICAgICAgICAgdGhpcy5zaGVldERhdGEgKz0gYDxzaGVldERhdGE+YDtcblxuICAgICAgICAgICAgbGV0IGhlYWRlcnNGb3JMZXZlbDogSUNvbHVtbkluZm9bXSA9IFtdO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDw9IG93bmVyLm1heFJvd0xldmVsOyBpKyspIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzRm9yTGV2ZWwgPSAgb3duZXIuY29sdW1ucy5maWx0ZXIoYyA9PiBjLmxldmVsID09PSBpICYmIGMucm93U3BhbiA+IDAgJiYgIWMuc2tpcClcblxuICAgICAgICAgICAgICAgIHRoaXMucHJpbnRIZWFkZXJzKHdvcmtzaGVldERhdGEsIGhlYWRlcnNGb3JMZXZlbCwgaSwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucm93SW5kZXggPSAwO1xuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBvd25lci5tYXhMZXZlbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3dJbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBpdm90R3JpZENvbHVtbnMgPSB0aGlzLnBpdm90R3JpZFJvd0hlYWRlcnNNYXAuZ2V0KHRoaXMucm93SW5kZXgpID8/IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGVldERhdGEgKz0gYDxyb3cgcj1cIiR7dGhpcy5yb3dJbmRleH1cIiR7dGhpcy5yb3dIZWlnaHR9PiR7cGl2b3RHcmlkQ29sdW1uc31gO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dlZENvbHVtbnMgPSBvd25lci5jb2x1bW5zLmZpbHRlcihjID0+IGMuaGVhZGVyVHlwZSAhPT0gRXhwb3J0SGVhZGVyVHlwZS5Sb3dIZWFkZXIgJiZcbiAgICAgICAgICAgICAgICAgICAgIGMuaGVhZGVyVHlwZSAhPT0gRXhwb3J0SGVhZGVyVHlwZS5NdWx0aVJvd0hlYWRlciAmJlxuICAgICAgICAgICAgICAgICAgICAgYy5oZWFkZXJUeXBlICE9PSBFeHBvcnRIZWFkZXJUeXBlLlBpdm90Um93SGVhZGVyKTtcblxuICAgICAgICAgICAgICAgIGhlYWRlcnNGb3JMZXZlbCA9IGhhc011bHRpQ29sdW1uSGVhZGVyID9cbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZENvbHVtbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiAoYy5sZXZlbCA8IGkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmhlYWRlclR5cGUgIT09IEV4cG9ydEhlYWRlclR5cGUuTXVsdGlDb2x1bW5IZWFkZXIgfHwgYy5sZXZlbCA9PT0gaSkgJiYgYy5jb2x1bW5TcGFuID4gMCAmJiAhYy5za2lwKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEuc3RhcnRJbmRleCAtIGIuc3RhcnRJbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnBpbm5lZEluZGV4IC0gYi5waW5uZWRJbmRleCkgOlxuICAgICAgICAgICAgICAgICAgICBoYXNVc2VyU2V0SW5kZXggP1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuc2tpcCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZENvbHVtbnMuZmlsdGVyKGMgPT4gIWMuc2tpcClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5zdGFydEluZGV4IC0gYi5zdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnBpbm5lZEluZGV4IC0gYi5waW5uZWRJbmRleCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnByaW50SGVhZGVycyh3b3Jrc2hlZXREYXRhLCBoZWFkZXJzRm9yTGV2ZWwsIGksIGZhbHNlKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2hlZXREYXRhICs9IGA8L3Jvdz5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBtdWx0aUNvbHVtbkhlYWRlckxldmVsID0gd29ya3NoZWV0RGF0YS5vcHRpb25zLmlnbm9yZU11bHRpQ29sdW1uSGVhZGVycyA/IDAgOiBvd25lci5tYXhMZXZlbDtcbiAgICAgICAgICAgIGNvbnN0IGZyZWV6ZUhlYWRlcnMgPSB3b3Jrc2hlZXREYXRhLm9wdGlvbnMuZnJlZXplSGVhZGVycyA/IDIgKyBtdWx0aUNvbHVtbkhlYWRlckxldmVsIDogMTtcblxuICAgICAgICAgICAgaWYgKCFpc0hpZXJhcmNoaWNhbEdyaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB3b3Jrc2hlZXREYXRhLmhhc1N1bW1hcmllcyA/IHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQgKyAxIDogd29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCAtIDFcbiAgICAgICAgICAgICAgICB0aGlzLmRpbWVuc2lvbiA9ICdBMTonICsgRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbCkgKyAod29ya3NoZWV0RGF0YS5yb3dDb3VudCk7XG5cbiAgICAgICAgICAgICAgICBjb2xzICs9ICc8Y29scz4nO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNNdWx0aUNvbHVtbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBkaWN0aW9uYXJ5LmNvbHVtbldpZHRoc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgd2lkdGggcHJvdmlkZWQgaW4gdGhlIG9wdGlvbnMgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGhJblR3aXBzID0gd29ya3NoZWV0RGF0YS5vcHRpb25zLmNvbHVtbldpZHRoICE9PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya3NoZWV0RGF0YS5vcHRpb25zLmNvbHVtbldpZHRoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KCgod2lkdGggLyA5NikgKiAxNC40KSwgV29ya3NoZWV0RmlsZS5NSU5fV0lEVEgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEod2lkdGhJblR3aXBzID4gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aEluVHdpcHMgPSBXb3Jrc2hlZXRGaWxlLk1JTl9XSURUSDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY29scyArPSBgPGNvbCBtaW49XCIkeyhqICsgMSl9XCIgbWF4PVwiJHsoaiArIDEpfVwiIHdpZHRoPVwiJHt3aWR0aEluVHdpcHN9XCIgY3VzdG9tV2lkdGg9XCIxXCIvPmA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb2xzICs9IGA8Y29sIG1pbj1cIjFcIiBtYXg9XCIke3dvcmtzaGVldERhdGEuY29sdW1uQ291bnR9XCIgd2lkdGg9XCIxNVwiIGN1c3RvbVdpZHRoPVwiMVwiLz5gO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4T2ZMYXN0UGlubmVkQ29sdW1uID0gd29ya3NoZWV0RGF0YS5pbmRleE9mTGFzdFBpbm5lZENvbHVtbjtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm96ZW5Db2x1bW5Db3VudCA9IGluZGV4T2ZMYXN0UGlubmVkQ29sdW1uICsgMTtcbiAgICAgICAgICAgICAgICBsZXQgZmlyc3RDZWxsID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGZyb3plbkNvbHVtbkNvdW50KSArIGZyZWV6ZUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4T2ZMYXN0UGlubmVkQ29sdW1uICE9PSB1bmRlZmluZWQgJiYgaW5kZXhPZkxhc3RQaW5uZWRDb2x1bW4gIT09IC0xICYmXG4gICAgICAgICAgICAgICAgICAgICF3b3Jrc2hlZXREYXRhLm9wdGlvbnMuaWdub3JlUGlubmluZyAmJlxuICAgICAgICAgICAgICAgICAgICAhd29ya3NoZWV0RGF0YS5vcHRpb25zLmlnbm9yZUNvbHVtbnNPcmRlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZyZWV6ZVBhbmUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYDxwYW5lIHhTcGxpdD1cIiR7ZnJvemVuQ29sdW1uQ291bnR9XCIgeVNwbGl0PVwiJHtmcmVlemVIZWFkZXJzIC0gMX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnRDZWxsPVwiJHtmaXJzdENlbGx9XCIgYWN0aXZlUGFuZT1cInRvcFJpZ2h0XCIgc3RhdGU9XCJmcm96ZW5cIi8+YDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHdvcmtzaGVldERhdGEub3B0aW9ucy5mcmVlemVIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Q2VsbCA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbigwKSArIGZyZWV6ZUhlYWRlcnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZnJlZXplUGFuZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBgPHBhbmUgeFNwbGl0PVwiMFwiIHlTcGxpdD1cIiR7ZnJlZXplSGVhZGVycyAtIDF9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICB0b3BMZWZ0Q2VsbD1cIiR7Zmlyc3RDZWxsfVwiIGFjdGl2ZVBhbmU9XCJ0b3BSaWdodFwiIHN0YXRlPVwiZnJvemVuXCIvPmA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5XaWR0aCA9IHdvcmtzaGVldERhdGEub3B0aW9ucy5jb2x1bW5XaWR0aCA/IHdvcmtzaGVldERhdGEub3B0aW9ucy5jb2x1bW5XaWR0aCA6IDIwO1xuICAgICAgICAgICAgICAgIGNvbHMgKz0gYDxjb2xzPjxjb2wgbWluPVwiMVwiIG1heD1cIiR7d29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudH1cIiB3aWR0aD1cIiR7Y29sdW1uV2lkdGh9XCIgY3VzdG9tV2lkdGg9XCIxXCIvPmA7XG5cbiAgICAgICAgICAgICAgICBpZiAod29ya3NoZWV0RGF0YS5vcHRpb25zLmZyZWV6ZUhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKDApICsgZnJlZXplSGVhZGVycztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmVlemVQYW5lID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGA8cGFuZSB4U3BsaXQ9XCIwXCIgeVNwbGl0PVwiJHtmcmVlemVIZWFkZXJzIC0gMX1cIlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRvcExlZnRDZWxsPVwiJHtmaXJzdENlbGx9XCIgYWN0aXZlUGFuZT1cInRvcFJpZ2h0XCIgc3RhdGU9XCJmcm96ZW5cIi8+YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3b3Jrc2hlZXREYXRhLmhhc1N1bW1hcmllcykge1xuICAgICAgICAgICAgICAgIGNvbHMgKz0gYDxjb2wgbWluPVwiJHt3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50ICsgMn1cIiBtYXg9XCIke3dvcmtzaGVldERhdGEuY29sdW1uQ291bnQgKyAyfVwiIGhpZGRlbj1cIjFcIi8+YDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29scyArPSAnPC9jb2xzPic7XG5cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0RhdGFSZWNvcmRzQXN5bmMod29ya3NoZWV0RGF0YSwgKHJvd3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoZWV0RGF0YSArPSByb3dzO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hlZXREYXRhICs9ICc8L3NoZWV0RGF0YT4nO1xuXG4gICAgICAgICAgICAgICAgaWYgKChoYXNNdWx0aUNvbHVtbkhlYWRlciB8fCBoYXNNdWx0aVJvd0hlYWRlcikgJiYgdGhpcy5tZXJnZUNlbGxzQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGVldERhdGEgKz0gYDxtZXJnZUNlbGxzIGNvdW50PVwiJHt0aGlzLm1lcmdlQ2VsbHNDb3VudGVyfVwiPiR7dGhpcy5tZXJnZUNlbGxTdHJ9PC9tZXJnZUNlbGxzPmA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZG9uZShjb2xzLCB0aGlzLnNoZWV0RGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcHJvY2Vzc0RhdGFSZWNvcmRzQXN5bmMod29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSwgZG9uZTogKHJvd3M6IHN0cmluZykgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCByb3dEYXRhQXJyID0gW107XG4gICAgICAgIGNvbnN0IGhlaWdodCA9ICB3b3Jrc2hlZXREYXRhLm9wdGlvbnMucm93SGVpZ2h0O1xuICAgICAgICB0aGlzLnJvd0hlaWdodCA9IGhlaWdodCA/ICcgaHQ9XCInICsgaGVpZ2h0ICsgJ1wiIGN1c3RvbUhlaWdodD1cIjFcIicgOiAnJztcblxuICAgICAgICBjb25zdCBpc0hpZXJhcmNoaWNhbEdyaWQgPSB3b3Jrc2hlZXREYXRhLmlzSGllcmFyY2hpY2FsO1xuICAgICAgICBjb25zdCBoYXNVc2VyU2V0SW5kZXggPSB3b3Jrc2hlZXREYXRhLm93bmVyLmNvbHVtbnMuc29tZShjID0+IGMuZXhwb3J0SW5kZXggIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgICAgbGV0IHJlY29yZEhlYWRlcnMgPSBbXTtcblxuICAgICAgICB5aWVsZGluZ0xvb3Aod29ya3NoZWV0RGF0YS5yb3dDb3VudCAtIHdvcmtzaGVldERhdGEubXVsdGlDb2x1bW5IZWFkZXJSb3dzIC0gMSwgMTAwMCxcbiAgICAgICAgICAgIChpKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF3b3Jrc2hlZXREYXRhLmlzRW1wdHkpe1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzSGllcmFyY2hpY2FsR3JpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1VzZXJTZXRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZEhlYWRlcnMgPSB3b3Jrc2hlZXREYXRhLnJvb3RLZXlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRIZWFkZXJzID0gd29ya3NoZWV0RGF0YS5vd25lci5jb2x1bW5zXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiBjLmhlYWRlclR5cGUgPT09IEV4cG9ydEhlYWRlclR5cGUuQ29sdW1uSGVhZGVyICYmICFjLnNraXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXgtYi5zdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5waW5uZWRJbmRleC1iLnBpbm5lZEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGMgPT4gYy5maWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmQgPSB3b3Jrc2hlZXREYXRhLmRhdGFbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5IZWFkZXJSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRPd25lciA9IHdvcmtzaGVldERhdGEub3duZXJzLmdldChyZWNvcmQub3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc011bHRpQ29sdW1uSGVhZGVycyA9IHJlY29yZE93bmVyLmNvbHVtbnMuc29tZShjID0+ICFjLnNraXAgJiYgYy5oZWFkZXJUeXBlID09PSBFeHBvcnRIZWFkZXJUeXBlLk11bHRpQ29sdW1uSGVhZGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNNdWx0aUNvbHVtbkhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oR3JpZFByaW50TXVsdGlDb2xIZWFkZXJzKHdvcmtzaGVldERhdGEsIHJvd0RhdGFBcnIsIHJlY29yZCwgcmVjb3JkT3duZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkSGVhZGVycyA9IE9iamVjdC5rZXlzKHdvcmtzaGVldERhdGEuZGF0YVtpXS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJvd0RhdGFBcnIucHVzaCh0aGlzLnByb2Nlc3NSb3cod29ya3NoZWV0RGF0YSwgaSwgcmVjb3JkSGVhZGVycywgaXNIaWVyYXJjaGljYWxHcmlkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICBkb25lKHJvd0RhdGFBcnIuam9pbignJykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhHcmlkUHJpbnRNdWx0aUNvbEhlYWRlcnMod29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSwgcm93RGF0YUFycjogYW55W10sIHJlY29yZDogSUV4cG9ydFJlY29yZCxcbiAgICAgICAgb3duZXI6IElDb2x1bW5MaXN0KSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgb3duZXIubWF4TGV2ZWw7IGorKykge1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkTGV2ZWwgPSByZWNvcmQubGV2ZWw7XG4gICAgICAgICAgICBjb25zdCBvdXRsaW5lTGV2ZWwgPSByZWNvcmRMZXZlbCA+IDAgPyBgIG91dGxpbmVMZXZlbD1cIiR7cmVjb3JkTGV2ZWx9XCJgIDogJyc7XG4gICAgICAgICAgICB0aGlzLm1heE91dGxpbmVMZXZlbCA9IHRoaXMubWF4T3V0bGluZUxldmVsIDwgcmVjb3JkTGV2ZWwgPyByZWNvcmRMZXZlbCA6IHRoaXMubWF4T3V0bGluZUxldmVsO1xuICAgICAgICAgICAgY29uc3Qgc0hpZGRlbiA9IHJlY29yZC5oaWRkZW4gPyBgIGhpZGRlbj1cIjFcImAgOiAnJztcblxuICAgICAgICAgICAgdGhpcy5yb3dJbmRleCsrO1xuICAgICAgICAgICAgbGV0IHJvdyA9IGA8cm93IHI9XCIke3RoaXMucm93SW5kZXh9XCIke3RoaXMucm93SGVpZ2h0fSR7b3V0bGluZUxldmVsfSR7c0hpZGRlbn0+YDtcblxuICAgICAgICAgICAgY29uc3QgaGVhZGVyc0ZvckxldmVsID0gb3duZXIuY29sdW1uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiAoYy5sZXZlbCA8IGogJiZcbiAgICAgICAgICAgICAgICAgICAgYy5oZWFkZXJUeXBlICE9PSBFeHBvcnRIZWFkZXJUeXBlLk11bHRpQ29sdW1uSGVhZGVyIHx8IGMubGV2ZWwgPT09IGopICYmIGMuY29sdW1uU3BhbiA+IDAgJiYgIWMuc2tpcClcbiAgICAgICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5zdGFydEluZGV4IC0gYi5zdGFydEluZGV4KVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnBpbm5lZEluZGV4IC0gYi5waW5uZWRJbmRleCk7XG5cbiAgICAgICAgICAgIGxldCBzdGFydFZhbHVlID0gMCArIHJlY29yZC5sZXZlbDtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBjdXJyZW50Q29sIG9mIGhlYWRlcnNGb3JMZXZlbCkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29sLmxldmVsID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb2x1bW5Db29yZGluYXRlO1xuICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db29yZGluYXRlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihzdGFydFZhbHVlKSArIHRoaXMucm93SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sdW1uVmFsdWUgPSB3b3Jrc2hlZXREYXRhLmRhdGFEaWN0aW9uYXJ5LnNhdmVWYWx1ZShjdXJyZW50Q29sLmhlYWRlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJvdyArPSBgPGMgcj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX1cIiBzPVwiM1wiIHQ9XCJzXCI+PHY+JHtjb2x1bW5WYWx1ZX08L3Y+PC9jPmA7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGogIT09IG93bmVyLm1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlQ2VsbHNDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlQ2VsbFN0ciArPSBgIDxtZXJnZUNlbGwgcmVmPVwiJHtjb2x1bW5Db29yZGluYXRlfTpgO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbC5oZWFkZXJUeXBlID09PSBFeHBvcnRIZWFkZXJUeXBlLkNvbHVtbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbkNvb3JkaW5hdGUgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oc3RhcnRWYWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5yb3dJbmRleCArIG93bmVyLm1heExldmVsIC0gY3VycmVudENvbC5sZXZlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAxOyBrIDwgY3VycmVudENvbC5jb2x1bW5TcGFuOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ29vcmRpbmF0ZSA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihzdGFydFZhbHVlICsgaykgKyB0aGlzLnJvd0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3cgKz0gYDxjIHI9XCIke2NvbHVtbkNvb3JkaW5hdGV9XCIgcz1cIjNcIiAvPmA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lcmdlQ2VsbFN0ciArPSBgJHtjb2x1bW5Db29yZGluYXRlfVwiIC8+YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHN0YXJ0VmFsdWUgKz0gY3VycmVudENvbC5jb2x1bW5TcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93ICs9IGA8L3Jvdz5gO1xuICAgICAgICAgICAgcm93RGF0YUFyci5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHByb2Nlc3NSb3cod29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSwgaTogbnVtYmVyLCBoZWFkZXJzRm9yTGV2ZWw6IGFueVtdLCBpc0hpZXJhcmNoaWNhbEdyaWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgcmVjb3JkID0gd29ya3NoZWV0RGF0YS5kYXRhW2ldO1xuXG4gICAgICAgIGNvbnN0IHJvd0RhdGEgPSBuZXcgQXJyYXkod29ya3NoZWV0RGF0YS5jb2x1bW5Db3VudCArIDIpO1xuXG4gICAgICAgIGNvbnN0IHJvd0xldmVsID0gcmVjb3JkLmxldmVsO1xuICAgICAgICBjb25zdCBvdXRsaW5lTGV2ZWwgPSByb3dMZXZlbCA+IDAgPyBgIG91dGxpbmVMZXZlbD1cIiR7cm93TGV2ZWx9XCJgIDogJyc7XG4gICAgICAgIHRoaXMubWF4T3V0bGluZUxldmVsID0gdGhpcy5tYXhPdXRsaW5lTGV2ZWwgPCByb3dMZXZlbCA/IHJvd0xldmVsIDogdGhpcy5tYXhPdXRsaW5lTGV2ZWw7XG5cbiAgICAgICAgY29uc3Qgc0hpZGRlbiA9IHJlY29yZC5oaWRkZW4gPyBgIGhpZGRlbj1cIjFcImAgOiAnJztcblxuICAgICAgICB0aGlzLnJvd0luZGV4Kys7XG4gICAgICAgIGNvbnN0IHBpdm90R3JpZENvbHVtbnMgPSB0aGlzLnBpdm90R3JpZFJvd0hlYWRlcnNNYXAuZ2V0KHRoaXMucm93SW5kZXgpID8/IFwiXCI7XG5cbiAgICAgICAgcm93RGF0YVswXSA9IGA8cm93IHI9XCIke3RoaXMucm93SW5kZXh9XCIke3RoaXMucm93SGVpZ2h0fSR7b3V0bGluZUxldmVsfSR7c0hpZGRlbn0+JHtwaXZvdEdyaWRDb2x1bW5zfWA7XG4gICAgICAgIGNvbnN0IGtleXMgPSB3b3Jrc2hlZXREYXRhLmlzU3BlY2lhbERhdGEgPyBbcmVjb3JkLmRhdGFdIDogaGVhZGVyc0ZvckxldmVsO1xuICAgICAgICBjb25zdCBpc0RhdGFSZWNvcmQgPSByZWNvcmQudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5IaWVyYXJjaGljYWxHcmlkUmVjb3JkXG4gICAgICAgICAgICB8fCByZWNvcmQudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5EYXRhUmVjb3JkXG4gICAgICAgICAgICB8fCByZWNvcmQudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5Hcm91cGVkUmVjb3JkXG4gICAgICAgICAgICB8fCByZWNvcmQudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5UcmVlR3JpZFJlY29yZDtcblxuICAgICAgICBjb25zdCBpc1ZhbGlkUmVjb3JkVHlwZSA9IGlzRGF0YVJlY29yZCB8fCByZWNvcmQudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5TdW1tYXJ5UmVjb3JkO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkUmVjb3JkVHlwZSAmJiB3b3Jrc2hlZXREYXRhLmhhc1N1bW1hcmllcykge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlU3VtbWFyeURpbWVuc2lvbnMocmVjb3JkLCBpc0RhdGFSZWNvcmQsIHdvcmtzaGVldERhdGEuaXNHcm91cGVkR3JpZClcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgY29sID0gaiArIChpc0hpZXJhcmNoaWNhbEdyaWQgPyByb3dMZXZlbCA6IHdvcmtzaGVldERhdGEuaXNQaXZvdEdyaWQgPyB3b3Jrc2hlZXREYXRhLm93bmVyLm1heFJvd0xldmVsIDogMCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNlbGxEYXRhID0gdGhpcy5nZXRDZWxsRGF0YSh3b3Jrc2hlZXREYXRhLCBpLCBjb2wsIGtleXNbal0pO1xuXG4gICAgICAgICAgICByb3dEYXRhW2ogKyAxXSA9IGNlbGxEYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgcm93RGF0YVtrZXlzLmxlbmd0aCArIDFdID0gJzwvcm93Pic7XG5cbiAgICAgICAgcmV0dXJuIHJvd0RhdGEuam9pbignJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDZWxsRGF0YSh3b3Jrc2hlZXREYXRhOiBXb3Jrc2hlZXREYXRhLCByb3c6IG51bWJlciwgY29sdW1uOiBudW1iZXIsIGtleTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGljdGlvbmFyeSA9IHdvcmtzaGVldERhdGEuZGF0YURpY3Rpb25hcnk7XG4gICAgICAgIGxldCBjb2x1bW5OYW1lID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbHVtbikgKyAodGhpcy5yb3dJbmRleCk7XG4gICAgICAgIGNvbnN0IGZ1bGxSb3cgPSB3b3Jrc2hlZXREYXRhLmRhdGFbcm93XTtcbiAgICAgICAgY29uc3QgaXNIZWFkZXJSZWNvcmQgPSBmdWxsUm93LnR5cGUgPT09IEV4cG9ydFJlY29yZFR5cGUuSGVhZGVyUmVjb3JkO1xuICAgICAgICBjb25zdCBpc1N1bW1hcnlSZWNvcmQgPSBmdWxsUm93LnR5cGUgPT09IEV4cG9ydFJlY29yZFR5cGUuU3VtbWFyeVJlY29yZDtcbiAgICAgICAgY29uc3QgaXNWYWxpZFJlY29yZFR5cGUgPSBmdWxsUm93LnR5cGUgPT09IEV4cG9ydFJlY29yZFR5cGUuR3JvdXBlZFJlY29yZFxuICAgICAgICAgICAgfHwgZnVsbFJvdy50eXBlID09PSBFeHBvcnRSZWNvcmRUeXBlLkRhdGFSZWNvcmRcbiAgICAgICAgICAgIHx8IGZ1bGxSb3cudHlwZSA9PT0gRXhwb3J0UmVjb3JkVHlwZS5IaWVyYXJjaGljYWxHcmlkUmVjb3JkXG4gICAgICAgICAgICB8fCBmdWxsUm93LnR5cGUgPT09IEV4cG9ydFJlY29yZFR5cGUuVHJlZUdyaWRSZWNvcmQ7XG5cbiAgICAgICAgdGhpcy5maXJzdERhdGFSb3cgPSB0aGlzLmZpcnN0RGF0YVJvdyA+IHRoaXMucm93SW5kZXggPyB0aGlzLnJvd0luZGV4IDogdGhpcy5maXJzdERhdGFSb3c7XG5cbiAgICAgICAgY29uc3QgY2VsbFZhbHVlID0gd29ya3NoZWV0RGF0YS5pc1NwZWNpYWxEYXRhID9cbiAgICAgICAgICAgIGZ1bGxSb3cuZGF0YSA6XG4gICAgICAgICAgICBmdWxsUm93LmRhdGFba2V5XTtcblxuICAgICAgICBpZiAoY2VsbFZhbHVlID09PSBHUklEX0xFVkVMX0NPTCB8fCBrZXkgPT09IEdSSURfTEVWRUxfQ09MKSB7XG4gICAgICAgICAgICBjb2x1bW5OYW1lID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQgKyAxKSArICh0aGlzLnJvd0luZGV4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3b3Jrc2hlZXREYXRhLmhhc1N1bW1hcmllcyAmJiAoaXNWYWxpZFJlY29yZFR5cGUgfHwgKHdvcmtzaGVldERhdGEuaXNHcm91cGVkR3JpZCAmJiBpc1N1bW1hcnlSZWNvcmQpKSkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdW1tYXJ5Q29vcmRpbmF0ZXMoY29sdW1uTmFtZSwga2V5LCBmdWxsUm93LmhpZXJhcmNoaWNhbE93bmVyLCB3b3Jrc2hlZXREYXRhLmlzR3JvdXBlZEdyaWQgJiYgaXNTdW1tYXJ5UmVjb3JkKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZ1bGxSb3cuc3VtbWFyeUtleSAmJiBmdWxsUm93LnN1bW1hcnlLZXkgPT09IEdSSURfUk9PVF9TVU1NQVJZICYmIGtleSAhPT0gR1JJRF9MRVZFTF9DT0wgJiYgd29ya3NoZWV0RGF0YS5pc0dyb3VwZWRHcmlkKSB7XG4gICAgICAgICAgICB0aGlzLnNldFJvb3RTdW1tYXJ5U3RhcnRDb29yZGluYXRlKGNvbHVtbiwga2V5KTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZmlyc3RDb2x1bW4gPiBjb2x1bW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFJvb3RTdW1tYXJ5U3RhcnRDb29yZGluYXRlKHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQgKyAxLCBHUklEX0xFVkVMX0NPTCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdENvbHVtbiA9IGNvbHVtbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHRhcmdldENvbEFyciA9IEFycmF5LmZyb20od29ya3NoZWV0RGF0YS5vd25lcnMudmFsdWVzKCkpLm1hcChhcnIgPT4gYXJyLmNvbHVtbnMpLmZpbmQocHJvZHVjdCA9PiBwcm9kdWN0LnNvbWUoaXRlbSA9PiBpdGVtLmZpZWxkID09PSBrZXkpKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Q29sID0gdGFyZ2V0Q29sQXJyID8gdGFyZ2V0Q29sQXJyLmZpbmQoY29sID0+IGNvbC5maWVsZCA9PT0ga2V5KSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoKGNlbGxWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGNlbGxWYWx1ZSA9PT0gbnVsbCkgJiYgIXdvcmtzaGVldERhdGEuaGFzU3VtbWFyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gYDxjIHI9XCIke2NvbHVtbk5hbWV9XCIgcz1cIjFcIi8+YDtcbiAgICAgICAgfSBlbHNlIGlmICgod29ya3NoZWV0RGF0YS5oYXNTdW1tYXJpZXMgJiYgKGlzVmFsaWRSZWNvcmRUeXBlIHx8IGlzSGVhZGVyUmVjb3JkKSkgfHwgIXdvcmtzaGVldERhdGEuaGFzU3VtbWFyaWVzKSB7XG4gICAgICAgICAgICBjb25zdCBzYXZlZFZhbHVlID0gZGljdGlvbmFyeS5zYXZlVmFsdWUoY2VsbFZhbHVlLCBpc0hlYWRlclJlY29yZCk7XG4gICAgICAgICAgICBjb25zdCBpc1NhdmVkQXNTdHJpbmcgPSBzYXZlZFZhbHVlICE9PSAtMTtcblxuICAgICAgICAgICAgY29uc3QgaXNTYXZlZEFzRGF0ZSA9ICFpc1NhdmVkQXNTdHJpbmcgJiYgY2VsbFZhbHVlIGluc3RhbmNlb2YgRGF0ZTtcblxuICAgICAgICAgICAgbGV0IHZhbHVlID0gaXNTYXZlZEFzU3RyaW5nID8gc2F2ZWRWYWx1ZSA6IGNlbGxWYWx1ZTtcblxuICAgICAgICAgICAgaWYgKGlzU2F2ZWRBc0RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0aW1lWm9uZU9mZnNldCA9IHZhbHVlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc29TdHJpbmcgPSAobmV3IERhdGUodmFsdWUgLSB0aW1lWm9uZU9mZnNldCkpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBpc29TdHJpbmcuc3Vic3RyaW5nKDAsIGlzb1N0cmluZy5pbmRleE9mKCcuJykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gaXNTYXZlZEFzU3RyaW5nID8gYCB0PVwic1wiYCA6IGlzU2F2ZWRBc0RhdGUgPyBgIHQ9XCJkXCJgIDogJyc7XG5cbiAgICAgICAgICAgIGNvbnN0IGlzVGltZSA9IHRhcmdldENvbD8uZGF0YVR5cGUgPT09ICd0aW1lJztcbiAgICAgICAgICAgIGNvbnN0IGlzRGF0ZVRpbWUgPSB0YXJnZXRDb2w/LmRhdGFUeXBlID09PSAnZGF0ZVRpbWUnO1xuICAgICAgICAgICAgY29uc3QgaXNQZXJjZW50YWdlID0gdGFyZ2V0Q29sPy5kYXRhVHlwZSA9PT0gJ3BlcmNlbnQnO1xuICAgICAgICAgICAgY29uc3QgaXNDb2x1bW5DdXJyZW5jeVR5cGUgPSB0YXJnZXRDb2w/LmRhdGFUeXBlID09PSAnY3VycmVuY3knO1xuXG4gICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBpc1BlcmNlbnRhZ2UgPyBgIHM9XCIxMlwiYCA6IGlzRGF0ZVRpbWUgPyBgIHM9XCIxMVwiYCA6IGlzVGltZSA/IGAgcz1cIjEwXCJgIDogaXNIZWFkZXJSZWNvcmQgPyBgIHM9XCIzXCJgIDogaXNTYXZlZEFzU3RyaW5nID8gJycgOiBpc1NhdmVkQXNEYXRlID8gYCBzPVwiMlwiYCA6IGlzQ29sdW1uQ3VycmVuY3lUeXBlID8gYCBzPVwiJHt0aGlzLmN1cnJlbmN5U3R5bGVNYXAuZ2V0KHRhcmdldENvbC5jdXJyZW5jeUNvZGUpPy5zdHlsZVhmIHx8IDB9XCJgIDogYCBzPVwiMVwiYDtcblxuICAgICAgICAgICAgcmV0dXJuIGA8YyByPVwiJHtjb2x1bW5OYW1lfVwiJHt0eXBlfSR7Zm9ybWF0fT48dj4ke3ZhbHVlfTwvdj48L2M+YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzdW1tYXJ5RnVuYyA9IGBcIiR7Y2VsbFZhbHVlID8/IFwiXCJ9XCJgO1xuXG4gICAgICAgICAgICBpZiAoaXNTdW1tYXJ5UmVjb3JkICYmIGNlbGxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbk1hcEtleSA9IHRoaXMuaXNWYWxpZEdyaWQgPyBmdWxsUm93LmhpZXJhcmNoaWNhbE93bmVyID8/IEdSSURfUEFSRU5UIDogbnVsbDtcbiAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9IHdvcmtzaGVldERhdGEuaXNHcm91cGVkR3JpZCA/IHdvcmtzaGVldERhdGEubWF4TGV2ZWwgOiBmdWxsUm93LmxldmVsO1xuXG4gICAgICAgICAgICAgICAgc3VtbWFyeUZ1bmMgPSB0aGlzLmdldFN1bW1hcnlGdW5jdGlvbihjZWxsVmFsdWUubGFiZWwsIGtleSwgZGltZW5zaW9uTWFwS2V5LCBsZXZlbCwgdGFyZ2V0Q29sKTtcblxuICAgICAgICAgICAgICAgIGlmICghc3VtbWFyeUZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbFN0ciA9IGAke2NlbGxWYWx1ZS5sYWJlbH06ICR7Y2VsbFZhbHVlLnZhbHVlfWA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhdmVkVmFsdWUgPSBkaWN0aW9uYXJ5LnNhdmVWYWx1ZShjZWxsU3RyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgPGMgcj1cIiR7Y29sdW1uTmFtZX1cIiB0PVwic1wiIHM9XCIxXCI+PHY+JHtzYXZlZFZhbHVlfTwvdj48L2M+YDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYDxjIHI9XCIke2NvbHVtbk5hbWV9XCI+PGYgdD1cImFycmF5XCIgcmVmPVwiJHtjb2x1bW5OYW1lfVwiPiR7c3VtbWFyeUZ1bmN9PC9mPjwvYz5gO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYDxjIHI9XCIke2NvbHVtbk5hbWV9XCIgcz1cIjFcIj48Zj4ke3N1bW1hcnlGdW5jfTwvZj48L2M+YDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVzb2x2ZVN1bW1hcnlEaW1lbnNpb25zKHJlY29yZDogSUV4cG9ydFJlY29yZCwgaXNEYXRhUmVjb3JkOiBib29sZWFuLCBpc0dyb3VwZWRHcmlkOiBib29sZWFuKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWRHcmlkICYmXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRIaWVyYXJjaGljYWxPd25lciAhPT0gJycgJiZcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEhpZXJhcmNoaWNhbE93bmVyICE9PSByZWNvcmQub3duZXIgJiZcbiAgICAgICAgICAgICF0aGlzLmhpZXJhcmNoaWNhbERpbWVuc2lvbk1hcC5nZXQodGhpcy5jdXJyZW50SGllcmFyY2hpY2FsT3duZXIpKSB7XG4gICAgICAgICAgICB0aGlzLmhpZXJhcmNoaWNhbERpbWVuc2lvbk1hcC5zZXQodGhpcy5jdXJyZW50SGllcmFyY2hpY2FsT3duZXIsIG5ldyBNYXAodGhpcy5kaW1lbnNpb25NYXApKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRGF0YVJlY29yZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN1bW1hcnlPd25lciAhPT0gcmVjb3JkLnN1bW1hcnlLZXkgfHwgdGhpcy5jdXJyZW50SGllcmFyY2hpY2FsT3duZXIgIT09IHJlY29yZC5oaWVyYXJjaGljYWxPd25lcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZGltZW5zaW9uTWFwLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFN1bW1hcnlPd25lciA9IHJlY29yZC5zdW1tYXJ5S2V5O1xuXG4gICAgICAgICAgICAvLyBGb3IgZ3JvdXBlZCBncmlkIHdlIG5lZWQgdG8gcmVzZXQgdGhlIHBhcmVudCBtYXBcbiAgICAgICAgICAgIC8vIHNvIHdlIGNhbiBjaGFuZ2UgdGhlIHN0YXJ0Q29vcmRpbmF0ZSBmb3IgZWFjaCByZWNvcmRcbiAgICAgICAgICAgIGlmIChpc0dyb3VwZWRHcmlkICYmIHRoaXMuY3VycmVudEhpZXJhcmNoaWNhbE93bmVyICE9PSAnJyAmJiByZWNvcmQuaGllcmFyY2hpY2FsT3duZXIgPT09IEdSSURfUEFSRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWVyYXJjaGljYWxEaW1lbnNpb25NYXAuZGVsZXRlKEdSSURfUEFSRU5UKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRIaWVyYXJjaGljYWxPd25lciA9IHJlY29yZC5oaWVyYXJjaGljYWxPd25lcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0U3VtbWFyeUNvb3JkaW5hdGVzKGNvbHVtbk5hbWU6IHN0cmluZywga2V5OiBzdHJpbmcsIGhpZXJhcmNoaWNhbE93bmVyOiBzdHJpbmcsIHVzZUxhc3RWYWxpZEVuZENvb3JkaW5hdGU6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGltZW5zaW9uTWFwID0gdGhpcy5oaWVyYXJjaGljYWxEaW1lbnNpb25NYXAuZ2V0KGhpZXJhcmNoaWNhbE93bmVyKSA/PyB0aGlzLmRpbWVuc2lvbk1hcDtcblxuICAgICAgICBpZiAoIXRhcmdldERpbWVuc2lvbk1hcC5nZXQoa2V5KSkge1xuICAgICAgICAgICAgY29uc3QgaW5pdGlhbERpbWVuc2lvbnM6IERpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnRDb29yZGluYXRlOiBjb2x1bW5OYW1lLFxuICAgICAgICAgICAgICAgIGVuZENvb3JkaW5hdGU6IGNvbHVtbk5hbWVcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRhcmdldERpbWVuc2lvbk1hcC5zZXQoa2V5LCBpbml0aWFsRGltZW5zaW9ucylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh1c2VMYXN0VmFsaWRFbmRDb29yZGluYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRFbmRDb29yZGluYXRlcyh0YXJnZXREaW1lbnNpb25NYXAsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXREaW1lbnNpb25NYXAuZ2V0KGtleSkuZW5kQ29vcmRpbmF0ZSA9IGNvbHVtbk5hbWU7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0VmFsaWRSb3cgPSB0YXJnZXREaW1lbnNpb25NYXAuZ2V0KGtleSkuZW5kQ29vcmRpbmF0ZS5tYXRjaCgvW2Etel0rfFteYS16XSsvZ2kpWzFdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkR3JpZCAmJiAhdXNlTGFzdFZhbGlkRW5kQ29vcmRpbmF0ZSAmJiBoaWVyYXJjaGljYWxPd25lciAhPT0gR1JJRF9QQVJFTlQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE1hcCA9IHRoaXMuaGllcmFyY2hpY2FsRGltZW5zaW9uTWFwLmdldChHUklEX1BBUkVOVCk7XG4gICAgICAgICAgICB0aGlzLnNldEVuZENvb3JkaW5hdGVzKHBhcmVudE1hcCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldEVuZENvb3JkaW5hdGVzKG1hcDogTWFwPHN0cmluZywgRGltZW5zaW9ucz4sIHVzZUxhc3RWYWxpZEVuZENvb3JkaW5hdGUgPSBmYWxzZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGEgb2YgbWFwLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2xOYW1lID0gYS5lbmRDb29yZGluYXRlLm1hdGNoKC9bYS16XSt8W15hLXpdKy9naSlbMF07XG4gICAgICAgICAgICBhLmVuZENvb3JkaW5hdGUgPSBgJHtjb2xOYW1lfSR7dXNlTGFzdFZhbGlkRW5kQ29vcmRpbmF0ZSA/IHRoaXMubGFzdFZhbGlkUm93IDogdGhpcy5yb3dJbmRleH1gO1xuICAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0U3VtbWFyeUZ1bmN0aW9uKHR5cGU6IHN0cmluZywga2V5OiBzdHJpbmcsIGRpbWVuc2lvbk1hcEtleTogYW55LCByZWNvcmRMZXZlbDogbnVtYmVyLCBjb2w6IElDb2x1bW5JbmZvKTogc3RyaW5nIHtcbiAgICAgICAgY29uc3QgZGltZW5zaW9uTWFwID0gZGltZW5zaW9uTWFwS2V5ID8gdGhpcy5oaWVyYXJjaGljYWxEaW1lbnNpb25NYXAuZ2V0KGRpbWVuc2lvbk1hcEtleSkgOiB0aGlzLmRpbWVuc2lvbk1hcDtcbiAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGRpbWVuc2lvbk1hcC5nZXQoa2V5KTtcbiAgICAgICAgY29uc3QgbGV2ZWxEaW1lbnNpb25zID0gZGltZW5zaW9uTWFwLmdldChHUklEX0xFVkVMX0NPTCk7XG5cbiAgICAgICAgbGV0IGZ1bmMgPSAnJztcbiAgICAgICAgbGV0IGZ1bmNUeXBlID0gJyc7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgY29uc3QgY3VycmVuY3lJbmZvID0gdGhpcy5jdXJyZW5jeVN0eWxlTWFwLmdldChjb2wuY3VycmVuY3lDb2RlKTtcblxuICAgICAgICBzd2l0Y2godHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiY291bnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYFwiQ291bnQ6IFwiJmFtcDtfeGxmbi5DT1VOVElGKCR7bGV2ZWxEaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtsZXZlbERpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0sICR7cmVjb3JkTGV2ZWx9KWBcbiAgICAgICAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgICAgICAgICBmdW5jID0gYF94bGZuLk1JTihfeGxmbi5JRigke2xldmVsRGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7bGV2ZWxEaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9PSR7cmVjb3JkTGV2ZWx9LCAke2RpbWVuc2lvbnMuc3RhcnRDb29yZGluYXRlfToke2RpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0pKWBcbiAgICAgICAgICAgICAgICBmdW5jVHlwZSA9IGBcIk1pbjogXCImYW1wO2A7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jVHlwZSArIChjb2wuZGF0YVR5cGUgPT09ICdjdXJyZW5jeScgJiYgY3VycmVuY3lJbmZvXG4gICAgICAgICAgICAgICAgICAgID8gYF94bGZuLlRFWFQoJHtmdW5jfSwgXCIke2N1cnJlbmN5SW5mby5zeW1ib2x9IywjIzAuMDBcIilgXG4gICAgICAgICAgICAgICAgICAgIDogYCR7ZnVuY31gKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgICAgICAgICBmdW5jID0gYF94bGZuLk1BWChfeGxmbi5JRigke2xldmVsRGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7bGV2ZWxEaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9PSR7cmVjb3JkTGV2ZWx9LCAke2RpbWVuc2lvbnMuc3RhcnRDb29yZGluYXRlfToke2RpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0pKWBcbiAgICAgICAgICAgICAgICBmdW5jVHlwZSA9IGBcIk1heDogXCImYW1wO2A7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jVHlwZSArIChjb2wuZGF0YVR5cGUgPT09ICdjdXJyZW5jeScgJiYgY3VycmVuY3lJbmZvXG4gICAgICAgICAgICAgICAgICAgID8gYF94bGZuLlRFWFQoJHtmdW5jfSwgXCIke2N1cnJlbmN5SW5mby5zeW1ib2x9IywjIzAuMDBcIilgXG4gICAgICAgICAgICAgICAgICAgIDogYCR7ZnVuY31gKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIGNhc2UgXCJzdW1cIjpcbiAgICAgICAgICAgICAgICBmdW5jID0gIGBfeGxmbi5TVU1JRigke2xldmVsRGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7bGV2ZWxEaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9LCAke3JlY29yZExldmVsfSwgJHtkaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtkaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9KWBcbiAgICAgICAgICAgICAgICBmdW5jVHlwZSA9IGBcIlN1bTogXCImYW1wO2A7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jVHlwZSArIChjb2wuZGF0YVR5cGUgPT09ICdjdXJyZW5jeScgJiYgY3VycmVuY3lJbmZvXG4gICAgICAgICAgICAgICAgICAgID8gYF94bGZuLlRFWFQoJHtmdW5jfSwgXCIke2N1cnJlbmN5SW5mby5zeW1ib2x9IywjIzAuMDBcIilgXG4gICAgICAgICAgICAgICAgICAgIDogYCR7ZnVuY31gKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIGNhc2UgXCJhdmdcIjpcbiAgICAgICAgICAgICAgICBmdW5jID0gYF94bGZuLkFWRVJBR0VJRigke2xldmVsRGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7bGV2ZWxEaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9LCAke3JlY29yZExldmVsfSwgJHtkaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtkaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9KWBcbiAgICAgICAgICAgICAgICBmdW5jVHlwZSA9IGBcIkF2ZzogXCImYW1wO2A7XG5cbiAgICAgICAgICAgICAgICByZXN1bHQgPSBmdW5jVHlwZSArIChjb2wuZGF0YVR5cGUgPT09ICdjdXJyZW5jeScgJiYgY3VycmVuY3lJbmZvXG4gICAgICAgICAgICAgICAgICAgID8gYF94bGZuLlRFWFQoJHtmdW5jfSwgXCIke2N1cnJlbmN5SW5mby5zeW1ib2x9IywjIzAuMDBcIilgXG4gICAgICAgICAgICAgICAgICAgIDogYCR7ZnVuY31gKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIGNhc2UgXCJlYXJsaWVzdFwiOlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGdldCBkYXRlIGZvcm1hdCBmcm9tIGxvY2FsZVxuICAgICAgICAgICAgICAgIHJldHVybiBgXCJFYXJsaWVzdDogXCImYW1wO194bGZuLlRFWFQoX3hsZm4uTUlOKF94bGZuLklGKCR7bGV2ZWxEaW1lbnNpb25zLnN0YXJ0Q29vcmRpbmF0ZX06JHtsZXZlbERpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX09JHtyZWNvcmRMZXZlbH0sICR7ZGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7ZGltZW5zaW9ucy5lbmRDb29yZGluYXRlfSkpLCBcIm0vZC95eXl5XCIpYFxuICAgICAgICAgICAgY2FzZSBcImxhdGVzdFwiOlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IGdldCBkYXRlIGZvcm1hdCBmcm9tIGxvY2FsZVxuICAgICAgICAgICAgICAgIHJldHVybiBgXCJMYXRlc3Q6IFwiJmFtcDtfeGxmbi5URVhUKF94bGZuLk1BWChfeGxmbi5JRigke2xldmVsRGltZW5zaW9ucy5zdGFydENvb3JkaW5hdGV9OiR7bGV2ZWxEaW1lbnNpb25zLmVuZENvb3JkaW5hdGV9PSR7cmVjb3JkTGV2ZWx9LCAke2RpbWVuc2lvbnMuc3RhcnRDb29yZGluYXRlfToke2RpbWVuc2lvbnMuZW5kQ29vcmRpbmF0ZX0pKSwgXCJtL2QveXl5eVwiKWBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2V0Um9vdFN1bW1hcnlTdGFydENvb3JkaW5hdGUoY29sdW1uOiBudW1iZXIsIGtleTogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0RGF0YVJlY29yZENvbE5hbWUgPSBFeGNlbFN0cmluZ3MuZ2V0RXhjZWxDb2x1bW4oY29sdW1uKSArICh0aGlzLmZpcnN0RGF0YVJvdyk7XG4gICAgICAgIGNvbnN0IHRhcmdldE1hcCA9IHRoaXMuaGllcmFyY2hpY2FsRGltZW5zaW9uTWFwLmdldChHUklEX1BBUkVOVCk7XG5cbiAgICAgICAgaWYgKHRhcmdldE1hcC5nZXQoa2V5KS5zdGFydENvb3JkaW5hdGUgIT09IGZpcnN0RGF0YVJlY29yZENvbE5hbWUpIHtcbiAgICAgICAgICAgIHRhcmdldE1hcC5nZXQoa2V5KS5zdGFydENvb3JkaW5hdGUgPSBmaXJzdERhdGFSZWNvcmRDb2xOYW1lO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwcmludEhlYWRlcnMod29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSwgaGVhZGVyc0ZvckxldmVsOiBJQ29sdW1uSW5mb1tdLCBpOiBudW1iZXIsIGlzVmVydGljYWw6IGJvb2xlYW4pIHtcbiAgICAgICAgbGV0IHN0YXJ0VmFsdWUgPSAwO1xuICAgICAgICBsZXQgc3RyID0gJyc7XG5cbiAgICAgICAgY29uc3QgaXNIaWVyYXJjaGljYWxHcmlkID0gd29ya3NoZWV0RGF0YS5pc0hpZXJhcmNoaWNhbDtcbiAgICAgICAgbGV0IHJvd1N0eWxlID0gaXNIaWVyYXJjaGljYWxHcmlkID8gJyBzPVwiM1wiJyA6ICcnO1xuICAgICAgICBjb25zdCBkaWN0aW9uYXJ5ID0gd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeTtcbiAgICAgICAgY29uc3Qgb3duZXIgPSB3b3Jrc2hlZXREYXRhLm93bmVyO1xuICAgICAgICBjb25zdCBtYXhMZXZlbCA9IGlzVmVydGljYWxcbiAgICAgICAgICAgID8gb3duZXIubWF4Um93TGV2ZWxcbiAgICAgICAgICAgIDogb3duZXIubWF4TGV2ZWw7XG5cbiAgICAgICAgZm9yIChjb25zdCBjdXJyZW50Q29sIG9mIGhlYWRlcnNGb3JMZXZlbCkge1xuICAgICAgICAgICAgY29uc3Qgc3Bhbkxlbmd0aCA9IGlzVmVydGljYWwgPyBjdXJyZW50Q29sLnJvd1NwYW4gOiBjdXJyZW50Q29sLmNvbHVtblNwYW47XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29sLmxldmVsID09PSBpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvbHVtbkNvb3JkaW5hdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY29sdW1uID0gaXNWZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucm93SW5kZXhcbiAgICAgICAgICAgICAgICAgICAgOiBzdGFydFZhbHVlICsgKG93bmVyLm1heFJvd0xldmVsID8/IDApXG5cbiAgICAgICAgICAgICAgICBsZXQgcm93Q29vcmRpbmF0ZSA9IGlzVmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgPyBzdGFydFZhbHVlICsgb3duZXIubWF4TGV2ZWwgKyAyXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5yb3dJbmRleFxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q29sLmhlYWRlclR5cGUgPT09IEV4cG9ydEhlYWRlclR5cGUuUGl2b3RSb3dIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93Q29vcmRpbmF0ZSA9IHN0YXJ0VmFsdWUgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjb2x1bW5WYWx1ZSA9IGRpY3Rpb25hcnkuc2F2ZVZhbHVlKGN1cnJlbnRDb2wuaGVhZGVyLCB0cnVlLCBmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICBjb2x1bW5Db29yZGluYXRlID0gKGN1cnJlbnRDb2wuZmllbGQgPT09IEdSSURfTEVWRUxfQ09MXG4gICAgICAgICAgICAgICAgICAgID8gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKHdvcmtzaGVldERhdGEuY29sdW1uQ291bnQgKyAxKVxuICAgICAgICAgICAgICAgICAgICA6IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2x1bW4pKSArIHJvd0Nvb3JkaW5hdGU7XG5cbiAgICAgICAgICAgICAgICByb3dTdHlsZSA9IGlzVmVydGljYWwgJiYgY3VycmVudENvbC5yb3dTcGFuID4gMSA/ICcgcz1cIjRcIicgOiByb3dTdHlsZTtcbiAgICAgICAgICAgICAgICBzdHIgPSBgPGMgcj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX1cIiR7cm93U3R5bGV9IHQ9XCJzXCI+PHY+JHtjb2x1bW5WYWx1ZX08L3Y+PC9jPmA7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5waXZvdEdyaWRSb3dIZWFkZXJzTWFwLmhhcyhyb3dDb29yZGluYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXZvdEdyaWRSb3dIZWFkZXJzTWFwLnNldChyb3dDb29yZGluYXRlLCB0aGlzLnBpdm90R3JpZFJvd0hlYWRlcnNNYXAuZ2V0KHJvd0Nvb3JkaW5hdGUpICsgc3RyKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5waXZvdEdyaWRSb3dIZWFkZXJzTWFwLnNldChyb3dDb29yZGluYXRlLCBzdHIpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoZWV0RGF0YSArPSBzdHI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGkgIT09IG1heExldmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VDZWxsc0NvdW50ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXJnZUNlbGxTdHIgKz0gYCA8bWVyZ2VDZWxsIHJlZj1cIiR7Y29sdW1uQ29vcmRpbmF0ZX06YDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbC5oZWFkZXJUeXBlID09PSBFeHBvcnRIZWFkZXJUeXBlLkNvbHVtbkhlYWRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sID0gaXNWZXJ0aWNhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbWF4TGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHN0YXJ0VmFsdWUgKyAob3duZXIubWF4Um93TGV2ZWwgPz8gMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGlzVmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJvd0Nvb3JkaW5hdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG93bmVyLm1heExldmVsICsgMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uQ29vcmRpbmF0ZSA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2wpICsgcm93O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgayA9IDE7IGsgPCBzcGFuTGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSBpc1ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29sdW1uICsgaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvdyA9IGlzVmVydGljYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByb3dDb29yZGluYXRlICsga1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMucm93SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5Db29yZGluYXRlID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbCkgKyByb3c7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RyID0gYDxjIHI9XCIke2NvbHVtbkNvb3JkaW5hdGV9XCIke3Jvd1N0eWxlfSAvPmA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZlcnRpY2FsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5waXZvdEdyaWRSb3dIZWFkZXJzTWFwLnNldChyb3csIHN0cilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnNoZWV0RGF0YSArPSBzdHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVyZ2VDZWxsU3RyICs9IGAke2NvbHVtbkNvb3JkaW5hdGV9XCIgLz5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJyZW50Q29sLmhlYWRlclR5cGUgIT09IEV4cG9ydEhlYWRlclR5cGUuUGl2b3RSb3dIZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBzdGFydFZhbHVlICs9IHNwYW5MZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgU3R5bGVGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCkge1xuICAgICAgICBmb2xkZXJbJ3N0eWxlcy54bWwnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldFN0eWxlcygpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgV29ya2Jvb2tGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBmb2xkZXJbJ3dvcmtib29rLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0V29ya2Jvb2sod29ya3NoZWV0RGF0YS5vcHRpb25zLndvcmtzaGVldE5hbWUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgQ29udGVudFR5cGVzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgaGFzU2hhcmVkU3RyaW5ncyA9ICF3b3Jrc2hlZXREYXRhLmlzRW1wdHkgfHwgd29ya3NoZWV0RGF0YS5vcHRpb25zLmFsd2F5c0V4cG9ydEhlYWRlcnM7XG4gICAgICAgIGZvbGRlclsnW0NvbnRlbnRfVHlwZXNdLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0Q29udGVudFR5cGVzWE1MKGhhc1NoYXJlZFN0cmluZ3MsIHdvcmtzaGVldERhdGEub3B0aW9ucy5leHBvcnRBc1RhYmxlKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGNsYXNzIFNoYXJlZFN0cmluZ3NGaWxlIGltcGxlbWVudHMgSUV4Y2VsRmlsZSB7XG4gICAgcHVibGljIHdyaXRlRWxlbWVudChmb2xkZXI6IE9iamVjdCwgd29ya3NoZWV0RGF0YTogV29ya3NoZWV0RGF0YSkge1xuICAgICAgICBjb25zdCBkaWN0ID0gd29ya3NoZWV0RGF0YS5kYXRhRGljdGlvbmFyeTtcbiAgICAgICAgY29uc3Qgc29ydGVkVmFsdWVzID0gZGljdC5nZXRLZXlzKCk7XG4gICAgICAgIGNvbnN0IHNoYXJlZFN0cmluZ3MgPSBuZXcgQXJyYXk8c3RyaW5nPihzb3J0ZWRWYWx1ZXMubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHNvcnRlZFZhbHVlcykge1xuICAgICAgICAgICAgc2hhcmVkU3RyaW5nc1tkaWN0LmdldFNhbml0aXplZFZhbHVlKHZhbHVlKV0gPSAnPHNpPjx0PicgKyB2YWx1ZSArICc8L3Q+PC9zaT4nO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9sZGVyWydzaGFyZWRTdHJpbmdzLnhtbCddID0gc3RyVG9VOChFeGNlbFN0cmluZ3MuZ2V0U2hhcmVkU3RyaW5nWE1MKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGljdC5zdHJpbmdzQ291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3J0ZWRWYWx1ZXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2hhcmVkU3RyaW5ncy5qb2luKCcnKSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgVGFibGVzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QsIHdvcmtzaGVldERhdGE6IFdvcmtzaGVldERhdGEpIHtcbiAgICAgICAgY29uc3QgY29sdW1uQ291bnQgPSB3b3Jrc2hlZXREYXRhLmNvbHVtbkNvdW50O1xuICAgICAgICBjb25zdCBsYXN0Q29sdW1uID0gRXhjZWxTdHJpbmdzLmdldEV4Y2VsQ29sdW1uKGNvbHVtbkNvdW50IC0gMSkgKyB3b3Jrc2hlZXREYXRhLnJvd0NvdW50O1xuICAgICAgICBjb25zdCBhdXRvRmlsdGVyRGltZW5zaW9uID0gJ0ExOicgKyBsYXN0Q29sdW1uO1xuICAgICAgICBjb25zdCB0YWJsZURpbWVuc2lvbiA9IHdvcmtzaGVldERhdGEuaXNFbXB0eVxuICAgICAgICAgICAgPyAnQTE6JyArIEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbihjb2x1bW5Db3VudCAtIDEpICsgKHdvcmtzaGVldERhdGEucm93Q291bnQgKyAxKVxuICAgICAgICAgICAgOiBhdXRvRmlsdGVyRGltZW5zaW9uO1xuICAgICAgICBjb25zdCBoYXNVc2VyU2V0SW5kZXggPSB3b3Jrc2hlZXREYXRhLm93bmVyLmNvbHVtbnMuc29tZShjID0+IGMuZXhwb3J0SW5kZXggIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGhhc1VzZXJTZXRJbmRleFxuICAgICAgICAgICAgPyB3b3Jrc2hlZXREYXRhLnJvb3RLZXlzXG4gICAgICAgICAgICA6IHdvcmtzaGVldERhdGEub3duZXIuY29sdW1uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoYyA9PiAhYy5za2lwKVxuICAgICAgICAgICAgICAgIC5zb3J0KChhLCBiKSA9PiBhLnN0YXJ0SW5kZXggLSBiLnN0YXJ0SW5kZXgpXG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucGlubmVkSW5kZXggLSBiLnBpbm5lZEluZGV4KVxuICAgICAgICAgICAgICAgIC5tYXAoYyA9PiBjLmhlYWRlcik7XG5cbiAgICAgICAgbGV0IHNvcnRTdHJpbmcgPSAnJztcblxuICAgICAgICBsZXQgdGFibGVDb2x1bW5zID0gJzx0YWJsZUNvbHVtbnMgY291bnQ9XCInICsgY29sdW1uQ291bnQgKyAnXCI+JztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9ICB2YWx1ZXNbaV07XG4gICAgICAgICAgICB0YWJsZUNvbHVtbnMgKz0gJzx0YWJsZUNvbHVtbiBpZD1cIicgKyAoaSArIDEpICsgJ1wiIG5hbWU9XCInICsgdmFsdWUgKyAnXCIvPic7XG4gICAgICAgIH1cblxuICAgICAgICB0YWJsZUNvbHVtbnMgKz0gJzwvdGFibGVDb2x1bW5zPic7XG5cbiAgICAgICAgaWYgKHdvcmtzaGVldERhdGEuc29ydCkge1xuICAgICAgICAgICAgY29uc3Qgc29ydGluZ0V4cHJlc3Npb24gPSB3b3Jrc2hlZXREYXRhLnNvcnQ7XG4gICAgICAgICAgICBjb25zdCBzYyA9IEV4Y2VsU3RyaW5ncy5nZXRFeGNlbENvbHVtbih2YWx1ZXMuaW5kZXhPZihzb3J0aW5nRXhwcmVzc2lvbi5maWVsZE5hbWUpKTtcbiAgICAgICAgICAgIGNvbnN0IGRpciA9IHNvcnRpbmdFeHByZXNzaW9uLmRpciAtIDE7XG4gICAgICAgICAgICBzb3J0U3RyaW5nID0gYDxzb3J0U3RhdGUgcmVmPVwiQTI6JHtsYXN0Q29sdW1ufVwiPjxzb3J0Q29uZGl0aW9uIGRlc2NlbmRpbmc9XCIke2Rpcn1cIiByZWY9XCIke3NjfTE6JHtzY30xNVwiLz48L3NvcnRTdGF0ZT5gO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9sZGVyWyd0YWJsZTEueG1sJ10gPSBzdHJUb1U4KEV4Y2VsU3RyaW5ncy5nZXRUYWJsZXNYTUwoYXV0b0ZpbHRlckRpbWVuc2lvbiwgdGFibGVEaW1lbnNpb24sIHRhYmxlQ29sdW1ucywgc29ydFN0cmluZykpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBjbGFzcyBXb3Jrc2hlZXRSZWxzRmlsZSBpbXBsZW1lbnRzIElFeGNlbEZpbGUge1xuICAgIHB1YmxpYyB3cml0ZUVsZW1lbnQoZm9sZGVyOiBPYmplY3QpIHtcbiAgICAgICAgZm9sZGVyWydzaGVldDEueG1sLnJlbHMnXSA9IHN0clRvVTgoRXhjZWxTdHJpbmdzLmdldFdvcmtzaGVldFJlbHMoKSk7XG4gICAgfVxufVxuIl19
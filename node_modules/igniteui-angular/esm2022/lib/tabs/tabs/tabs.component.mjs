import { Component, HostBinding, Inject, Input, ViewChild } from '@angular/core';
import { getResizeObserver, mkenum } from '../../core/utils';
import { IgxAngularAnimationService } from '../../services/animation/angular-animation-service';
import { IgxTabsBase } from '../tabs.base';
import { IgxTabsDirective } from '../tabs.directive';
import { NgClass, NgFor, NgTemplateOutlet, NgIf } from '@angular/common';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxRippleDirective } from '../../directives/ripple/ripple.directive';
import * as i0 from "@angular/core";
import * as i1 from "../../services/direction/directionality";
export const IgxTabsAlignment = /*@__PURE__*/ mkenum({
    start: 'start',
    end: 'end',
    center: 'center',
    justify: 'justify'
});
/** @hidden */
let NEXT_TAB_ID = 0;
/**
 * Tabs component is used to organize or switch between similar data sets.
 *
 * @igxModule IgxTabsModule
 *
 * @igxTheme igx-tabs-theme
 *
 * @igxKeywords tabs
 *
 * @igxGroup Layouts
 *
 * @remarks
 * The Ignite UI for Angular Tabs component places tabs at the top and allows for scrolling when there are multiple tab items on the screen.
 *
 * @example
 * ```html
 * <igx-tabs>
 *     <igx-tab-item>
 *         <igx-tab-header>
 *             <igx-icon igxTabHeaderIcon>folder</igx-icon>
 *             <span igxTabHeaderLabel>Tab 1</span>
 *         </igx-tab-header>
 *         <igx-tab-content>
 *             Content 1
 *         </igx-tab-content>
 *     </igx-tab-item>
 *     ...
 * </igx-tabs>
 * ```
 */
export class IgxTabsComponent extends IgxTabsDirective {
    /**
     * Gets/Sets the tab alignment. Defaults to `start`.
     */
    get tabAlignment() {
        return this._tabAlignment;
    }
    set tabAlignment(value) {
        this._tabAlignment = value;
        requestAnimationFrame(() => {
            this.updateScrollButtons();
            this.realignSelectedIndicator();
        });
    }
    constructor(animationService, cdr, ngZone, dir) {
        super(animationService, cdr, dir);
        this.ngZone = ngZone;
        /** @hidden */
        this.defaultClass = true;
        /**  @hidden */
        this.offset = 0;
        /** @hidden */
        this.componentName = 'igx-tabs';
        this._tabAlignment = 'start';
    }
    /** @hidden @internal */
    ngAfterViewInit() {
        super.ngAfterViewInit();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver = new (getResizeObserver())(() => {
                this.updateScrollButtons();
                this.realignSelectedIndicator();
            });
            this._resizeObserver.observe(this.headerContainer.nativeElement);
            this._resizeObserver.observe(this.viewPort.nativeElement);
        });
    }
    /** @hidden @internal */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.ngZone.runOutsideAngular(() => {
            this._resizeObserver?.disconnect();
        });
    }
    /** @hidden */
    scrollPrev() {
        this.scroll(false);
    }
    /** @hidden */
    scrollNext() {
        this.scroll(true);
    }
    /** @hidden */
    realignSelectedIndicator() {
        if (this.selectedIndex >= 0 && this.selectedIndex < this.items.length) {
            const header = this.items.get(this.selectedIndex).headerComponent.nativeElement;
            this.alignSelectedIndicator(header, 0);
        }
    }
    /** @hidden */
    resolveHeaderScrollClasses() {
        return {
            'igx-tabs__header-scroll--start': this.tabAlignment === 'start',
            'igx-tabs__header-scroll--end': this.tabAlignment === 'end',
            'igx-tabs__header-scroll--center': this.tabAlignment === 'center',
            'igx-tabs__header-scroll--justify': this.tabAlignment === 'justify',
        };
    }
    /** @hidden */
    scrollTabHeaderIntoView() {
        if (this.selectedIndex >= 0) {
            const tabItems = this.items.toArray();
            const tabHeaderNativeElement = tabItems[this.selectedIndex].headerComponent.nativeElement;
            // Scroll left if there is need
            if (this.getElementOffset(tabHeaderNativeElement) < this.offset) {
                this.scrollElement(tabHeaderNativeElement, false);
            }
            // Scroll right if there is need
            const viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
            const delta = (this.getElementOffset(tabHeaderNativeElement) + tabHeaderNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
            // Fix for IE 11, a difference is accumulated from the widths calculations
            if (delta > 1) {
                this.scrollElement(tabHeaderNativeElement, true);
            }
            this.alignSelectedIndicator(tabHeaderNativeElement);
        }
        else {
            this.hideSelectedIndicator();
        }
    }
    /** @hidden */
    getNextTabId() {
        return NEXT_TAB_ID++;
    }
    /** @hidden */
    onItemChanges() {
        super.onItemChanges();
        Promise.resolve().then(() => {
            this.updateScrollButtons();
        });
    }
    alignSelectedIndicator(element, duration = 0.3) {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? `${duration}s` : 'initial';
            this.selectedIndicator.nativeElement.style.width = `${element.offsetWidth}px`;
            this.selectedIndicator.nativeElement.style.transform = `translate(${element.offsetLeft}px)`;
        }
    }
    hideSelectedIndicator() {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    }
    scroll(scrollNext) {
        const tabsArray = this.items.toArray();
        for (let index = 0; index < tabsArray.length; index++) {
            const tab = tabsArray[index];
            const element = tab.headerComponent.nativeElement;
            if (scrollNext) {
                if (element.offsetWidth + this.getElementOffset(element) > this.viewPort.nativeElement.offsetWidth + this.offset) {
                    this.scrollElement(element, scrollNext);
                    break;
                }
            }
            else {
                if (this.getElementOffset(element) >= this.offset) {
                    this.scrollElement(tabsArray[index - 1].headerComponent.nativeElement, scrollNext);
                    break;
                }
            }
        }
    }
    scrollElement(element, scrollNext) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollNext) ? element.offsetWidth + this.getElementOffset(element) - viewPortWidth : this.getElementOffset(element);
        this.viewPort.nativeElement.scrollLeft = this.getOffset(this.offset);
        this.updateScrollButtons();
    }
    updateScrollButtons() {
        const itemsContainerWidth = this.getTabItemsContainerWidth();
        const scrollPrevButtonStyle = this.resolveLeftScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollPrevButton.nativeElement, scrollPrevButtonStyle);
        const scrollNextButtonStyle = this.resolveRightScrollButtonStyle(itemsContainerWidth);
        this.setScrollButtonStyle(this.scrollNextButton.nativeElement, scrollNextButtonStyle);
    }
    setScrollButtonStyle(button, buttonStyle) {
        if (buttonStyle === "enabled" /* TabScrollButtonStyle.Enabled */) {
            button.disabled = false;
            button.style.display = '';
        }
        else if (buttonStyle === "disabled" /* TabScrollButtonStyle.Disabled */) {
            button.disabled = true;
            button.style.display = '';
        }
        else if (buttonStyle === "not_displayed" /* TabScrollButtonStyle.NotDisplayed */) {
            button.style.display = 'none';
        }
    }
    resolveLeftScrollButtonStyle(itemsContainerWidth) {
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        if (offset === 0) {
            // Fix for IE 11, a difference is accumulated from the widths calculations.
            if (itemsContainerWidth - headerContainerWidth <= 1) {
                return "not_displayed" /* TabScrollButtonStyle.NotDisplayed */;
            }
            return "disabled" /* TabScrollButtonStyle.Disabled */;
        }
        else {
            return "enabled" /* TabScrollButtonStyle.Enabled */;
        }
    }
    resolveRightScrollButtonStyle(itemsContainerWidth) {
        const viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        const headerContainerWidth = this.headerContainer.nativeElement.offsetWidth;
        const offset = this.offset;
        const total = offset + viewPortWidth;
        // Fix for IE 11, a difference is accumulated from the widths calculations.
        if (itemsContainerWidth - headerContainerWidth <= 1 && offset === 0) {
            return "not_displayed" /* TabScrollButtonStyle.NotDisplayed */;
        }
        if (itemsContainerWidth > total) {
            return "enabled" /* TabScrollButtonStyle.Enabled */;
        }
        else {
            return "disabled" /* TabScrollButtonStyle.Disabled */;
        }
    }
    getTabItemsContainerWidth() {
        // We use this hacky way to get the width of the itemsContainer,
        // because there is inconsistency in IE we cannot use offsetWidth or scrollOffset.
        const itemsContainerChildrenCount = this.itemsContainer.nativeElement.children.length;
        let itemsContainerWidth = 0;
        if (itemsContainerChildrenCount > 1) {
            const lastTab = this.itemsContainer.nativeElement.children[itemsContainerChildrenCount - 1];
            itemsContainerWidth = this.getElementOffset(lastTab) + lastTab.offsetWidth;
        }
        return itemsContainerWidth;
    }
    getOffset(offset) {
        return this.dir.rtl ? -offset : offset;
    }
    getElementOffset(element) {
        return this.dir.rtl ? this.itemsWrapper.nativeElement.offsetWidth - element.offsetLeft - element.offsetWidth : element.offsetLeft;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxTabsComponent, deps: [{ token: IgxAngularAnimationService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.IgxDirectionality }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.1", type: IgxTabsComponent, isStandalone: true, selector: "igx-tabs", inputs: { tabAlignment: "tabAlignment" }, host: { properties: { "class.igx-tabs": "this.defaultClass" } }, providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], viewQueries: [{ propertyName: "headerContainer", first: true, predicate: ["headerContainer"], descendants: true, static: true }, { propertyName: "viewPort", first: true, predicate: ["viewPort"], descendants: true, static: true }, { propertyName: "itemsWrapper", first: true, predicate: ["itemsWrapper"], descendants: true, static: true }, { propertyName: "itemsContainer", first: true, predicate: ["itemsContainer"], descendants: true, static: true }, { propertyName: "selectedIndicator", first: true, predicate: ["selectedIndicator"], descendants: true }, { propertyName: "scrollPrevButton", first: true, predicate: ["scrollPrevButton"], descendants: true }, { propertyName: "scrollNextButton", first: true, predicate: ["scrollNextButton"], descendants: true }], usesInheritance: true, ngImport: i0, template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>\n", dependencies: [{ kind: "directive", type: IgxRippleDirective, selector: "[igxRipple]", inputs: ["igxRippleTarget", "igxRipple", "igxRippleDuration", "igxRippleCentered", "igxRippleDisabled"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxTabsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tabs', providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }], standalone: true, imports: [IgxRippleDirective, IgxIconComponent, NgClass, NgFor, NgTemplateOutlet, NgIf], template: "<div #headerContainer class=\"igx-tabs__header\">\n    <button #scrollPrevButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollPrev()\">\n        <igx-icon>navigate_before</igx-icon>\n    </button>\n    <div #viewPort class=\"igx-tabs__header-content\">\n        <div #itemsWrapper class=\"igx-tabs__header-wrapper\" role=\"tablist\">\n            <div #itemsContainer class=\"igx-tabs__header-scroll\" [ngClass]=\"resolveHeaderScrollClasses()\">\n                <ng-container *ngFor=\"let tab of items; let i = index\">\n                    <ng-container *ngTemplateOutlet=\"tab.headerTemplate\"></ng-container>\n                </ng-container>\n            </div>\n            <div #selectedIndicator *ngIf=\"items.length > 0\" class=\"igx-tabs__header-active-indicator\">\n            </div>\n        </div>\n    </div>\n    <button #scrollNextButton type=\"button\" igxIconButton=\"flat\" igxRipple class=\"igx-tabs__header-button\" (click)=\"scrollNext()\">\n        <igx-icon>navigate_next</igx-icon>\n    </button>\n</div>\n<div class=\"igx-tabs__panels\">\n    <ng-container *ngFor=\"let tab of items; let i = index\">\n        <ng-container *ngTemplateOutlet=\"tab.panelTemplate\"></ng-container>\n    </ng-container>\n</div>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.IgxDirectionality }], propDecorators: { tabAlignment: [{
                type: Input
            }], headerContainer: [{
                type: ViewChild,
                args: ['headerContainer', { static: true }]
            }], viewPort: [{
                type: ViewChild,
                args: ['viewPort', { static: true }]
            }], itemsWrapper: [{
                type: ViewChild,
                args: ['itemsWrapper', { static: true }]
            }], itemsContainer: [{
                type: ViewChild,
                args: ['itemsContainer', { static: true }]
            }], selectedIndicator: [{
                type: ViewChild,
                args: ['selectedIndicator']
            }], scrollPrevButton: [{
                type: ViewChild,
                args: ['scrollPrevButton']
            }], scrollNextButton: [{
                type: ViewChild,
                args: ['scrollNextButton']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.igx-tabs']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvdGFicy90YWJzL3RhYnMuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RhYnMvdGFicy90YWJzLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBb0MsU0FBUyxFQUFjLFdBQVcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFxQixTQUFTLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbEosT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQzdELE9BQU8sRUFBRSwwQkFBMEIsRUFBRSxNQUFNLG9EQUFvRCxDQUFDO0FBR2hHLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDM0MsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDckQsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDekUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sMENBQTBDLENBQUM7OztBQUU5RSxNQUFNLENBQUMsTUFBTSxnQkFBZ0IsR0FBRyxhQUFhLENBQUEsTUFBTSxDQUFDO0lBQ2hELEtBQUssRUFBRSxPQUFPO0lBQ2QsR0FBRyxFQUFFLEtBQUs7SUFDVixNQUFNLEVBQUUsUUFBUTtJQUNoQixPQUFPLEVBQUUsU0FBUztDQUNyQixDQUFDLENBQUM7QUFXSCxjQUFjO0FBQ2QsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0FBRXBCOzs7Ozs7Ozs7Ozs7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bEYsTUFBTTsyQkFBQywwQkFBMEI7OEhBdEQzQixZQUFZO3NCQUR0QixLQUFLO2dCQWVDLGVBQWU7c0JBRHJCLFNBQVM7dUJBQUMsaUJBQWlCLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUt2QyxRQUFRO3NCQURkLFNBQVM7dUJBQUMsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFLaEMsWUFBWTtzQkFEbEIsU0FBUzt1QkFBQyxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFO2dCQUtwQyxjQUFjO3NCQURwQixTQUFTO3VCQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFLdEMsaUJBQWlCO3NCQUR2QixTQUFTO3VCQUFDLG1CQUFtQjtnQkFLdkIsZ0JBQWdCO3NCQUR0QixTQUFTO3VCQUFDLGtCQUFrQjtnQkFLdEIsZ0JBQWdCO3NCQUR0QixTQUFTO3VCQUFDLGtCQUFrQjtnQkFLdEIsWUFBWTtzQkFEbEIsV0FBVzt1QkFBQyxnQkFBZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBZnRlclZpZXdJbml0LCBDaGFuZ2VEZXRlY3RvclJlZiwgQ29tcG9uZW50LCBFbGVtZW50UmVmLCBIb3N0QmluZGluZywgSW5qZWN0LCBJbnB1dCwgTmdab25lLCBPbkRlc3Ryb3ksIFZpZXdDaGlsZCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZ2V0UmVzaXplT2JzZXJ2ZXIsIG1rZW51bSB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4QW5ndWxhckFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5ndWxhci1hbmltYXRpb24tc2VydmljZSc7XG5pbXBvcnQgeyBBbmltYXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYW5pbWF0aW9uL2FuaW1hdGlvbic7XG5pbXBvcnQgeyBJZ3hEaXJlY3Rpb25hbGl0eSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2RpcmVjdGlvbi9kaXJlY3Rpb25hbGl0eSc7XG5pbXBvcnQgeyBJZ3hUYWJzQmFzZSB9IGZyb20gJy4uL3RhYnMuYmFzZSc7XG5pbXBvcnQgeyBJZ3hUYWJzRGlyZWN0aXZlIH0gZnJvbSAnLi4vdGFicy5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgTmdDbGFzcywgTmdGb3IsIE5nVGVtcGxhdGVPdXRsZXQsIE5nSWYgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4UmlwcGxlRGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9yaXBwbGUvcmlwcGxlLmRpcmVjdGl2ZSc7XG5cbmV4cG9ydCBjb25zdCBJZ3hUYWJzQWxpZ25tZW50ID0gLypAX19QVVJFX18qL21rZW51bSh7XG4gICAgc3RhcnQ6ICdzdGFydCcsXG4gICAgZW5kOiAnZW5kJyxcbiAgICBjZW50ZXI6ICdjZW50ZXInLFxuICAgIGp1c3RpZnk6ICdqdXN0aWZ5J1xufSk7XG5cbi8qKiBAaGlkZGVuICovXG5jb25zdCBlbnVtIFRhYlNjcm9sbEJ1dHRvblN0eWxlIHtcbiAgICBFbmFibGVkID0gJ2VuYWJsZWQnLFxuICAgIERpc2FibGVkID0gJ2Rpc2FibGVkJyxcbiAgICBOb3REaXNwbGF5ZWQgPSAnbm90X2Rpc3BsYXllZCdcbn1cblxuZXhwb3J0IHR5cGUgSWd4VGFic0FsaWdubWVudCA9ICh0eXBlb2YgSWd4VGFic0FsaWdubWVudClba2V5b2YgdHlwZW9mIElneFRhYnNBbGlnbm1lbnRdO1xuXG4vKiogQGhpZGRlbiAqL1xubGV0IE5FWFRfVEFCX0lEID0gMDtcblxuLyoqXG4gKiBUYWJzIGNvbXBvbmVudCBpcyB1c2VkIHRvIG9yZ2FuaXplIG9yIHN3aXRjaCBiZXR3ZWVuIHNpbWlsYXIgZGF0YSBzZXRzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4VGFic01vZHVsZVxuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtdGFicy10aGVtZVxuICpcbiAqIEBpZ3hLZXl3b3JkcyB0YWJzXG4gKlxuICogQGlneEdyb3VwIExheW91dHNcbiAqXG4gKiBAcmVtYXJrc1xuICogVGhlIElnbml0ZSBVSSBmb3IgQW5ndWxhciBUYWJzIGNvbXBvbmVudCBwbGFjZXMgdGFicyBhdCB0aGUgdG9wIGFuZCBhbGxvd3MgZm9yIHNjcm9sbGluZyB3aGVuIHRoZXJlIGFyZSBtdWx0aXBsZSB0YWIgaXRlbXMgb24gdGhlIHNjcmVlbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC10YWJzPlxuICogICAgIDxpZ3gtdGFiLWl0ZW0+XG4gKiAgICAgICAgIDxpZ3gtdGFiLWhlYWRlcj5cbiAqICAgICAgICAgICAgIDxpZ3gtaWNvbiBpZ3hUYWJIZWFkZXJJY29uPmZvbGRlcjwvaWd4LWljb24+XG4gKiAgICAgICAgICAgICA8c3BhbiBpZ3hUYWJIZWFkZXJMYWJlbD5UYWIgMTwvc3Bhbj5cbiAqICAgICAgICAgPC9pZ3gtdGFiLWhlYWRlcj5cbiAqICAgICAgICAgPGlneC10YWItY29udGVudD5cbiAqICAgICAgICAgICAgIENvbnRlbnQgMVxuICogICAgICAgICA8L2lneC10YWItY29udGVudD5cbiAqICAgICA8L2lneC10YWItaXRlbT5cbiAqICAgICAuLi5cbiAqIDwvaWd4LXRhYnM+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdGFicycsXG4gICAgdGVtcGxhdGVVcmw6ICd0YWJzLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneFRhYnNCYXNlLCB1c2VFeGlzdGluZzogSWd4VGFic0NvbXBvbmVudCB9XSxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtJZ3hSaXBwbGVEaXJlY3RpdmUsIElneEljb25Db21wb25lbnQsIE5nQ2xhc3MsIE5nRm9yLCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0lmXVxufSlcblxuZXhwb3J0IGNsYXNzIElneFRhYnNDb21wb25lbnQgZXh0ZW5kcyBJZ3hUYWJzRGlyZWN0aXZlIGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgdGFiIGFsaWdubWVudC4gRGVmYXVsdHMgdG8gYHN0YXJ0YC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgdGFiQWxpZ25tZW50KCk6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5fdGFiQWxpZ25tZW50O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgdGFiQWxpZ25tZW50KHZhbHVlOiBzdHJpbmcgfCBJZ3hUYWJzQWxpZ25tZW50KSB7XG4gICAgICAgIHRoaXMuX3RhYkFsaWdubWVudCA9IHZhbHVlO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWxpZ25TZWxlY3RlZEluZGljYXRvcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlckNvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3ZpZXdQb3J0JywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgdmlld1BvcnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc1dyYXBwZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBpdGVtc1dyYXBwZXI6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGl0ZW1zQ29udGFpbmVyOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0ZWRJbmRpY2F0b3InKVxuICAgIHB1YmxpYyBzZWxlY3RlZEluZGljYXRvcjogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBWaWV3Q2hpbGQoJ3Njcm9sbFByZXZCdXR0b24nKVxuICAgIHB1YmxpYyBzY3JvbGxQcmV2QnV0dG9uOiBFbGVtZW50UmVmPEhUTUxCdXR0b25FbGVtZW50PjtcblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQFZpZXdDaGlsZCgnc2Nyb2xsTmV4dEJ1dHRvbicpXG4gICAgcHVibGljIHNjcm9sbE5leHRCdXR0b246IEVsZW1lbnRSZWY8SFRNTEJ1dHRvbkVsZW1lbnQ+O1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10YWJzJylcbiAgICBwdWJsaWMgZGVmYXVsdENsYXNzID0gdHJ1ZTtcblxuICAgIC8qKiAgQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBvZmZzZXQgPSAwO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgY29tcG9uZW50TmFtZSA9ICdpZ3gtdGFicyc7XG5cbiAgICBwcml2YXRlIF90YWJBbGlnbm1lbnQ6IHN0cmluZyB8IElneFRhYnNBbGlnbm1lbnQgPSAnc3RhcnQnO1xuICAgIHByaXZhdGUgX3Jlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KElneEFuZ3VsYXJBbmltYXRpb25TZXJ2aWNlKSBhbmltYXRpb25TZXJ2aWNlOiBBbmltYXRpb25TZXJ2aWNlLFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgICAgICBkaXI6IElneERpcmVjdGlvbmFsaXR5KSB7XG4gICAgICAgIHN1cGVyKGFuaW1hdGlvblNlcnZpY2UsIGNkciwgZGlyKTtcbiAgICB9XG5cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IChnZXRSZXNpemVPYnNlcnZlcigpKSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmhlYWRlckNvbnRhaW5lci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG92ZXJyaWRlIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuXG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIHNjcm9sbFByZXYoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyBzY3JvbGxOZXh0KCkge1xuICAgICAgICB0aGlzLnNjcm9sbCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHB1YmxpYyByZWFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gMCAmJiB0aGlzLnNlbGVjdGVkSW5kZXggPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyID0gdGhpcy5pdGVtcy5nZXQodGhpcy5zZWxlY3RlZEluZGV4KS5oZWFkZXJDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuYWxpZ25TZWxlY3RlZEluZGljYXRvcihoZWFkZXIsIDApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgcmVzb2x2ZUhlYWRlclNjcm9sbENsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLXN0YXJ0JzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdzdGFydCcsXG4gICAgICAgICAgICAnaWd4LXRhYnNfX2hlYWRlci1zY3JvbGwtLWVuZCc6IHRoaXMudGFiQWxpZ25tZW50ID09PSAnZW5kJyxcbiAgICAgICAgICAgICdpZ3gtdGFic19faGVhZGVyLXNjcm9sbC0tY2VudGVyJzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdjZW50ZXInLFxuICAgICAgICAgICAgJ2lneC10YWJzX19oZWFkZXItc2Nyb2xsLS1qdXN0aWZ5JzogdGhpcy50YWJBbGlnbm1lbnQgPT09ICdqdXN0aWZ5JyxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByb3RlY3RlZCBvdmVycmlkZSBzY3JvbGxUYWJIZWFkZXJJbnRvVmlldygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCB0YWJJdGVtcyA9IHRoaXMuaXRlbXMudG9BcnJheSgpO1xuICAgICAgICAgICAgY29uc3QgdGFiSGVhZGVyTmF0aXZlRWxlbWVudCA9IHRhYkl0ZW1zW3RoaXMuc2VsZWN0ZWRJbmRleF0uaGVhZGVyQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICAgIC8vIFNjcm9sbCBsZWZ0IGlmIHRoZXJlIGlzIG5lZWRcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEVsZW1lbnRPZmZzZXQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCkgPCB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJIZWFkZXJOYXRpdmVFbGVtZW50LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNjcm9sbCByaWdodCBpZiB0aGVyZSBpcyBuZWVkXG4gICAgICAgICAgICBjb25zdCB2aWV3UG9ydE9mZnNldFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSAodGhpcy5nZXRFbGVtZW50T2Zmc2V0KHRhYkhlYWRlck5hdGl2ZUVsZW1lbnQpICsgdGFiSGVhZGVyTmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCkgLSAodmlld1BvcnRPZmZzZXRXaWR0aCArIHRoaXMub2Zmc2V0KTtcblxuICAgICAgICAgICAgLy8gRml4IGZvciBJRSAxMSwgYSBkaWZmZXJlbmNlIGlzIGFjY3VtdWxhdGVkIGZyb20gdGhlIHdpZHRocyBjYWxjdWxhdGlvbnNcbiAgICAgICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiSGVhZGVyTmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuYWxpZ25TZWxlY3RlZEluZGljYXRvcih0YWJIZWFkZXJOYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZVNlbGVjdGVkSW5kaWNhdG9yKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIHByb3RlY3RlZCBnZXROZXh0VGFiSWQoKSB7XG4gICAgICAgIHJldHVybiBORVhUX1RBQl9JRCsrO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIG9uSXRlbUNoYW5nZXMoKSB7XG4gICAgICAgIHN1cGVyLm9uSXRlbUNoYW5nZXMoKTtcblxuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsQnV0dG9ucygpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGFsaWduU2VsZWN0ZWRJbmRpY2F0b3IoZWxlbWVudDogSFRNTEVsZW1lbnQsIGR1cmF0aW9uID0gMC4zKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiA+IDAgPyBgJHtkdXJhdGlvbn1zYCA6ICdpbml0aWFsJztcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS53aWR0aCA9IGAke2VsZW1lbnQub2Zmc2V0V2lkdGh9cHhgO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHtlbGVtZW50Lm9mZnNldExlZnR9cHgpYDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgaGlkZVNlbGVjdGVkSW5kaWNhdG9yKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGljYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2Nyb2xsKHNjcm9sbE5leHQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFic0FycmF5ID0gdGhpcy5pdGVtcy50b0FycmF5KCk7XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRhYnNBcnJheS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IHRhYnNBcnJheVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGFiLmhlYWRlckNvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbE5leHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRXaWR0aCArIHRoaXMuZ2V0RWxlbWVudE9mZnNldChlbGVtZW50KSA+IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCArIHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudChlbGVtZW50LCBzY3JvbGxOZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpID49IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJzQXJyYXlbaW5kZXggLSAxXS5oZWFkZXJDb21wb25lbnQubmF0aXZlRWxlbWVudCwgc2Nyb2xsTmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgc2Nyb2xsRWxlbWVudChlbGVtZW50OiBhbnksIHNjcm9sbE5leHQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3Qgdmlld1BvcnRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgICB0aGlzLm9mZnNldCA9IChzY3JvbGxOZXh0KSA/IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLmdldEVsZW1lbnRPZmZzZXQoZWxlbWVudCkgLSB2aWV3UG9ydFdpZHRoIDogdGhpcy5nZXRFbGVtZW50T2Zmc2V0KGVsZW1lbnQpO1xuICAgICAgICB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsTGVmdCA9IHRoaXMuZ2V0T2Zmc2V0KHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVTY3JvbGxCdXR0b25zKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVTY3JvbGxCdXR0b25zKCkge1xuICAgICAgICBjb25zdCBpdGVtc0NvbnRhaW5lcldpZHRoID0gdGhpcy5nZXRUYWJJdGVtc0NvbnRhaW5lcldpZHRoKCk7XG5cbiAgICAgICAgY29uc3Qgc2Nyb2xsUHJldkJ1dHRvblN0eWxlID0gdGhpcy5yZXNvbHZlTGVmdFNjcm9sbEJ1dHRvblN0eWxlKGl0ZW1zQ29udGFpbmVyV2lkdGgpO1xuICAgICAgICB0aGlzLnNldFNjcm9sbEJ1dHRvblN0eWxlKHRoaXMuc2Nyb2xsUHJldkJ1dHRvbi5uYXRpdmVFbGVtZW50LCBzY3JvbGxQcmV2QnV0dG9uU3R5bGUpO1xuXG4gICAgICAgIGNvbnN0IHNjcm9sbE5leHRCdXR0b25TdHlsZSA9IHRoaXMucmVzb2x2ZVJpZ2h0U2Nyb2xsQnV0dG9uU3R5bGUoaXRlbXNDb250YWluZXJXaWR0aCk7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsQnV0dG9uU3R5bGUodGhpcy5zY3JvbGxOZXh0QnV0dG9uLm5hdGl2ZUVsZW1lbnQsIHNjcm9sbE5leHRCdXR0b25TdHlsZSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRTY3JvbGxCdXR0b25TdHlsZShidXR0b246IEhUTUxCdXR0b25FbGVtZW50LCBidXR0b25TdHlsZTogVGFiU2Nyb2xsQnV0dG9uU3R5bGUpIHtcbiAgICAgICAgaWYgKGJ1dHRvblN0eWxlID09PSBUYWJTY3JvbGxCdXR0b25TdHlsZS5FbmFibGVkKSB7XG4gICAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgIH0gZWxzZSBpZiAoYnV0dG9uU3R5bGUgPT09IFRhYlNjcm9sbEJ1dHRvblN0eWxlLkRpc2FibGVkKSB7XG4gICAgICAgICAgICBidXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChidXR0b25TdHlsZSA9PT0gVGFiU2Nyb2xsQnV0dG9uU3R5bGUuTm90RGlzcGxheWVkKSB7XG4gICAgICAgICAgICBidXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcml2YXRlIHJlc29sdmVMZWZ0U2Nyb2xsQnV0dG9uU3R5bGUoaXRlbXNDb250YWluZXJXaWR0aDogbnVtYmVyKTogVGFiU2Nyb2xsQnV0dG9uU3R5bGUge1xuICAgICAgICBjb25zdCBoZWFkZXJDb250YWluZXJXaWR0aCA9IHRoaXMuaGVhZGVyQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuXG4gICAgICAgIGlmIChvZmZzZXQgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zLlxuICAgICAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyV2lkdGggLSBoZWFkZXJDb250YWluZXJXaWR0aCA8PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5EaXNhYmxlZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5FbmFibGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZXNvbHZlUmlnaHRTY3JvbGxCdXR0b25TdHlsZShpdGVtc0NvbnRhaW5lcldpZHRoOiBudW1iZXIpOiBUYWJTY3JvbGxCdXR0b25TdHlsZSB7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNvbnN0IGhlYWRlckNvbnRhaW5lcldpZHRoID0gdGhpcy5oZWFkZXJDb250YWluZXIubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gb2Zmc2V0ICsgdmlld1BvcnRXaWR0aDtcblxuICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9ucy5cbiAgICAgICAgaWYgKGl0ZW1zQ29udGFpbmVyV2lkdGggLSBoZWFkZXJDb250YWluZXJXaWR0aCA8PSAxICYmIG9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLk5vdERpc3BsYXllZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lcldpZHRoID4gdG90YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBUYWJTY3JvbGxCdXR0b25TdHlsZS5FbmFibGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFRhYlNjcm9sbEJ1dHRvblN0eWxlLkRpc2FibGVkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUYWJJdGVtc0NvbnRhaW5lcldpZHRoKCkge1xuICAgICAgICAvLyBXZSB1c2UgdGhpcyBoYWNreSB3YXkgdG8gZ2V0IHRoZSB3aWR0aCBvZiB0aGUgaXRlbXNDb250YWluZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgaW5jb25zaXN0ZW5jeSBpbiBJRSB3ZSBjYW5ub3QgdXNlIG9mZnNldFdpZHRoIG9yIHNjcm9sbE9mZnNldC5cbiAgICAgICAgY29uc3QgaXRlbXNDb250YWluZXJDaGlsZHJlbkNvdW50ID0gdGhpcy5pdGVtc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgbGV0IGl0ZW1zQ29udGFpbmVyV2lkdGggPSAwO1xuXG4gICAgICAgIGlmIChpdGVtc0NvbnRhaW5lckNoaWxkcmVuQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0VGFiID0gdGhpcy5pdGVtc0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNoaWxkcmVuW2l0ZW1zQ29udGFpbmVyQ2hpbGRyZW5Db3VudCAtIDFdIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgaXRlbXNDb250YWluZXJXaWR0aCA9IHRoaXMuZ2V0RWxlbWVudE9mZnNldChsYXN0VGFiKSArIGxhc3RUYWIub2Zmc2V0V2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXRlbXNDb250YWluZXJXaWR0aDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE9mZnNldChvZmZzZXQ6IG51bWJlcik6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpci5ydGwgPyAtb2Zmc2V0IDogb2Zmc2V0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0RWxlbWVudE9mZnNldChlbGVtZW50OiBIVE1MRWxlbWVudCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpci5ydGwgPyB0aGlzLml0ZW1zV3JhcHBlci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC0gZWxlbWVudC5vZmZzZXRMZWZ0IC0gZWxlbWVudC5vZmZzZXRXaWR0aCA6IGVsZW1lbnQub2Zmc2V0TGVmdDtcbiAgICB9XG59XG5cbiIsIjxkaXYgI2hlYWRlckNvbnRhaW5lciBjbGFzcz1cImlneC10YWJzX19oZWFkZXJcIj5cbiAgICA8YnV0dG9uICNzY3JvbGxQcmV2QnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZ3hJY29uQnV0dG9uPVwiZmxhdFwiIGlneFJpcHBsZSBjbGFzcz1cImlneC10YWJzX19oZWFkZXItYnV0dG9uXCIgKGNsaWNrKT1cInNjcm9sbFByZXYoKVwiPlxuICAgICAgICA8aWd4LWljb24+bmF2aWdhdGVfYmVmb3JlPC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbiAgICA8ZGl2ICN2aWV3UG9ydCBjbGFzcz1cImlneC10YWJzX19oZWFkZXItY29udGVudFwiPlxuICAgICAgICA8ZGl2ICNpdGVtc1dyYXBwZXIgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLXdyYXBwZXJcIiByb2xlPVwidGFibGlzdFwiPlxuICAgICAgICAgICAgPGRpdiAjaXRlbXNDb250YWluZXIgY2xhc3M9XCJpZ3gtdGFic19faGVhZGVyLXNjcm9sbFwiIFtuZ0NsYXNzXT1cInJlc29sdmVIZWFkZXJTY3JvbGxDbGFzc2VzKClcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCB0YWIgb2YgaXRlbXM7IGxldCBpID0gaW5kZXhcIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRhYi5oZWFkZXJUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8ZGl2ICNzZWxlY3RlZEluZGljYXRvciAqbmdJZj1cIml0ZW1zLmxlbmd0aCA+IDBcIiBjbGFzcz1cImlneC10YWJzX19oZWFkZXItYWN0aXZlLWluZGljYXRvclwiPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICAgIDxidXR0b24gI3Njcm9sbE5leHRCdXR0b24gdHlwZT1cImJ1dHRvblwiIGlneEljb25CdXR0b249XCJmbGF0XCIgaWd4UmlwcGxlIGNsYXNzPVwiaWd4LXRhYnNfX2hlYWRlci1idXR0b25cIiAoY2xpY2spPVwic2Nyb2xsTmV4dCgpXCI+XG4gICAgICAgIDxpZ3gtaWNvbj5uYXZpZ2F0ZV9uZXh0PC9pZ3gtaWNvbj5cbiAgICA8L2J1dHRvbj5cbjwvZGl2PlxuPGRpdiBjbGFzcz1cImlneC10YWJzX19wYW5lbHNcIj5cbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCB0YWIgb2YgaXRlbXM7IGxldCBpID0gaW5kZXhcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInRhYi5wYW5lbFRlbXBsYXRlXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9uZy1jb250YWluZXI+XG48L2Rpdj5cbiJdfQ==
import { Component, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output, SkipSelf, TemplateRef, ViewChild, booleanAttribute } from '@angular/core';
import { takeUntil } from 'rxjs/operators';
import { TreeResourceStringsEN } from '../../core/i18n/tree-resources';
import { ToggleAnimationPlayer } from '../../expansion-panel/toggle-animation-component';
import { IgxAngularAnimationService } from '../../services/animation/angular-animation-service';
import { IgxTreeSelectionType, IGX_TREE_COMPONENT, IGX_TREE_NODE_COMPONENT } from '../common';
import { IgxCircularProgressBarComponent } from '../../progressbar/progressbar.component';
import { IgxCheckboxComponent } from '../../checkbox/checkbox.component';
import { IgxIconComponent } from '../../icon/icon.component';
import { NgTemplateOutlet, NgIf, NgClass, NgFor } from '@angular/common';
import { getCurrentResourceStrings } from '../../core/i18n/resources';
import * as i0 from "@angular/core";
import * as i1 from "../tree-navigation.service";
import * as i2 from "../tree-selection.service";
import * as i3 from "../tree.service";
// TODO: Implement aria functionality
/**
 * @hidden @internal
 * Used for links (`a` tags) in the body of an `igx-tree-node`. Handles aria and event dispatch.
 */
export class IgxTreeNodeLinkDirective {
    /**
     * The node's parent. Should be used only when the link is defined
     * in `<ng-template>` tag outside of its parent, as Angular DI will not properly provide a reference
     *
     * ```html
     * <igx-tree>
     *     <igx-tree-node #myNode *ngFor="let node of data" [data]="node">
     *         <ng-template *ngTemplateOutlet="nodeTemplate; context: { $implicit: data, parentNode: myNode }">
     *         </ng-template>
     *     </igx-tree-node>
     *     ...
     *     <!-- node template is defined under tree to access related services -->
     *     <ng-template #nodeTemplate let-data let-node="parentNode">
     *         <a [igxTreeNodeLink]="node">{{ data.label }}</a>
     *     </ng-template>
     * </igx-tree>
     * ```
     */
    set parentNode(val) {
        if (val) {
            this._parentNode = val;
            this._parentNode.addLinkChild(this);
        }
    }
    get parentNode() {
        return this._parentNode;
    }
    /** A pointer to the parent node */
    get target() {
        return this.node || this.parentNode;
    }
    constructor(node, navService, elementRef) {
        this.node = node;
        this.navService = navService;
        this.elementRef = elementRef;
        this.role = 'treeitem';
        this._parentNode = null;
    }
    /** @hidden @internal */
    get tabIndex() {
        return this.navService.focusedNode === this.target ? (this.target?.disabled ? -1 : 0) : -1;
    }
    /**
     * @hidden @internal
     * Clear the node's focused state
     */
    handleBlur() {
        this.target.isFocused = false;
    }
    /**
     * @hidden @internal
     * Set the node as focused
     */
    handleFocus() {
        if (this.target && !this.target.disabled) {
            if (this.navService.focusedNode !== this.target) {
                this.navService.focusedNode = this.target;
            }
            this.target.isFocused = true;
        }
    }
    ngOnDestroy() {
        this.target.removeLinkChild(this);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxTreeNodeLinkDirective, deps: [{ token: IGX_TREE_NODE_COMPONENT, optional: true }, { token: i1.IgxTreeNavigationService }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: IgxTreeNodeLinkDirective, isStandalone: true, selector: "[igxTreeNodeLink]", inputs: { parentNode: ["igxTreeNodeLink", "parentNode"] }, host: { listeners: { "blur": "handleBlur()", "focus": "handleFocus()" }, properties: { "attr.role": "this.role", "attr.tabindex": "this.tabIndex" } }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxTreeNodeLinkDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: `[igxTreeNodeLink]`,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [IGX_TREE_NODE_COMPONENT]
                }] }, { type: i1.IgxTreeNavigationService }, { type: i0.ElementRef }], propDecorators: { role: [{
                type: HostBinding,
                args: ['attr.role']
            }], parentNode: [{
                type: Input,
                args: ['igxTreeNodeLink']
            }], tabIndex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], handleBlur: [{
                type: HostListener,
                args: ['blur']
            }], handleFocus: [{
                type: HostListener,
                args: ['focus']
            }] } });
/**
 *
 * The tree node component represents a child node of the tree component or another tree node.
 * Usage:
 *
 * ```html
 *  <igx-tree>
 *  ...
 *    <igx-tree-node [data]="data" [selected]="service.isNodeSelected(data.Key)" [expanded]="service.isNodeExpanded(data.Key)">
 *      {{ data.FirstName }} {{ data.LastName }}
 *    </igx-tree-node>
 *  ...
 *  </igx-tree>
 * ```
 */
export class IgxTreeNodeComponent extends ToggleAnimationPlayer {
    // TO DO: return different tab index depending on anchor child
    /** @hidden @internal */
    set tabIndex(val) {
        this._tabIndex = val;
    }
    /** @hidden @internal */
    get tabIndex() {
        if (this.disabled) {
            return -1;
        }
        if (this._tabIndex === null) {
            if (this.navService.focusedNode === null) {
                return this.hasLinkChildren ? -1 : 0;
            }
            return -1;
        }
        return this.hasLinkChildren ? -1 : this._tabIndex;
    }
    /** @hidden @internal */
    get animationSettings() {
        return this.tree.animationSettings;
    }
    /**
     * Gets/Sets the resource strings.
     *
     * @remarks
     * Uses EN resources by default.
     */
    set resourceStrings(value) {
        this._resourceStrings = Object.assign({}, this._resourceStrings, value);
    }
    /**
     * An accessor that returns the resource strings.
     */
    get resourceStrings() {
        return this._resourceStrings;
    }
    /**
     * Gets/Sets the active state of the node
     *
     * @param value: boolean
     */
    set active(value) {
        if (value) {
            this.navService.activeNode = this;
            this.tree.activeNodeBindingChange.emit(this);
        }
    }
    get active() {
        return this.navService.activeNode === this;
    }
    /** @hidden @internal */
    get focused() {
        return this.isFocused &&
            this.navService.focusedNode === this;
    }
    /**
     * Retrieves the full path to the node incuding itself
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const path: IgxTreeNode<any>[] = node.path;
     * ```
     */
    get path() {
        return this.parentNode?.path ? [...this.parentNode.path, this] : [this];
    }
    // TODO: bind to disabled state when node is dragged
    /**
     * Gets/Sets the disabled state of the node
     *
     * @param value: boolean
     */
    get disabled() {
        return this._disabled;
    }
    set disabled(value) {
        if (value !== this._disabled) {
            this._disabled = value;
            this.tree.disabledChange.emit(this);
        }
    }
    /** @hidden @internal */
    get role() {
        return this.hasLinkChildren ? 'none' : 'treeitem';
    }
    /**
     * Return the child nodes of the node (if any)
     *
     * @remark
     * Returns `null` if node does not have children
     *
     * @example
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const children: IgxTreeNode<any>[] = node.children;
     * ```
     */
    get children() {
        return this._children?.length ? this._children.toArray() : null;
    }
    get hasLinkChildren() {
        return this.linkChildren?.length > 0 || this.registeredChildren?.length > 0;
    }
    constructor(tree, selectionService, treeService, navService, cdr, animationService, element, parentNode) {
        super(animationService);
        this.tree = tree;
        this.selectionService = selectionService;
        this.treeService = treeService;
        this.navService = navService;
        this.cdr = cdr;
        this.element = element;
        this.parentNode = parentNode;
        /**
         * To be used for load-on-demand scenarios in order to specify whether the node is loading data.
         *
         * @remarks
         * Loading nodes do not render children.
         */
        this.loading = false;
        /**
         * Emitted when the node's `selected` property changes.
         *
         * ```html
         * <igx-tree>
         *      <igx-tree-node *ngFor="let node of data" [data]="node" [(selected)]="node.selected">
         *      </igx-tree-node>
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
         * node.selectedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log("Node selection changed to ", e))
         * ```
         */
        this.selectedChange = new EventEmitter();
        /**
         * Emitted when the node's `expanded` property changes.
         *
         * ```html
         * <igx-tree>
         *      <igx-tree-node *ngFor="let node of data" [data]="node" [(expanded)]="node.expanded">
         *      </igx-tree-node>
         * </igx-tree>
         * ```
         *
         * ```typescript
         * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
         * node.expandedChange.pipe(takeUntil(this.destroy$)).subscribe((e: boolean) => console.log("Node expansion state changed to ", e))
         * ```
         */
        this.expandedChange = new EventEmitter();
        /** @hidden @internal */
        this.cssClass = 'igx-tree-node';
        /** @hidden @internal */
        this.registeredChildren = [];
        /** @hidden @internal */
        this._resourceStrings = getCurrentResourceStrings(TreeResourceStringsEN);
        this._tabIndex = null;
        this._disabled = false;
    }
    /**
     * @hidden @internal
     */
    get showSelectors() {
        return this.tree.selection !== IgxTreeSelectionType.None;
    }
    /**
     * @hidden @internal
     */
    get indeterminate() {
        return this.selectionService.isNodeIndeterminate(this);
    }
    /** The depth of the node, relative to the root
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node #node>
     *      My level is {{ node.level }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[12])[0];
     * const level: number = node.level;
     * ```
     */
    get level() {
        return this.parentNode ? this.parentNode.level + 1 : 0;
    }
    /** Get/set whether the node is selected. Supporst two-way binding.
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node *ngFor="let node of data" [(selected)]="node.selected">
     *      {{ node.label }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const selected = node.selected;
     * node.selected = true;
     * ```
     */
    get selected() {
        return this.selectionService.isNodeSelected(this);
    }
    set selected(val) {
        if (!(this.tree?.nodes && this.tree.nodes.find((e) => e === this)) && val) {
            this.tree.forceSelect.push(this);
            return;
        }
        if (val && !this.selectionService.isNodeSelected(this)) {
            this.selectionService.selectNodesWithNoEvent([this]);
        }
        if (!val && this.selectionService.isNodeSelected(this)) {
            this.selectionService.deselectNodesWithNoEvent([this]);
        }
    }
    /** Get/set whether the node is expanded
     *
     * ```html
     * <igx-tree>
     *  ...
     *  <igx-tree-node *ngFor="let node of data" [expanded]="node.name === this.expandedNode">
     *      {{ node.label }}
     *  </igx-tree-node>
     * </igx-tree>
     * ```
     *
     * ```typescript
     * const node: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * const expanded = node.expanded;
     * node.expanded = true;
     * ```
     */
    get expanded() {
        return this.treeService.isExpanded(this);
    }
    set expanded(val) {
        if (val) {
            this.treeService.expand(this, false);
        }
        else {
            this.treeService.collapse(this);
        }
    }
    /** @hidden @internal */
    get expandIndicatorTemplate() {
        return this.tree?.expandIndicator || this._defaultExpandIndicatorTemplate;
    }
    /**
     * The native DOM element representing the node. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second node
     * const node: IgxTreeNode = this.tree.nodes.first();
     * const nodeElement: HTMLElement = node.nativeElement;
     * ```
     */
    /** @hidden @internal */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /** @hidden @internal */
    ngOnInit() {
        this.openAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.tree.nodeExpanded.emit({ owner: this.tree, node: this });
        });
        this.closeAnimationDone.pipe(takeUntil(this.destroy$)).subscribe(() => {
            this.tree.nodeCollapsed.emit({ owner: this.tree, node: this });
            this.treeService.collapse(this);
            this.cdr.markForCheck();
        });
    }
    /**
     * @hidden @internal
     * Sets the focus to the node's <a> child, if present
     * Sets the node as the tree service's focusedNode
     * Marks the node as the current active element
     */
    handleFocus() {
        if (this.disabled) {
            return;
        }
        if (this.navService.focusedNode !== this) {
            this.navService.focusedNode = this;
        }
        this.isFocused = true;
        if (this.linkChildren?.length) {
            this.linkChildren.first.nativeElement.focus();
            return;
        }
        if (this.registeredChildren.length) {
            this.registeredChildren[0].elementRef.nativeElement.focus();
            return;
        }
    }
    /**
     * @hidden @internal
     * Clear the node's focused status
     */
    clearFocus() {
        this.isFocused = false;
    }
    /**
     * @hidden @internal
     */
    onSelectorPointerDown(event) {
        event.preventDefault();
        event.stopPropagation();
    }
    /**
     * @hidden @internal
     */
    onSelectorClick(event) {
        // event.stopPropagation();
        event.preventDefault();
        // this.navService.handleFocusedAndActiveNode(this);
        if (event.shiftKey) {
            this.selectionService.selectMultipleNodes(this, event);
            return;
        }
        if (this.selected) {
            this.selectionService.deselectNode(this, event);
        }
        else {
            this.selectionService.selectNode(this, event);
        }
    }
    /**
     * Toggles the node expansion state, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button type="button" igxButton (click)="node.toggle()">Toggle Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.toggle();
     * ```
     */
    toggle() {
        if (this.expanded) {
            this.collapse();
        }
        else {
            this.expand();
        }
    }
    /** @hidden @internal */
    indicatorClick() {
        if (!this.tree.toggleNodeOnClick) {
            this.toggle();
            this.navService.setFocusedAndActiveNode(this);
        }
    }
    /**
     * @hidden @internal
     */
    onPointerDown(event) {
        event.stopPropagation();
        //Toggle the node only on left mouse click - https://w3c.github.io/pointerevents/#button-states
        if (this.tree.toggleNodeOnClick && event.button === 0) {
            this.toggle();
        }
        this.navService.setFocusedAndActiveNode(this);
    }
    ngOnDestroy() {
        super.ngOnDestroy();
        this.selectionService.ensureStateOnNodeDelete(this);
    }
    /**
     * Expands the node, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button type="button" igxButton (click)="node.expand()">Expand Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.expand();
     * ```
     */
    expand() {
        if (this.expanded && !this.treeService.collapsingNodes.has(this)) {
            return;
        }
        const args = {
            owner: this.tree,
            node: this,
            cancel: false
        };
        this.tree.nodeExpanding.emit(args);
        if (!args.cancel) {
            this.treeService.expand(this, true);
            this.cdr.detectChanges();
            this.playOpenAnimation(this.childrenContainer);
        }
    }
    /**
     * Collapses the node, triggering animation
     *
     * ```html
     * <igx-tree>
     *      <igx-tree-node #node>My Node</igx-tree-node>
     * </igx-tree>
     * <button type="button" igxButton (click)="node.collapse()">Collapse Node</button>
     * ```
     *
     * ```typescript
     * const myNode: IgxTreeNode<any> = this.tree.findNodes(data[0])[0];
     * myNode.collapse();
     * ```
     */
    collapse() {
        if (!this.expanded || this.treeService.collapsingNodes.has(this)) {
            return;
        }
        const args = {
            owner: this.tree,
            node: this,
            cancel: false
        };
        this.tree.nodeCollapsing.emit(args);
        if (!args.cancel) {
            this.treeService.collapsing(this);
            this.playCloseAnimation(this.childrenContainer);
        }
    }
    /** @hidden @internal */
    addLinkChild(link) {
        this._tabIndex = -1;
        this.registeredChildren.push(link);
    }
    /** @hidden @internal */
    removeLinkChild(link) {
        const index = this.registeredChildren.indexOf(link);
        if (index !== -1) {
            this.registeredChildren.splice(index, 1);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxTreeNodeComponent, deps: [{ token: IGX_TREE_COMPONENT }, { token: i2.IgxTreeSelectionService }, { token: i3.IgxTreeService }, { token: i1.IgxTreeNavigationService }, { token: i0.ChangeDetectorRef }, { token: IgxAngularAnimationService }, { token: i0.ElementRef }, { token: IGX_TREE_NODE_COMPONENT, optional: true, skipSelf: true }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.0.1", type: IgxTreeNodeComponent, isStandalone: true, selector: "igx-tree-node", inputs: { data: "data", loading: ["loading", "loading", booleanAttribute], resourceStrings: "resourceStrings", active: ["active", "active", booleanAttribute], disabled: ["disabled", "disabled", booleanAttribute], selected: ["selected", "selected", booleanAttribute], expanded: ["expanded", "expanded", booleanAttribute] }, outputs: { selectedChange: "selectedChange", expandedChange: "expandedChange" }, host: { properties: { "class.igx-tree-node--disabled": "this.disabled", "class.igx-tree-node": "this.cssClass", "attr.role": "this.role" } }, providers: [
            { provide: IGX_TREE_NODE_COMPONENT, useExisting: IgxTreeNodeComponent }
        ], queries: [{ propertyName: "linkChildren", predicate: IgxTreeNodeLinkDirective, read: ElementRef }, { propertyName: "_children", predicate: IGX_TREE_NODE_COMPONENT, read: IGX_TREE_NODE_COMPONENT }, { propertyName: "allChildren", predicate: IGX_TREE_NODE_COMPONENT, descendants: true, read: IGX_TREE_NODE_COMPONENT }], viewQueries: [{ propertyName: "header", first: true, predicate: ["ghostTemplate"], descendants: true, read: ElementRef }, { propertyName: "_defaultExpandIndicatorTemplate", first: true, predicate: ["defaultIndicator"], descendants: true, read: TemplateRef, static: true }, { propertyName: "childrenContainer", first: true, predicate: ["childrenContainer"], descendants: true, read: ElementRef }], usesInheritance: true, ngImport: i0, template: "<ng-template #noDragTemplate>\n    <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n</ng-template>\n\n<!-- Will switch templates depending on dragDrop -->\n<ng-template *ngTemplateOutlet=\"noDragTemplate\">\n</ng-template>\n\n<div #childrenContainer\n    *ngIf=\"expanded && !loading\"\n    class=\"igx-tree-node__group\"\n    role=\"group\"\n>\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n\n\n<ng-template #defaultIndicator>\n    <igx-icon [attr.aria-label]=\"expanded ? resourceStrings.igx_collapse : resourceStrings.igx_expand\">\n        {{ expanded ? \"keyboard_arrow_down\" : \"keyboard_arrow_right\" }}\n    </igx-icon>\n</ng-template>\n\n<!-- separated in a template in case this ever needs to be templatable -->\n<ng-template #selectMarkerTemplate>\n    <igx-checkbox [checked]=\"selected\" [disabled]=\"disabled\" [readonly]=\"true\" [indeterminate]=\"indeterminate\" [tabindex]=\"-1\">\n    </igx-checkbox>\n</ng-template>\n\n<ng-template #headerTemplate>\n    <div #ghostTemplate class=\"igx-tree-node__wrapper\"\n        [attr.role]=\"role\"\n        [tabIndex]=\"tabIndex\"\n        [ngClass]=\"{\n            'igx-tree-node__wrapper--selected': selected,\n            'igx-tree-node__wrapper--active' : this.active,\n            'igx-tree-node__wrapper--focused' : this.focused,\n            'igx-tree-node__wrapper--disabled' : this.disabled\n        }\"\n        (pointerdown)=\"onPointerDown($event)\"\n        (focus)=\"handleFocus()\"\n        (blur)=\"clearFocus()\"\n    >\n        <div aria-hidden=\"true\">\n            <span *ngFor=\"let item of [].constructor(level)\"\n                aria-hidden=\"true\"\n                class=\"igx-tree-node__spacer\"\n            ></span>\n        </div>\n\n        <!-- Expand/Collapse indicator -->\n        <span *ngIf=\"!loading\"\n            class=\"igx-tree-node__toggle-button\"\n            [ngClass]=\"{ 'igx-tree-node__toggle-button--hidden': !_children?.length }\"\n            (click)=\"indicatorClick()\"\n        >\n            <ng-container *ngTemplateOutlet=\"expandIndicatorTemplate, context: { $implicit: expanded }\">\n            </ng-container>\n        </span>\n        <span *ngIf=\"loading\"\n            class=\"igx-tree-node__toggle-button\"\n        >\n        \t<igx-circular-bar\n            \t[animate]=\"false\"\n            \t[indeterminate]=\"true\"\n            \t[textVisibility]=\"false\"\n        \t>\n        \t</igx-circular-bar>\n        </span>\n\n        <!-- Item selection -->\n        <div *ngIf=\"showSelectors\"\n            class=\"igx-tree-node__select\"\n            (pointerdown)=\"onSelectorPointerDown($event)\"\n            (click)=\"onSelectorClick($event)\">\n            <ng-container *ngTemplateOutlet=\"selectMarkerTemplate\">\n            </ng-container>\n        </div>\n\n        <div class=\"igx-tree-node__content\">\n            <!-- Ghost content -->\n            <ng-content></ng-content>\n        </div>\n    </div>\n\n    <!--  Buffer element for 'move after' when D&D is implemented-->\n    <div class=\"igx-tree-node__drop-indicator\">\n        <span aria-hidden=\"true\" class=\"igx-tree-node__spacer\" *ngFor=\"let item of [].constructor(level)\"></span>\n        <!-- style rules target this div, do not delete it -->\n        <div></div>\n    </div>\n</ng-template>\n\n<ng-template #dragTemplate>\n    <!-- Drag drop goes here\n        igxDrop\n        #dropRef=\"drop\"\n        [igxNodeDrag]=\"this\"\n        (dragStart)=\"logDrop(dropRef)\"\n        (leave)=\"emitLeave()\"\n        (enter)=\"emitEnter()\" -->\n    <div class=\"igx-tree-node__drag-wrapper\">\n        <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n    </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "component", type: IgxCheckboxComponent, selector: "igx-checkbox", inputs: ["id", "labelId", "value", "name", "tabindex", "labelPosition", "disableRipple", "required", "aria-labelledby", "aria-label", "indeterminate", "checked", "disabled", "invalid", "readonly", "disableTransitions"], outputs: ["change"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IgxCircularProgressBarComponent, selector: "igx-circular-bar", inputs: ["id", "isIndeterminate", "textVisibility", "text"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxTreeNodeComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree-node', providers: [
                        { provide: IGX_TREE_NODE_COMPONENT, useExisting: IgxTreeNodeComponent }
                    ], standalone: true, imports: [NgTemplateOutlet, NgIf, IgxIconComponent, IgxCheckboxComponent, NgClass, NgFor, IgxCircularProgressBarComponent], template: "<ng-template #noDragTemplate>\n    <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n</ng-template>\n\n<!-- Will switch templates depending on dragDrop -->\n<ng-template *ngTemplateOutlet=\"noDragTemplate\">\n</ng-template>\n\n<div #childrenContainer\n    *ngIf=\"expanded && !loading\"\n    class=\"igx-tree-node__group\"\n    role=\"group\"\n>\n    <ng-content select=\"igx-tree-node\"></ng-content>\n</div>\n\n\n<ng-template #defaultIndicator>\n    <igx-icon [attr.aria-label]=\"expanded ? resourceStrings.igx_collapse : resourceStrings.igx_expand\">\n        {{ expanded ? \"keyboard_arrow_down\" : \"keyboard_arrow_right\" }}\n    </igx-icon>\n</ng-template>\n\n<!-- separated in a template in case this ever needs to be templatable -->\n<ng-template #selectMarkerTemplate>\n    <igx-checkbox [checked]=\"selected\" [disabled]=\"disabled\" [readonly]=\"true\" [indeterminate]=\"indeterminate\" [tabindex]=\"-1\">\n    </igx-checkbox>\n</ng-template>\n\n<ng-template #headerTemplate>\n    <div #ghostTemplate class=\"igx-tree-node__wrapper\"\n        [attr.role]=\"role\"\n        [tabIndex]=\"tabIndex\"\n        [ngClass]=\"{\n            'igx-tree-node__wrapper--selected': selected,\n            'igx-tree-node__wrapper--active' : this.active,\n            'igx-tree-node__wrapper--focused' : this.focused,\n            'igx-tree-node__wrapper--disabled' : this.disabled\n        }\"\n        (pointerdown)=\"onPointerDown($event)\"\n        (focus)=\"handleFocus()\"\n        (blur)=\"clearFocus()\"\n    >\n        <div aria-hidden=\"true\">\n            <span *ngFor=\"let item of [].constructor(level)\"\n                aria-hidden=\"true\"\n                class=\"igx-tree-node__spacer\"\n            ></span>\n        </div>\n\n        <!-- Expand/Collapse indicator -->\n        <span *ngIf=\"!loading\"\n            class=\"igx-tree-node__toggle-button\"\n            [ngClass]=\"{ 'igx-tree-node__toggle-button--hidden': !_children?.length }\"\n            (click)=\"indicatorClick()\"\n        >\n            <ng-container *ngTemplateOutlet=\"expandIndicatorTemplate, context: { $implicit: expanded }\">\n            </ng-container>\n        </span>\n        <span *ngIf=\"loading\"\n            class=\"igx-tree-node__toggle-button\"\n        >\n        \t<igx-circular-bar\n            \t[animate]=\"false\"\n            \t[indeterminate]=\"true\"\n            \t[textVisibility]=\"false\"\n        \t>\n        \t</igx-circular-bar>\n        </span>\n\n        <!-- Item selection -->\n        <div *ngIf=\"showSelectors\"\n            class=\"igx-tree-node__select\"\n            (pointerdown)=\"onSelectorPointerDown($event)\"\n            (click)=\"onSelectorClick($event)\">\n            <ng-container *ngTemplateOutlet=\"selectMarkerTemplate\">\n            </ng-container>\n        </div>\n\n        <div class=\"igx-tree-node__content\">\n            <!-- Ghost content -->\n            <ng-content></ng-content>\n        </div>\n    </div>\n\n    <!--  Buffer element for 'move after' when D&D is implemented-->\n    <div class=\"igx-tree-node__drop-indicator\">\n        <span aria-hidden=\"true\" class=\"igx-tree-node__spacer\" *ngFor=\"let item of [].constructor(level)\"></span>\n        <!-- style rules target this div, do not delete it -->\n        <div></div>\n    </div>\n</ng-template>\n\n<ng-template #dragTemplate>\n    <!-- Drag drop goes here\n        igxDrop\n        #dropRef=\"drop\"\n        [igxNodeDrag]=\"this\"\n        (dragStart)=\"logDrop(dropRef)\"\n        (leave)=\"emitLeave()\"\n        (enter)=\"emitEnter()\" -->\n    <div class=\"igx-tree-node__drag-wrapper\">\n        <ng-template *ngTemplateOutlet=\"headerTemplate\"></ng-template>\n    </div>\n</ng-template>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_TREE_COMPONENT]
                }] }, { type: i2.IgxTreeSelectionService }, { type: i3.IgxTreeService }, { type: i1.IgxTreeNavigationService }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [IgxAngularAnimationService]
                }] }, { type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: SkipSelf
                }, {
                    type: Inject,
                    args: [IGX_TREE_NODE_COMPONENT]
                }] }], propDecorators: { data: [{
                type: Input
            }], loading: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], resourceStrings: [{
                type: Input
            }], active: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], selectedChange: [{
                type: Output
            }], expandedChange: [{
                type: Output
            }], disabled: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }, {
                type: HostBinding,
                args: ['class.igx-tree-node--disabled']
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-tree-node']
            }], role: [{
                type: HostBinding,
                args: ['attr.role']
            }], linkChildren: [{
                type: ContentChildren,
                args: [IgxTreeNodeLinkDirective, { read: ElementRef }]
            }], _children: [{
                type: ContentChildren,
                args: [IGX_TREE_NODE_COMPONENT, { read: IGX_TREE_NODE_COMPONENT }]
            }], allChildren: [{
                type: ContentChildren,
                args: [IGX_TREE_NODE_COMPONENT, { read: IGX_TREE_NODE_COMPONENT, descendants: true }]
            }], header: [{
                type: ViewChild,
                args: ['ghostTemplate', { read: ElementRef }]
            }], _defaultExpandIndicatorTemplate: [{
                type: ViewChild,
                args: ['defaultIndicator', { read: TemplateRef, static: true }]
            }], childrenContainer: [{
                type: ViewChild,
                args: ['childrenContainer', { read: ElementRef }]
            }], selected: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], expanded: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ub2RlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi90cmVlL3RyZWUtbm9kZS90cmVlLW5vZGUuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3RyZWUvdHJlZS1ub2RlL3RyZWUtbm9kZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBRUgsU0FBUyxFQUNULGVBQWUsRUFDZixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixXQUFXLEVBQ1gsWUFBWSxFQUNaLE1BQU0sRUFDTixLQUFLLEVBR0wsUUFBUSxFQUNSLE1BQU0sRUFFTixRQUFRLEVBQ1IsV0FBVyxFQUNYLFNBQVMsRUFDVCxnQkFBZ0IsRUFDbkIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBd0IscUJBQXFCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM3RixPQUFPLEVBQUUscUJBQXFCLEVBQTJCLE1BQU0sa0RBQWtELENBQUM7QUFDbEgsT0FBTyxFQUFFLDBCQUEwQixFQUFFLE1BQU0sb0RBQW9ELENBQUM7QUFFaEcsT0FBTyxFQUdILG9CQUFvQixFQUNwQixrQkFBa0IsRUFDbEIsdUJBQXVCLEVBRTFCLE1BQU0sV0FBVyxDQUFDO0FBSW5CLE9BQU8sRUFBRSwrQkFBK0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDO0FBQzFGLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzdELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtB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QUMscUJBQXFCO2dCQUt2QixJQUFJO3NCQURkLFdBQVc7dUJBQUMsV0FBVztnQkFPakIsWUFBWTtzQkFEbEIsZUFBZTt1QkFBQyx3QkFBd0IsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7Z0JBS3hELFNBQVM7c0JBRGYsZUFBZTt1QkFBQyx1QkFBdUIsRUFBRSxFQUFFLElBQUksRUFBRSx1QkFBdUIsRUFBRTtnQkFLcEUsV0FBVztzQkFEakIsZUFBZTt1QkFBQyx1QkFBdUIsRUFBRSxFQUFFLElBQUksRUFBRSx1QkFBdUIsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFO2dCQXNCdkYsTUFBTTtzQkFEWixTQUFTO3VCQUFDLGVBQWUsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUU7Z0JBSXhDLCtCQUErQjtzQkFEdEMsU0FBUzt1QkFBQyxrQkFBa0IsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtnQkFJMUQsaUJBQWlCO3NCQUR4QixTQUFTO3VCQUFDLG1CQUFtQixFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRTtnQkFvRnpDLFFBQVE7c0JBRGxCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBb0MzQixRQUFRO3NCQURsQixLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0LFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBTa2lwU2VsZixcbiAgICBUZW1wbGF0ZVJlZixcbiAgICBWaWV3Q2hpbGQsXG4gICAgYm9vbGVhbkF0dHJpYnV0ZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElUcmVlUmVzb3VyY2VTdHJpbmdzLCBUcmVlUmVzb3VyY2VTdHJpbmdzRU4gfSBmcm9tICcuLi8uLi9jb3JlL2kxOG4vdHJlZS1yZXNvdXJjZXMnO1xuaW1wb3J0IHsgVG9nZ2xlQW5pbWF0aW9uUGxheWVyLCBUb2dnbGVBbmltYXRpb25TZXR0aW5ncyB9IGZyb20gJy4uLy4uL2V4cGFuc2lvbi1wYW5lbC90b2dnbGUtYW5pbWF0aW9uLWNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hBbmd1bGFyQW5pbWF0aW9uU2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL2FuaW1hdGlvbi9hbmd1bGFyLWFuaW1hdGlvbi1zZXJ2aWNlJztcbmltcG9ydCB7IEFuaW1hdGlvblNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9hbmltYXRpb24vYW5pbWF0aW9uJztcbmltcG9ydCB7XG4gICAgSWd4VHJlZSxcbiAgICBJZ3hUcmVlTm9kZSxcbiAgICBJZ3hUcmVlU2VsZWN0aW9uVHlwZSxcbiAgICBJR1hfVFJFRV9DT01QT05FTlQsXG4gICAgSUdYX1RSRUVfTk9ERV9DT01QT05FTlQsXG4gICAgSVRyZWVOb2RlVG9nZ2xpbmdFdmVudEFyZ3Ncbn0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7IElneFRyZWVOYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL3RyZWUtbmF2aWdhdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IElneFRyZWVTZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vdHJlZS1zZWxlY3Rpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hUcmVlU2VydmljZSB9IGZyb20gJy4uL3RyZWUuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vcHJvZ3Jlc3NiYXIvcHJvZ3Jlc3NiYXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneENoZWNrYm94Q29tcG9uZW50IH0gZnJvbSAnLi4vLi4vY2hlY2tib3gvY2hlY2tib3guY29tcG9uZW50JztcbmltcG9ydCB7IElneEljb25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9pY29uL2ljb24uY29tcG9uZW50JztcbmltcG9ydCB7IE5nVGVtcGxhdGVPdXRsZXQsIE5nSWYsIE5nQ2xhc3MsIE5nRm9yIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IGdldEN1cnJlbnRSZXNvdXJjZVN0cmluZ3MgfSBmcm9tICcuLi8uLi9jb3JlL2kxOG4vcmVzb3VyY2VzJztcblxuLy8gVE9ETzogSW1wbGVtZW50IGFyaWEgZnVuY3Rpb25hbGl0eVxuLyoqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICogVXNlZCBmb3IgbGlua3MgKGBhYCB0YWdzKSBpbiB0aGUgYm9keSBvZiBhbiBgaWd4LXRyZWUtbm9kZWAuIEhhbmRsZXMgYXJpYSBhbmQgZXZlbnQgZGlzcGF0Y2guXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiBgW2lneFRyZWVOb2RlTGlua11gLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZU5vZGVMaW5rRGlyZWN0aXZlIGltcGxlbWVudHMgT25EZXN0cm95IHtcblxuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBwdWJsaWMgcm9sZSA9ICd0cmVlaXRlbSc7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSdzIHBhcmVudC4gU2hvdWxkIGJlIHVzZWQgb25seSB3aGVuIHRoZSBsaW5rIGlzIGRlZmluZWRcbiAgICAgKiBpbiBgPG5nLXRlbXBsYXRlPmAgdGFnIG91dHNpZGUgb2YgaXRzIHBhcmVudCwgYXMgQW5ndWxhciBESSB3aWxsIG5vdCBwcm9wZXJseSBwcm92aWRlIGEgcmVmZXJlbmNlXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICA8aWd4LXRyZWUtbm9kZSAjbXlOb2RlICpuZ0Zvcj1cImxldCBub2RlIG9mIGRhdGFcIiBbZGF0YV09XCJub2RlXCI+XG4gICAgICogICAgICAgICA8bmctdGVtcGxhdGUgKm5nVGVtcGxhdGVPdXRsZXQ9XCJub2RlVGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBkYXRhLCBwYXJlbnROb2RlOiBteU5vZGUgfVwiPlxuICAgICAqICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiAgICAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqICAgICAuLi5cbiAgICAgKiAgICAgPCEtLSBub2RlIHRlbXBsYXRlIGlzIGRlZmluZWQgdW5kZXIgdHJlZSB0byBhY2Nlc3MgcmVsYXRlZCBzZXJ2aWNlcyAtLT5cbiAgICAgKiAgICAgPG5nLXRlbXBsYXRlICNub2RlVGVtcGxhdGUgbGV0LWRhdGEgbGV0LW5vZGU9XCJwYXJlbnROb2RlXCI+XG4gICAgICogICAgICAgICA8YSBbaWd4VHJlZU5vZGVMaW5rXT1cIm5vZGVcIj57eyBkYXRhLmxhYmVsIH19PC9hPlxuICAgICAqICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUcmVlTm9kZUxpbmsnKVxuICAgIHB1YmxpYyBzZXQgcGFyZW50Tm9kZSh2YWw6IGFueSkge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnROb2RlID0gdmFsO1xuICAgICAgICAgICAgKHRoaXMuX3BhcmVudE5vZGUgYXMgYW55KS5hZGRMaW5rQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHBhcmVudE5vZGUoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLyoqIEEgcG9pbnRlciB0byB0aGUgcGFyZW50IG5vZGUgKi9cbiAgICBwcml2YXRlIGdldCB0YXJnZXQoKTogSWd4VHJlZU5vZGU8YW55PiB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUgfHwgdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3BhcmVudE5vZGU6IElneFRyZWVOb2RlPGFueT4gPSBudWxsO1xuXG4gICAgY29uc3RydWN0b3IoQE9wdGlvbmFsKCkgQEluamVjdChJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVClcbiAgICBwcml2YXRlIG5vZGU6IElneFRyZWVOb2RlPGFueT4sXG4gICAgICAgIHByaXZhdGUgbmF2U2VydmljZTogSWd4VHJlZU5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICBwdWJsaWMgZWxlbWVudFJlZjogRWxlbWVudFJlZikge1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci50YWJpbmRleCcpXG4gICAgcHVibGljIGdldCB0YWJJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5uYXZTZXJ2aWNlLmZvY3VzZWROb2RlID09PSB0aGlzLnRhcmdldCA/ICh0aGlzLnRhcmdldD8uZGlzYWJsZWQgPyAtMSA6IDApIDogLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBDbGVhciB0aGUgbm9kZSdzIGZvY3VzZWQgc3RhdGVcbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdibHVyJylcbiAgICBwdWJsaWMgaGFuZGxlQmx1cigpIHtcbiAgICAgICAgdGhpcy50YXJnZXQuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBTZXQgdGhlIG5vZGUgYXMgZm9jdXNlZFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2ZvY3VzJylcbiAgICBwdWJsaWMgaGFuZGxlRm9jdXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnRhcmdldCAmJiAhdGhpcy50YXJnZXQuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGUgIT09IHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLmZvY3VzZWROb2RlID0gdGhpcy50YXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRhcmdldC5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnRhcmdldC5yZW1vdmVMaW5rQ2hpbGQodGhpcyk7XG4gICAgfVxufVxuXG4vKipcbiAqXG4gKiBUaGUgdHJlZSBub2RlIGNvbXBvbmVudCByZXByZXNlbnRzIGEgY2hpbGQgbm9kZSBvZiB0aGUgdHJlZSBjb21wb25lbnQgb3IgYW5vdGhlciB0cmVlIG5vZGUuXG4gKiBVc2FnZTpcbiAqXG4gKiBgYGBodG1sXG4gKiAgPGlneC10cmVlPlxuICogIC4uLlxuICogICAgPGlneC10cmVlLW5vZGUgW2RhdGFdPVwiZGF0YVwiIFtzZWxlY3RlZF09XCJzZXJ2aWNlLmlzTm9kZVNlbGVjdGVkKGRhdGEuS2V5KVwiIFtleHBhbmRlZF09XCJzZXJ2aWNlLmlzTm9kZUV4cGFuZGVkKGRhdGEuS2V5KVwiPlxuICogICAgICB7eyBkYXRhLkZpcnN0TmFtZSB9fSB7eyBkYXRhLkxhc3ROYW1lIH19XG4gKiAgICA8L2lneC10cmVlLW5vZGU+XG4gKiAgLi4uXG4gKiAgPC9pZ3gtdHJlZT5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC10cmVlLW5vZGUnLFxuICAgIHRlbXBsYXRlVXJsOiAndHJlZS1ub2RlLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgeyBwcm92aWRlOiBJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVCwgdXNlRXhpc3Rpbmc6IElneFRyZWVOb2RlQ29tcG9uZW50IH1cbiAgICBdLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW05nVGVtcGxhdGVPdXRsZXQsIE5nSWYsIElneEljb25Db21wb25lbnQsIElneENoZWNrYm94Q29tcG9uZW50LCBOZ0NsYXNzLCBOZ0ZvciwgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudF1cbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZU5vZGVDb21wb25lbnQ8VD4gZXh0ZW5kcyBUb2dnbGVBbmltYXRpb25QbGF5ZXIgaW1wbGVtZW50cyBJZ3hUcmVlTm9kZTxUPiwgT25Jbml0LCBPbkRlc3Ryb3kge1xuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIGVudHJ5IHRoYXQgdGhlIG5vZGUgaXMgdmlzdWFsaXppbmcuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqIFJlcXVpcmVkIGZvciBzZWFyY2hpbmcgdGhyb3VnaCBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LXRyZWU+XG4gICAgICogIC4uLlxuICAgICAqICAgIDxpZ3gtdHJlZS1ub2RlIFtkYXRhXT1cImRhdGFcIj5cbiAgICAgKiAgICAgIHt7IGRhdGEuRmlyc3ROYW1lIH19IHt7IGRhdGEuTGFzdE5hbWUgfX1cbiAgICAgKiAgICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogIC4uLlxuICAgICAqICA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGRhdGE6IFQ7XG5cbiAgICAvKipcbiAgICAgKiBUbyBiZSB1c2VkIGZvciBsb2FkLW9uLWRlbWFuZCBzY2VuYXJpb3MgaW4gb3JkZXIgdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSBub2RlIGlzIGxvYWRpbmcgZGF0YS5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogTG9hZGluZyBub2RlcyBkbyBub3QgcmVuZGVyIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBsb2FkaW5nID0gZmFsc2U7XG5cbiAgICAvLyBUTyBETzogcmV0dXJuIGRpZmZlcmVudCB0YWIgaW5kZXggZGVwZW5kaW5nIG9uIGFuY2hvciBjaGlsZFxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBzZXQgdGFiSW5kZXgodmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdGFiSW5kZXggPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCB0YWJJbmRleCgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl90YWJJbmRleCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0xpbmtDaGlsZHJlbiA/IC0xIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYXNMaW5rQ2hpbGRyZW4gPyAtMSA6IHRoaXMuX3RhYkluZGV4O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgYW5pbWF0aW9uU2V0dGluZ3MoKTogVG9nZ2xlQW5pbWF0aW9uU2V0dGluZ3Mge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmFuaW1hdGlvblNldHRpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgcmVzb3VyY2Ugc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVXNlcyBFTiByZXNvdXJjZXMgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgcmVzb3VyY2VTdHJpbmdzKHZhbHVlOiBJVHJlZVJlc291cmNlU3RyaW5ncykge1xuICAgICAgICB0aGlzLl9yZXNvdXJjZVN0cmluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9yZXNvdXJjZVN0cmluZ3MsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBhY2Nlc3NvciB0aGF0IHJldHVybnMgdGhlIHJlc291cmNlIHN0cmluZ3MuXG4gICAgICovXG4gICAgcHVibGljIGdldCByZXNvdXJjZVN0cmluZ3MoKTogSVRyZWVSZXNvdXJjZVN0cmluZ3Mge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VTdHJpbmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWU6IGJvb2xlYW5cbiAgICAgKi9cbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgc2V0IGFjdGl2ZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubmF2U2VydmljZS5hY3RpdmVOb2RlID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMudHJlZS5hY3RpdmVOb2RlQmluZGluZ0NoYW5nZS5lbWl0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBhY3RpdmUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLm5hdlNlcnZpY2UuYWN0aXZlTm9kZSA9PT0gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gdGhlIG5vZGUncyBgc2VsZWN0ZWRgIHByb3BlcnR5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICAgPGlneC10cmVlLW5vZGUgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YVwiIFtkYXRhXT1cIm5vZGVcIiBbKHNlbGVjdGVkKV09XCJub2RlLnNlbGVjdGVkXCI+XG4gICAgICogICAgICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBub2RlLnNlbGVjdGVkQ2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKGU6IGJvb2xlYW4pID0+IGNvbnNvbGUubG9nKFwiTm9kZSBzZWxlY3Rpb24gY2hhbmdlZCB0byBcIiwgZSkpXG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHNlbGVjdGVkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBub2RlJ3MgYGV4cGFuZGVkYCBwcm9wZXJ0eSBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgICAgIDxpZ3gtdHJlZS1ub2RlICpuZ0Zvcj1cImxldCBub2RlIG9mIGRhdGFcIiBbZGF0YV09XCJub2RlXCIgWyhleHBhbmRlZCldPVwibm9kZS5leHBhbmRlZFwiPlxuICAgICAqICAgICAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgbm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXMoZGF0YVswXSlbMF07XG4gICAgICogbm9kZS5leHBhbmRlZENoYW5nZS5waXBlKHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKSkuc3Vic2NyaWJlKChlOiBib29sZWFuKSA9PiBjb25zb2xlLmxvZyhcIk5vZGUgZXhwYW5zaW9uIHN0YXRlIGNoYW5nZWQgdG8gXCIsIGUpKVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBleHBhbmRlZENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8Ym9vbGVhbj4oKTtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgZm9jdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNGb2N1c2VkICYmXG4gICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2UuZm9jdXNlZE5vZGUgPT09IHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBmdWxsIHBhdGggdG8gdGhlIG5vZGUgaW5jdWRpbmcgaXRzZWxmXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgbm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXMoZGF0YVswXSlbMF07XG4gICAgICogY29uc3QgcGF0aDogSWd4VHJlZU5vZGU8YW55PltdID0gbm9kZS5wYXRoO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcGF0aCgpOiBJZ3hUcmVlTm9kZTxhbnk+W10ge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnROb2RlPy5wYXRoID8gWy4uLnRoaXMucGFyZW50Tm9kZS5wYXRoLCB0aGlzXSA6IFt0aGlzXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBiaW5kIHRvIGRpc2FibGVkIHN0YXRlIHdoZW4gbm9kZSBpcyBkcmFnZ2VkXG4gICAgLyoqXG4gICAgICogR2V0cy9TZXRzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlOiBib29sZWFuXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdHJlZS1ub2RlLS1kaXNhYmxlZCcpXG4gICAgcHVibGljIGdldCBkaXNhYmxlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Rpc2FibGVkO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZGlzYWJsZWQodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9kaXNhYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fZGlzYWJsZWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMudHJlZS5kaXNhYmxlZENoYW5nZS5lbWl0KHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdHJlZS1ub2RlJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LXRyZWUtbm9kZSc7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gICAgcHVibGljIGdldCByb2xlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNMaW5rQ2hpbGRyZW4gPyAnbm9uZScgOiAndHJlZWl0ZW0nO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4VHJlZU5vZGVMaW5rRGlyZWN0aXZlLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwdWJsaWMgbGlua0NoaWxkcmVuOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKElHWF9UUkVFX05PREVfQ09NUE9ORU5ULCB7IHJlYWQ6IElHWF9UUkVFX05PREVfQ09NUE9ORU5UIH0pXG4gICAgcHVibGljIF9jaGlsZHJlbjogUXVlcnlMaXN0PElneFRyZWVOb2RlPGFueT4+O1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVCwgeyByZWFkOiBJR1hfVFJFRV9OT0RFX0NPTVBPTkVOVCwgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgICBwdWJsaWMgYWxsQ2hpbGRyZW46IFF1ZXJ5TGlzdDxJZ3hUcmVlTm9kZTxhbnk+PjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIG5vZGUgKGlmIGFueSlcbiAgICAgKlxuICAgICAqIEByZW1hcmtcbiAgICAgKiBSZXR1cm5zIGBudWxsYCBpZiBub2RlIGRvZXMgbm90IGhhdmUgY2hpbGRyZW5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIGNvbnN0IGNoaWxkcmVuOiBJZ3hUcmVlTm9kZTxhbnk+W10gPSBub2RlLmNoaWxkcmVuO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY2hpbGRyZW4oKTogSWd4VHJlZU5vZGU8YW55PltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuPy5sZW5ndGggPyB0aGlzLl9jaGlsZHJlbi50b0FycmF5KCkgOiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHdpbGwgYmUgdXNlZCBpbiBEcmFnIGFuZCBEcm9wIGltcGxlbWVudGF0aW9uXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQFZpZXdDaGlsZCgnZ2hvc3RUZW1wbGF0ZScsIHsgcmVhZDogRWxlbWVudFJlZiB9KVxuICAgIHB1YmxpYyBoZWFkZXI6IEVsZW1lbnRSZWY7XG5cbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0SW5kaWNhdG9yJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSBfZGVmYXVsdEV4cGFuZEluZGljYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgQFZpZXdDaGlsZCgnY2hpbGRyZW5Db250YWluZXInLCB7IHJlYWQ6IEVsZW1lbnRSZWYgfSlcbiAgICBwcml2YXRlIGNoaWxkcmVuQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgcHJpdmF0ZSBnZXQgaGFzTGlua0NoaWxkcmVuKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5saW5rQ2hpbGRyZW4/Lmxlbmd0aCA+IDAgfHwgdGhpcy5yZWdpc3RlcmVkQ2hpbGRyZW4/Lmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGlzRm9jdXNlZDogYm9vbGVhbjtcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyByZWdpc3RlcmVkQ2hpbGRyZW46IElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZVtdID0gW107XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwcml2YXRlIF9yZXNvdXJjZVN0cmluZ3MgPSBnZXRDdXJyZW50UmVzb3VyY2VTdHJpbmdzKFRyZWVSZXNvdXJjZVN0cmluZ3NFTik7XG5cbiAgICBwcml2YXRlIF90YWJJbmRleCA9IG51bGw7XG4gICAgcHJpdmF0ZSBfZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KElHWF9UUkVFX0NPTVBPTkVOVCkgcHVibGljIHRyZWU6IElneFRyZWUsXG4gICAgICAgIHByb3RlY3RlZCBzZWxlY3Rpb25TZXJ2aWNlOiBJZ3hUcmVlU2VsZWN0aW9uU2VydmljZSxcbiAgICAgICAgcHJvdGVjdGVkIHRyZWVTZXJ2aWNlOiBJZ3hUcmVlU2VydmljZSxcbiAgICAgICAgcHJvdGVjdGVkIG5hdlNlcnZpY2U6IElneFRyZWVOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgcHJvdGVjdGVkIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEBJbmplY3QoSWd4QW5ndWxhckFuaW1hdGlvblNlcnZpY2UpIGFuaW1hdGlvblNlcnZpY2U6IEFuaW1hdGlvblNlcnZpY2UsXG4gICAgICAgIHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgICAgIEBPcHRpb25hbCgpIEBTa2lwU2VsZigpIEBJbmplY3QoSUdYX1RSRUVfTk9ERV9DT01QT05FTlQpIHB1YmxpYyBwYXJlbnROb2RlOiBJZ3hUcmVlTm9kZTxhbnk+XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGFuaW1hdGlvblNlcnZpY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBzaG93U2VsZWN0b3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnNlbGVjdGlvbiAhPT0gSWd4VHJlZVNlbGVjdGlvblR5cGUuTm9uZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaW5kZXRlcm1pbmF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc05vZGVJbmRldGVybWluYXRlKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKiBUaGUgZGVwdGggb2YgdGhlIG5vZGUsIHJlbGF0aXZlIHRvIHRoZSByb290XG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAuLi5cbiAgICAgKiAgPGlneC10cmVlLW5vZGUgI25vZGU+XG4gICAgICogICAgICBNeSBsZXZlbCBpcyB7eyBub2RlLmxldmVsIH19XG4gICAgICogIDwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IG5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMTJdKVswXTtcbiAgICAgKiBjb25zdCBsZXZlbDogbnVtYmVyID0gbm9kZS5sZXZlbDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxldmVsKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudE5vZGUgPyB0aGlzLnBhcmVudE5vZGUubGV2ZWwgKyAxIDogMDtcbiAgICB9XG5cbiAgICAvKiogR2V0L3NldCB3aGV0aGVyIHRoZSBub2RlIGlzIHNlbGVjdGVkLiBTdXBwb3JzdCB0d28td2F5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAuLi5cbiAgICAgKiAgPGlneC10cmVlLW5vZGUgKm5nRm9yPVwibGV0IG5vZGUgb2YgZGF0YVwiIFsoc2VsZWN0ZWQpXT1cIm5vZGUuc2VsZWN0ZWRcIj5cbiAgICAgKiAgICAgIHt7IG5vZGUubGFiZWwgfX1cbiAgICAgKiAgPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgbm9kZTogSWd4VHJlZU5vZGU8YW55PiA9IHRoaXMudHJlZS5maW5kTm9kZXMoZGF0YVswXSlbMF07XG4gICAgICogY29uc3Qgc2VsZWN0ZWQgPSBub2RlLnNlbGVjdGVkO1xuICAgICAqIG5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCh7IHRyYW5zZm9ybTogYm9vbGVhbkF0dHJpYnV0ZSB9KVxuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvblNlcnZpY2UuaXNOb2RlU2VsZWN0ZWQodGhpcyk7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBzZWxlY3RlZCh2YWw6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKCEodGhpcy50cmVlPy5ub2RlcyAmJiB0aGlzLnRyZWUubm9kZXMuZmluZCgoZSkgPT4gZSA9PT0gdGhpcykpICYmIHZhbCkge1xuICAgICAgICAgICAgdGhpcy50cmVlLmZvcmNlU2VsZWN0LnB1c2godGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCAmJiAhdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmlzTm9kZVNlbGVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0Tm9kZXNXaXRoTm9FdmVudChbdGhpc10pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsICYmIHRoaXMuc2VsZWN0aW9uU2VydmljZS5pc05vZGVTZWxlY3RlZCh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLmRlc2VsZWN0Tm9kZXNXaXRoTm9FdmVudChbdGhpc10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEdldC9zZXQgd2hldGhlciB0aGUgbm9kZSBpcyBleHBhbmRlZFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZT5cbiAgICAgKiAgLi4uXG4gICAgICogIDxpZ3gtdHJlZS1ub2RlICpuZ0Zvcj1cImxldCBub2RlIG9mIGRhdGFcIiBbZXhwYW5kZWRdPVwibm9kZS5uYW1lID09PSB0aGlzLmV4cGFuZGVkTm9kZVwiPlxuICAgICAqICAgICAge3sgbm9kZS5sYWJlbCB9fVxuICAgICAqICA8L2lneC10cmVlLW5vZGU+XG4gICAgICogPC9pZ3gtdHJlZT5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBub2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBjb25zdCBleHBhbmRlZCA9IG5vZGUuZXhwYW5kZWQ7XG4gICAgICogbm9kZS5leHBhbmRlZCA9IHRydWU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIGdldCBleHBhbmRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZVNlcnZpY2UuaXNFeHBhbmRlZCh0aGlzKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGV4cGFuZGVkKHZhbDogYm9vbGVhbikge1xuICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVTZXJ2aWNlLmV4cGFuZCh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVTZXJ2aWNlLmNvbGxhcHNlKHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBleHBhbmRJbmRpY2F0b3JUZW1wbGF0ZSgpOiBUZW1wbGF0ZVJlZjxhbnk+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZT8uZXhwYW5kSW5kaWNhdG9yIHx8IHRoaXMuX2RlZmF1bHRFeHBhbmRJbmRpY2F0b3JUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmF0aXZlIERPTSBlbGVtZW50IHJlcHJlc2VudGluZyB0aGUgbm9kZS4gQ291bGQgYmUgbnVsbCBpbiBjZXJ0YWluIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXQgdGhlIG5hdGl2ZUVsZW1lbnQgb2YgdGhlIHNlY29uZCBub2RlXG4gICAgICogY29uc3Qgbm9kZTogSWd4VHJlZU5vZGUgPSB0aGlzLnRyZWUubm9kZXMuZmlyc3QoKTtcbiAgICAgKiBjb25zdCBub2RlRWxlbWVudDogSFRNTEVsZW1lbnQgPSBub2RlLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLm9wZW5BbmltYXRpb25Eb25lLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlLm5vZGVFeHBhbmRlZC5lbWl0KHsgb3duZXI6IHRoaXMudHJlZSwgbm9kZTogdGhpcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5jbG9zZUFuaW1hdGlvbkRvbmUucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyZWUubm9kZUNvbGxhcHNlZC5lbWl0KHsgb3duZXI6IHRoaXMudHJlZSwgbm9kZTogdGhpcyB9KTtcbiAgICAgICAgICAgIHRoaXMudHJlZVNlcnZpY2UuY29sbGFwc2UodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBTZXRzIHRoZSBmb2N1cyB0byB0aGUgbm9kZSdzIDxhPiBjaGlsZCwgaWYgcHJlc2VudFxuICAgICAqIFNldHMgdGhlIG5vZGUgYXMgdGhlIHRyZWUgc2VydmljZSdzIGZvY3VzZWROb2RlXG4gICAgICogTWFya3MgdGhlIG5vZGUgYXMgdGhlIGN1cnJlbnQgYWN0aXZlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgaGFuZGxlRm9jdXMoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmF2U2VydmljZS5mb2N1c2VkTm9kZSAhPT0gdGhpcykge1xuICAgICAgICAgICAgdGhpcy5uYXZTZXJ2aWNlLmZvY3VzZWROb2RlID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmxpbmtDaGlsZHJlbj8ubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtDaGlsZHJlbi5maXJzdC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZENoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlcmVkQ2hpbGRyZW5bMF0uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIENsZWFyIHRoZSBub2RlJ3MgZm9jdXNlZCBzdGF0dXNcbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJGb2N1cygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5pc0ZvY3VzZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvblNlbGVjdG9yUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvblNlbGVjdG9yQ2xpY2soZXZlbnQpIHtcbiAgICAgICAgLy8gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIHRoaXMubmF2U2VydmljZS5oYW5kbGVGb2N1c2VkQW5kQWN0aXZlTm9kZSh0aGlzKTtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0TXVsdGlwbGVOb2Rlcyh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uU2VydmljZS5kZXNlbGVjdE5vZGUodGhpcywgZXZlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdE5vZGUodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgbm9kZSBleHBhbnNpb24gc3RhdGUsIHRyaWdnZXJpbmcgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlPlxuICAgICAqICAgICAgPGlneC10cmVlLW5vZGUgI25vZGU+TXkgTm9kZTwvaWd4LXRyZWUtbm9kZT5cbiAgICAgKiA8L2lneC10cmVlPlxuICAgICAqIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGlneEJ1dHRvbiAoY2xpY2spPVwibm9kZS50b2dnbGUoKVwiPlRvZ2dsZSBOb2RlPC9idXR0b24+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlOb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBteU5vZGUudG9nZ2xlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgaW5kaWNhdG9yQ2xpY2soKSB7XG4gICAgICAgIGlmKCF0aGlzLnRyZWUudG9nZ2xlTm9kZU9uQ2xpY2spIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgICAgICB0aGlzLm5hdlNlcnZpY2Uuc2V0Rm9jdXNlZEFuZEFjdGl2ZU5vZGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgIC8vVG9nZ2xlIHRoZSBub2RlIG9ubHkgb24gbGVmdCBtb3VzZSBjbGljayAtIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby9wb2ludGVyZXZlbnRzLyNidXR0b24tc3RhdGVzXG4gICAgICAgIGlmKHRoaXMudHJlZS50b2dnbGVOb2RlT25DbGljayAmJiBldmVudC5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm5hdlNlcnZpY2Uuc2V0Rm9jdXNlZEFuZEFjdGl2ZU5vZGUodGhpcyk7XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIG5nT25EZXN0cm95KCkge1xuICAgICAgICBzdXBlci5uZ09uRGVzdHJveSgpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuZW5zdXJlU3RhdGVPbk5vZGVEZWxldGUodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwYW5kcyB0aGUgbm9kZSwgdHJpZ2dlcmluZyBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogICAgICA8aWd4LXRyZWUtbm9kZSAjbm9kZT5NeSBOb2RlPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWd4QnV0dG9uIChjbGljayk9XCJub2RlLmV4cGFuZCgpXCI+RXhwYW5kIE5vZGU8L2J1dHRvbj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBteU5vZGU6IElneFRyZWVOb2RlPGFueT4gPSB0aGlzLnRyZWUuZmluZE5vZGVzKGRhdGFbMF0pWzBdO1xuICAgICAqIG15Tm9kZS5leHBhbmQoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZXhwYW5kKCkge1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCAmJiAhdGhpcy50cmVlU2VydmljZS5jb2xsYXBzaW5nTm9kZXMuaGFzKHRoaXMpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXJnczogSVRyZWVOb2RlVG9nZ2xpbmdFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBvd25lcjogdGhpcy50cmVlLFxuICAgICAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgICAgIGNhbmNlbDogZmFsc2VcblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRyZWUubm9kZUV4cGFuZGluZy5lbWl0KGFyZ3MpO1xuICAgICAgICBpZiAoIWFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVTZXJ2aWNlLmV4cGFuZCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICAgIHRoaXMucGxheU9wZW5BbmltYXRpb24oXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkNvbnRhaW5lclxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbGxhcHNlcyB0aGUgbm9kZSwgdHJpZ2dlcmluZyBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWU+XG4gICAgICogICAgICA8aWd4LXRyZWUtbm9kZSAjbm9kZT5NeSBOb2RlPC9pZ3gtdHJlZS1ub2RlPlxuICAgICAqIDwvaWd4LXRyZWU+XG4gICAgICogPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWd4QnV0dG9uIChjbGljayk9XCJub2RlLmNvbGxhcHNlKClcIj5Db2xsYXBzZSBOb2RlPC9idXR0b24+XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgbXlOb2RlOiBJZ3hUcmVlTm9kZTxhbnk+ID0gdGhpcy50cmVlLmZpbmROb2RlcyhkYXRhWzBdKVswXTtcbiAgICAgKiBteU5vZGUuY29sbGFwc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sbGFwc2UoKSB7XG4gICAgICAgIGlmICghdGhpcy5leHBhbmRlZCB8fCB0aGlzLnRyZWVTZXJ2aWNlLmNvbGxhcHNpbmdOb2Rlcy5oYXModGhpcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzOiBJVHJlZU5vZGVUb2dnbGluZ0V2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLnRyZWUsXG4gICAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJlZS5ub2RlQ29sbGFwc2luZy5lbWl0KGFyZ3MpO1xuICAgICAgICBpZiAoIWFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLnRyZWVTZXJ2aWNlLmNvbGxhcHNpbmcodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnBsYXlDbG9zZUFuaW1hdGlvbihcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuQ29udGFpbmVyXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGFkZExpbmtDaGlsZChsaW5rOiBJZ3hUcmVlTm9kZUxpbmtEaXJlY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fdGFiSW5kZXggPSAtMTtcbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkQ2hpbGRyZW4ucHVzaChsaW5rKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgcmVtb3ZlTGlua0NoaWxkKGxpbms6IElneFRyZWVOb2RlTGlua0RpcmVjdGl2ZSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMucmVnaXN0ZXJlZENoaWxkcmVuLmluZGV4T2YobGluayk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJlZENoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCI8bmctdGVtcGxhdGUgI25vRHJhZ1RlbXBsYXRlPlxuICAgIDxuZy10ZW1wbGF0ZSAqbmdUZW1wbGF0ZU91dGxldD1cImhlYWRlclRlbXBsYXRlXCI+PC9uZy10ZW1wbGF0ZT5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gV2lsbCBzd2l0Y2ggdGVtcGxhdGVzIGRlcGVuZGluZyBvbiBkcmFnRHJvcCAtLT5cbjxuZy10ZW1wbGF0ZSAqbmdUZW1wbGF0ZU91dGxldD1cIm5vRHJhZ1RlbXBsYXRlXCI+XG48L25nLXRlbXBsYXRlPlxuXG48ZGl2ICNjaGlsZHJlbkNvbnRhaW5lclxuICAgICpuZ0lmPVwiZXhwYW5kZWQgJiYgIWxvYWRpbmdcIlxuICAgIGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fZ3JvdXBcIlxuICAgIHJvbGU9XCJncm91cFwiXG4+XG4gICAgPG5nLWNvbnRlbnQgc2VsZWN0PVwiaWd4LXRyZWUtbm9kZVwiPjwvbmctY29udGVudD5cbjwvZGl2PlxuXG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEluZGljYXRvcj5cbiAgICA8aWd4LWljb24gW2F0dHIuYXJpYS1sYWJlbF09XCJleHBhbmRlZCA/IHJlc291cmNlU3RyaW5ncy5pZ3hfY29sbGFwc2UgOiByZXNvdXJjZVN0cmluZ3MuaWd4X2V4cGFuZFwiPlxuICAgICAgICB7eyBleHBhbmRlZCA/IFwia2V5Ym9hcmRfYXJyb3dfZG93blwiIDogXCJrZXlib2FyZF9hcnJvd19yaWdodFwiIH19XG4gICAgPC9pZ3gtaWNvbj5cbjwvbmctdGVtcGxhdGU+XG5cbjwhLS0gc2VwYXJhdGVkIGluIGEgdGVtcGxhdGUgaW4gY2FzZSB0aGlzIGV2ZXIgbmVlZHMgdG8gYmUgdGVtcGxhdGFibGUgLS0+XG48bmctdGVtcGxhdGUgI3NlbGVjdE1hcmtlclRlbXBsYXRlPlxuICAgIDxpZ3gtY2hlY2tib3ggW2NoZWNrZWRdPVwic2VsZWN0ZWRcIiBbZGlzYWJsZWRdPVwiZGlzYWJsZWRcIiBbcmVhZG9ubHldPVwidHJ1ZVwiIFtpbmRldGVybWluYXRlXT1cImluZGV0ZXJtaW5hdGVcIiBbdGFiaW5kZXhdPVwiLTFcIj5cbiAgICA8L2lneC1jaGVja2JveD5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjaGVhZGVyVGVtcGxhdGU+XG4gICAgPGRpdiAjZ2hvc3RUZW1wbGF0ZSBjbGFzcz1cImlneC10cmVlLW5vZGVfX3dyYXBwZXJcIlxuICAgICAgICBbYXR0ci5yb2xlXT1cInJvbGVcIlxuICAgICAgICBbdGFiSW5kZXhdPVwidGFiSW5kZXhcIlxuICAgICAgICBbbmdDbGFzc109XCJ7XG4gICAgICAgICAgICAnaWd4LXRyZWUtbm9kZV9fd3JhcHBlci0tc2VsZWN0ZWQnOiBzZWxlY3RlZCxcbiAgICAgICAgICAgICdpZ3gtdHJlZS1ub2RlX193cmFwcGVyLS1hY3RpdmUnIDogdGhpcy5hY3RpdmUsXG4gICAgICAgICAgICAnaWd4LXRyZWUtbm9kZV9fd3JhcHBlci0tZm9jdXNlZCcgOiB0aGlzLmZvY3VzZWQsXG4gICAgICAgICAgICAnaWd4LXRyZWUtbm9kZV9fd3JhcHBlci0tZGlzYWJsZWQnIDogdGhpcy5kaXNhYmxlZFxuICAgICAgICB9XCJcbiAgICAgICAgKHBvaW50ZXJkb3duKT1cIm9uUG9pbnRlckRvd24oJGV2ZW50KVwiXG4gICAgICAgIChmb2N1cyk9XCJoYW5kbGVGb2N1cygpXCJcbiAgICAgICAgKGJsdXIpPVwiY2xlYXJGb2N1cygpXCJcbiAgICA+XG4gICAgICAgIDxkaXYgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICAgICAgICA8c3BhbiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBbXS5jb25zdHJ1Y3RvcihsZXZlbClcIlxuICAgICAgICAgICAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgICAgICAgICAgICAgY2xhc3M9XCJpZ3gtdHJlZS1ub2RlX19zcGFjZXJcIlxuICAgICAgICAgICAgPjwvc3Bhbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPCEtLSBFeHBhbmQvQ29sbGFwc2UgaW5kaWNhdG9yIC0tPlxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFsb2FkaW5nXCJcbiAgICAgICAgICAgIGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fdG9nZ2xlLWJ1dHRvblwiXG4gICAgICAgICAgICBbbmdDbGFzc109XCJ7ICdpZ3gtdHJlZS1ub2RlX190b2dnbGUtYnV0dG9uLS1oaWRkZW4nOiAhX2NoaWxkcmVuPy5sZW5ndGggfVwiXG4gICAgICAgICAgICAoY2xpY2spPVwiaW5kaWNhdG9yQ2xpY2soKVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJleHBhbmRJbmRpY2F0b3JUZW1wbGF0ZSwgY29udGV4dDogeyAkaW1wbGljaXQ6IGV4cGFuZGVkIH1cIj5cbiAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwibG9hZGluZ1wiXG4gICAgICAgICAgICBjbGFzcz1cImlneC10cmVlLW5vZGVfX3RvZ2dsZS1idXR0b25cIlxuICAgICAgICA+XG4gICAgICAgIFx0PGlneC1jaXJjdWxhci1iYXJcbiAgICAgICAgICAgIFx0W2FuaW1hdGVdPVwiZmFsc2VcIlxuICAgICAgICAgICAgXHRbaW5kZXRlcm1pbmF0ZV09XCJ0cnVlXCJcbiAgICAgICAgICAgIFx0W3RleHRWaXNpYmlsaXR5XT1cImZhbHNlXCJcbiAgICAgICAgXHQ+XG4gICAgICAgIFx0PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAgICA8L3NwYW4+XG5cbiAgICAgICAgPCEtLSBJdGVtIHNlbGVjdGlvbiAtLT5cbiAgICAgICAgPGRpdiAqbmdJZj1cInNob3dTZWxlY3RvcnNcIlxuICAgICAgICAgICAgY2xhc3M9XCJpZ3gtdHJlZS1ub2RlX19zZWxlY3RcIlxuICAgICAgICAgICAgKHBvaW50ZXJkb3duKT1cIm9uU2VsZWN0b3JQb2ludGVyRG93bigkZXZlbnQpXCJcbiAgICAgICAgICAgIChjbGljayk9XCJvblNlbGVjdG9yQ2xpY2soJGV2ZW50KVwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInNlbGVjdE1hcmtlclRlbXBsYXRlXCI+XG4gICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPGRpdiBjbGFzcz1cImlneC10cmVlLW5vZGVfX2NvbnRlbnRcIj5cbiAgICAgICAgICAgIDwhLS0gR2hvc3QgY29udGVudCAtLT5cbiAgICAgICAgICAgIDxuZy1jb250ZW50PjwvbmctY29udGVudD5cbiAgICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8IS0tICBCdWZmZXIgZWxlbWVudCBmb3IgJ21vdmUgYWZ0ZXInIHdoZW4gRCZEIGlzIGltcGxlbWVudGVkLS0+XG4gICAgPGRpdiBjbGFzcz1cImlneC10cmVlLW5vZGVfX2Ryb3AtaW5kaWNhdG9yXCI+XG4gICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwiaWd4LXRyZWUtbm9kZV9fc3BhY2VyXCIgKm5nRm9yPVwibGV0IGl0ZW0gb2YgW10uY29uc3RydWN0b3IobGV2ZWwpXCI+PC9zcGFuPlxuICAgICAgICA8IS0tIHN0eWxlIHJ1bGVzIHRhcmdldCB0aGlzIGRpdiwgZG8gbm90IGRlbGV0ZSBpdCAtLT5cbiAgICAgICAgPGRpdj48L2Rpdj5cbiAgICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZHJhZ1RlbXBsYXRlPlxuICAgIDwhLS0gRHJhZyBkcm9wIGdvZXMgaGVyZVxuICAgICAgICBpZ3hEcm9wXG4gICAgICAgICNkcm9wUmVmPVwiZHJvcFwiXG4gICAgICAgIFtpZ3hOb2RlRHJhZ109XCJ0aGlzXCJcbiAgICAgICAgKGRyYWdTdGFydCk9XCJsb2dEcm9wKGRyb3BSZWYpXCJcbiAgICAgICAgKGxlYXZlKT1cImVtaXRMZWF2ZSgpXCJcbiAgICAgICAgKGVudGVyKT1cImVtaXRFbnRlcigpXCIgLS0+XG4gICAgPGRpdiBjbGFzcz1cImlneC10cmVlLW5vZGVfX2RyYWctd3JhcHBlclwiPlxuICAgICAgICA8bmctdGVtcGxhdGUgKm5nVGVtcGxhdGVPdXRsZXQ9XCJoZWFkZXJUZW1wbGF0ZVwiPjwvbmctdGVtcGxhdGU+XG4gICAgPC9kaXY+XG48L25nLXRlbXBsYXRlPlxuIl19
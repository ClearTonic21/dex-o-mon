/* eslint-disable @angular-eslint/no-conflicting-lifecycle */
import { DOCUMENT } from '@angular/common';
import { Directive, EventEmitter, Input, Output, Inject, booleanAttribute } from '@angular/core';
import { DisplayContainerComponent } from './display.container';
import { HVirtualHelperComponent } from './horizontal.virtual.helper.component';
import { VirtualHelperComponent } from './virtual.helper.component';
import { IgxForOfScrollSyncService } from './for_of.sync.service';
import { Subject } from 'rxjs';
import { takeUntil, filter, throttleTime, first } from 'rxjs/operators';
import { getResizeObserver } from '../../core/utils';
import * as i0 from "@angular/core";
import * as i1 from "./for_of.sync.service";
import * as i2 from "../../core/utils";
const MAX_PERF_SCROLL_DIFF = 4;
/**
 *  @publicApi
 */
export class IgxForOfContext {
    constructor($implicit, igxForOf, index, count) {
        this.$implicit = $implicit;
        this.igxForOf = igxForOf;
        this.index = index;
        this.count = count;
    }
    /**
     * A function that returns whether the element is the first or not
     */
    get first() {
        return this.index === 0;
    }
    /**
     * A function that returns whether the element is the last or not
     */
    get last() {
        return this.index === this.count - 1;
    }
    /**
     * A function that returns whether the element is even or not
     */
    get even() {
        return this.index % 2 === 0;
    }
    /**
     * A function that returns whether the element is odd or not
     */
    get odd() {
        return !this.even;
    }
}
/** @hidden @internal */
export class IgxForOfToken {
}
export class IgxForOfDirective extends IgxForOfToken {
    /**
     * The total count of the virtual data items, when using remote service.
     * Similar to the property totalItemCount, but this will allow setting the data count into the template.
     * ```html
     * <ng-template igxFor let-item [igxForOf]="data | async" [igxForTotalItemCount]="count | async"
     *  [igxForContainerSize]="'500px'" [igxForItemSize]="'50px'"></ng-template>
     * ```
     */
    get igxForTotalItemCount() {
        return this.totalItemCount;
    }
    set igxForTotalItemCount(value) {
        this.totalItemCount = value;
    }
    /**
     * The total count of the virtual data items, when using remote service.
     * ```typescript
     * this.parentVirtDir.totalItemCount = data.Count;
     * ```
     */
    get totalItemCount() {
        return this._totalItemCount;
    }
    set totalItemCount(val) {
        if (this._totalItemCount !== val) {
            this._totalItemCount = val;
            // update sizes in case total count changes.
            const newSize = this.initSizesCache(this.igxForOf);
            const sizeDiff = this.scrollComponent.size - newSize;
            this.scrollComponent.size = newSize;
            const lastChunkExceeded = this.state.startIndex + this.state.chunkSize > val;
            if (lastChunkExceeded) {
                this.state.startIndex = val - this.state.chunkSize;
            }
            this._adjustScrollPositionAfterSizeChange(sizeDiff);
        }
    }
    get displayContainer() {
        return this.dc?.instance?._viewContainer?.element?.nativeElement;
    }
    get virtualHelper() {
        return this.scrollComponent.nativeElement;
    }
    /**
     * @hidden
     */
    get isRemote() {
        return this.totalItemCount !== null;
    }
    /**
     *
     * Gets/Sets the scroll position.
     * ```typescript
     * const position = directive.scrollPosition;
     * directive.scrollPosition = value;
     * ```
     */
    get scrollPosition() {
        return this.scrollComponent.scrollAmount;
    }
    set scrollPosition(val) {
        if (val === this.scrollComponent.scrollAmount) {
            return;
        }
        if (this.igxForScrollOrientation === 'horizontal' && this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollLeft = this.isRTL ? -val : val;
        }
        else if (this.scrollComponent) {
            this.scrollComponent.nativeElement.scrollTop = val;
        }
    }
    /**
     * @hidden
     */
    get isRTL() {
        const dir = window.getComputedStyle(this.dc.instance._viewContainer.element.nativeElement).getPropertyValue('direction');
        return dir === 'rtl';
    }
    get sizesCache() {
        return this._sizesCache;
    }
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get _isScrolledToBottom() {
        if (!this.getScroll()) {
            return true;
        }
        const scrollHeight = this.getScroll().scrollHeight;
        // Use === and not >= because `scrollTop + container size` can't be bigger than `scrollHeight`, unless something isn't updated.
        // Also use Math.round because Chrome has some inconsistencies and `scrollTop + container` can be float when zooming the page.
        return Math.round(this.getScroll().scrollTop + this.igxForContainerSize) === scrollHeight;
    }
    get _isAtBottomIndex() {
        return this.igxForOf && this.state.startIndex + this.state.chunkSize > this.igxForOf.length;
    }
    constructor(_viewContainer, _template, _differs, cdr, _zone, syncScrollService, platformUtil, document) {
        super();
        this._viewContainer = _viewContainer;
        this._template = _template;
        this._differs = _differs;
        this.cdr = cdr;
        this._zone = _zone;
        this.syncScrollService = syncScrollService;
        this.platformUtil = platformUtil;
        this.document = document;
        /**
         * Specifies the scroll orientation.
         * Scroll orientation can be "vertical" or "horizontal".
         * ```html
         * <ng-template igxFor let-item [igxForOf]="data" [igxForScrollOrientation]="'horizontal'"></ng-template>
         * ```
         */
        this.igxForScrollOrientation = 'vertical';
        /**
         * An event that is emitted after a new chunk has been loaded.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (chunkLoad)="loadChunk($event)"></ng-template>
         * ```
         * ```typescript
         * loadChunk(e){
         * alert("chunk loaded!");
         * }
         * ```
         */
        this.chunkLoad = new EventEmitter();
        /**
         * @hidden @internal
         * An event that is emitted when scrollbar visibility has changed.
         */
        this.scrollbarVisibilityChanged = new EventEmitter();
        /**
         * An event that is emitted after the rendered content size of the igxForOf has been changed.
         */
        this.contentSizeChange = new EventEmitter();
        /**
         * An event that is emitted after data has been changed.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (dataChanged)="dataChanged($event)"></ng-template>
         * ```
         * ```typescript
         * dataChanged(e){
         * alert("data changed!");
         * }
         * ```
         */
        this.dataChanged = new EventEmitter();
        this.beforeViewDestroyed = new EventEmitter();
        /**
         * An event that is emitted on chunk loading to emit the current state information - startIndex, endIndex, totalCount.
         * Can be used for implementing remote load on demand for the igxFor data.
         * ```html
         * <ng-template igxFor [igxForOf]="data" [igxForScrollOrientation]="'horizontal'" (chunkPreload)="chunkPreload($event)"></ng-template>
         * ```
         * ```typescript
         * chunkPreload(e){
         * alert("chunk is loading!");
         * }
         * ```
         */
        this.chunkPreload = new EventEmitter();
        /**
         * The current state of the directive. It contains `startIndex` and `chunkSize`.
         * state.startIndex - The index of the item at which the current visible chunk begins.
         * state.chunkSize - The number of items the current visible chunk holds.
         * These options can be used when implementing remote virtualization as they provide the necessary state information.
         * ```typescript
         * const gridState = this.parentVirtDir.state;
         * ```
         */
        this.state = {
            startIndex: 0,
            chunkSize: 0
        };
        this._sizesCache = [];
        this._differ = null;
        this.individualSizeCache = [];
        /** Internal track for scroll top that is being virtualized */
        this._virtScrollPosition = 0;
        /** If the next onScroll event is triggered due to internal setting of scrollTop */
        this._bScrollInternal = false;
        // End properties related to virtual height handling
        this._embeddedViews = [];
        this.contentResizeNotify = new Subject();
        /** Size that is being virtualized. */
        this._virtSize = 0;
        /**
         * @hidden
         */
        this.destroy$ = new Subject();
        this._totalItemCount = null;
        /**
         * Ratio for height that's being virtualizaed and the one visible
         * If _virtHeightRatio = 1, the visible height and the virtualized are the same, also _maxSize > _virtHeight.
         */
        this._virtRatio = 1;
    }
    verticalScrollHandler(event) {
        this.onScroll(event);
    }
    isScrollable() {
        return this.scrollComponent.size > parseInt(this.igxForContainerSize, 10);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const vc = this.igxForScrollContainer ? this.igxForScrollContainer._viewContainer : this._viewContainer;
        this.igxForSizePropName = this.igxForSizePropName || 'width';
        this.dc = this._viewContainer.createComponent(DisplayContainerComponent, { index: 0 });
        this.dc.instance.scrollDirection = this.igxForScrollOrientation;
        if (this.igxForOf && this.igxForOf.length) {
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            this.state.chunkSize = this._calculateChunkSize();
            this.dc.instance.notVirtual = !(this.igxForContainerSize && this.state.chunkSize < this.igxForOf.length);
            if (this.scrollComponent && !this.scrollComponent.destroyed) {
                this.state.startIndex = Math.min(this.getIndexAt(this.scrollPosition, this.sizesCache), this.igxForOf.length - this.state.chunkSize);
            }
            for (let i = this.state.startIndex; i < this.state.startIndex + this.state.chunkSize &&
                this.igxForOf[i] !== undefined; i++) {
                const input = this.igxForOf[i];
                const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.igxForOf, this.getContextIndex(input), this.igxForOf.length));
                this._embeddedViews.push(embeddedView);
            }
        }
        this._maxSize = this._calcMaxBrowserSize();
        if (this.igxForScrollOrientation === 'vertical') {
            this.dc.instance._viewContainer.element.nativeElement.style.top = '0px';
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent || this.scrollComponent.destroyed) {
                this.scrollComponent = vc.createComponent(VirtualHelperComponent).instance;
            }
            this.scrollComponent.size = this.igxForOf ? this._calcSize() : 0;
            this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
            this._zone.runOutsideAngular(() => {
                this.verticalScrollHandler = this.verticalScrollHandler.bind(this);
                this.scrollComponent.nativeElement.addEventListener('scroll', this.verticalScrollHandler);
                this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
            });
            const destructor = takeUntil(this.destroy$);
            this.contentResizeNotify.pipe(filter(() => this.igxForContainerSize && this.igxForOf && this.igxForOf.length > 0), throttleTime(40, undefined, { leading: false, trailing: true }), destructor).subscribe(() => this._zone.runTask(() => this.updateSizes()));
        }
        if (this.igxForScrollOrientation === 'horizontal') {
            this.func = (evt) => this.onHScroll(evt);
            this.scrollComponent = this.syncScrollService.getScrollMaster(this.igxForScrollOrientation);
            if (!this.scrollComponent) {
                this.scrollComponent = vc.createComponent(HVirtualHelperComponent).instance;
                this.scrollComponent.size = this.igxForOf ? this._calcSize() : 0;
                this.syncScrollService.setScrollMaster(this.igxForScrollOrientation, this.scrollComponent);
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            else {
                this._zone.runOutsideAngular(() => {
                    this.scrollComponent.nativeElement.addEventListener('scroll', this.func);
                    this.dc.instance.scrollContainer = this.scrollComponent.nativeElement;
                });
            }
            this._updateScrollOffset();
        }
    }
    ngAfterViewInit() {
        if (this.igxForScrollOrientation === 'vertical') {
            this._zone.runOutsideAngular(() => {
                this.contentObserver = new (getResizeObserver())(() => this.contentResizeNotify.next());
                this.contentObserver.observe(this.dc.instance._viewContainer.element.nativeElement);
            });
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        this.removeScrollEventListeners();
        this.destroy$.next(true);
        this.destroy$.complete();
        if (this.contentObserver) {
            this.contentObserver.disconnect();
        }
    }
    /**
     * @hidden @internal
     * Asserts the correct type of the context for the template that `igxForOf` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `IgxForOf` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        const forOf = 'igxForOf';
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
            this._applyChanges();
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            const prevSize = parseInt(changes[containerSize].previousValue, 10);
            const newSize = parseInt(changes[containerSize].currentValue, 10);
            this._recalcOnContainerChange({ prevSize, newSize });
        }
    }
    /**
     * @hidden
     */
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                this._updateSizeCache();
                this._zone.run(() => {
                    this._applyChanges();
                    this.cdr.markForCheck();
                    this._updateScrollOffset();
                    const args = {
                        containerSize: this.igxForContainerSize,
                        state: this.state
                    };
                    this.dataChanged.emit(args);
                });
            }
        }
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScroll(5);
     * ```
     *
     * @param addTop negative value to scroll up and positive to scroll down;
     */
    addScrollTop(add) {
        return this.addScroll(add);
    }
    /**
     * Shifts the scroll thumb position.
     * ```typescript
     * this.parentVirtDir.addScroll(5);
     * ```
     *
     * @param add negative value to scroll previous and positive to scroll next;
     */
    addScroll(add) {
        if (add === 0) {
            return false;
        }
        const originalVirtScrollTop = this._virtScrollPosition;
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxVirtScrollTop = this._virtSize - containerSize;
        this._bScrollInternal = true;
        this._virtScrollPosition += add;
        this._virtScrollPosition = this._virtScrollPosition > 0 ?
            (this._virtScrollPosition < maxVirtScrollTop ? this._virtScrollPosition : maxVirtScrollTop) :
            0;
        this.scrollPosition += add / this._virtRatio;
        if (Math.abs(add / this._virtRatio) < 1) {
            // Actual scroll delta that was added is smaller than 1 and onScroll handler doesn't trigger when scrolling < 1px
            const scrollOffset = this.fixedUpdateAllElements(this._virtScrollPosition);
            // scrollOffset = scrollOffset !== parseInt(this.igxForItemSize, 10) ? scrollOffset : 0;
            this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        }
        const maxRealScrollTop = this.scrollComponent.nativeElement.scrollHeight - containerSize;
        if ((this._virtScrollPosition > 0 && this.scrollPosition === 0) ||
            (this._virtScrollPosition < maxVirtScrollTop && this.scrollPosition === maxRealScrollTop)) {
            // Actual scroll position is at the top or bottom, but virtual one is not at the top or bottom (there's more to scroll)
            // Recalculate actual scroll position based on the virtual scroll.
            this.scrollPosition = this._virtScrollPosition / this._virtRatio;
        }
        else if (this._virtScrollPosition === 0 && this.scrollPosition > 0) {
            // Actual scroll position is not at the top, but virtual scroll is. Just update the actual scroll
            this.scrollPosition = 0;
        }
        else if (this._virtScrollPosition === maxVirtScrollTop && this.scrollPosition < maxRealScrollTop) {
            // Actual scroll position is not at the bottom, but virtual scroll is. Just update the acual scroll
            this.scrollPosition = maxRealScrollTop;
        }
        return this._virtScrollPosition !== originalVirtScrollTop;
    }
    /**
     * Scrolls to the specified index.
     * ```typescript
     * this.parentVirtDir.scrollTo(5);
     * ```
     *
     * @param index
     */
    scrollTo(index) {
        if (index < 0 || index > (this.isRemote ? this.totalItemCount : this.igxForOf.length) - 1) {
            return;
        }
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const isPrevItem = index < this.state.startIndex || this.scrollPosition > this.sizesCache[index];
        let nextScroll = isPrevItem ? this.sizesCache[index] : this.sizesCache[index + 1] - containerSize;
        if (nextScroll < 0) {
            return;
        }
        const maxVirtScrollTop = this._virtSize - containerSize;
        if (nextScroll > maxVirtScrollTop) {
            nextScroll = maxVirtScrollTop;
        }
        this._bScrollInternal = true;
        this._virtScrollPosition = nextScroll;
        this.scrollPosition = this._virtScrollPosition / this._virtRatio;
        this._adjustToIndex = !isPrevItem ? index : null;
    }
    /**
     * Scrolls by one item into the appropriate next direction.
     * For "horizontal" orientation that will be the right column and for "vertical" that is the lower row.
     * ```typescript
     * this.parentVirtDir.scrollNext();
     * ```
     */
    scrollNext() {
        const scr = Math.abs(Math.ceil(this.scrollPosition));
        const endIndex = this.getIndexAt(scr + parseInt(this.igxForContainerSize, 10), this.sizesCache);
        this.scrollTo(endIndex);
    }
    /**
     * Scrolls by one item into the appropriate previous direction.
     * For "horizontal" orientation that will be the left column and for "vertical" that is the upper row.
     * ```typescript
     * this.parentVirtDir.scrollPrev();
     * ```
     */
    scrollPrev() {
        this.scrollTo(this.state.startIndex - 1);
    }
    /**
     * Scrolls by one page into the appropriate next direction.
     * For "horizontal" orientation that will be one view to the right and for "vertical" that is one view to the bottom.
     * ```typescript
     * this.parentVirtDir.scrollNextPage();
     * ```
     */
    scrollNextPage() {
        this.addScroll(parseInt(this.igxForContainerSize, 10));
    }
    /**
     * Scrolls by one page into the appropriate previous direction.
     * For "horizontal" orientation that will be one view to the left and for "vertical" that is one view to the top.
     * ```typescript
     * this.parentVirtDir.scrollPrevPage();
     * ```
     */
    scrollPrevPage() {
        const containerSize = (parseInt(this.igxForContainerSize, 10));
        this.addScroll(-containerSize);
    }
    /**
     * @hidden
     */
    getColumnScrollLeft(colIndex) {
        return this.sizesCache[colIndex];
    }
    /**
     * Returns the total number of items that are fully visible.
     * ```typescript
     * this.parentVirtDir.getItemCountInView();
     * ```
     */
    getItemCountInView() {
        let startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
        if (this.scrollPosition - this.sizesCache[startIndex] > 0) {
            // fisrt item is not fully in view
            startIndex++;
        }
        const endIndex = this.getIndexAt(this.scrollPosition + parseInt(this.igxForContainerSize, 10), this.sizesCache);
        return endIndex - startIndex;
    }
    /**
     * Returns a reference to the scrollbar DOM element.
     * This is either a vertical or horizontal scrollbar depending on the specified igxForScrollOrientation.
     * ```typescript
     * dir.getScroll();
     * ```
     */
    getScroll() {
        return this.scrollComponent?.nativeElement;
    }
    /**
     * Returns the size of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getSizeAt(1);
     * ```
     */
    getSizeAt(index) {
        return this.sizesCache[index + 1] - this.sizesCache[index];
    }
    /**
     * @hidden
     * Function that is called to get the native scrollbar size that the browsers renders.
     */
    getScrollNativeSize() {
        return this.scrollComponent ? this.scrollComponent.scrollNativeSize : 0;
    }
    /**
     * Returns the scroll offset of the element at the specified index.
     * ```typescript
     * this.parentVirtDir.getScrollForIndex(1);
     * ```
     */
    getScrollForIndex(index, bottom) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const scroll = bottom ? Math.max(0, this.sizesCache[index + 1] - containerSize) : this.sizesCache[index];
        return scroll;
    }
    /**
     * Returns the index of the element at the specified offset.
     * ```typescript
     * this.parentVirtDir.getIndexAtScroll(100);
     * ```
     */
    getIndexAtScroll(scrollOffset) {
        return this.getIndexAt(scrollOffset, this.sizesCache);
    }
    /**
     * Returns whether the target index is outside the view.
     * ```typescript
     * this.parentVirtDir.isIndexOutsideView(10);
     * ```
     */
    isIndexOutsideView(index) {
        const targetNode = index >= this.state.startIndex && index <= this.state.startIndex + this.state.chunkSize ?
            this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling)[index - this.state.startIndex] : null;
        const rowHeight = this.getSizeAt(index);
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const containerOffset = -(this.scrollPosition - this.sizesCache[this.state.startIndex]);
        const endTopOffset = targetNode ? targetNode.offsetTop + rowHeight + containerOffset : containerSize + rowHeight;
        return !targetNode || targetNode.offsetTop < Math.abs(containerOffset)
            || containerSize && endTopOffset - containerSize > 5;
    }
    /**
     * @hidden
     * Function that recalculates and updates cache sizes.
     */
    recalcUpdateSizes() {
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const diffs = [];
        let totalDiff = 0;
        const l = this._embeddedViews.length;
        const rNodes = this._embeddedViews.map(view => view.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE) || view.rootNodes[0].nextElementSibling);
        for (let i = 0; i < l; i++) {
            const rNode = rNodes[i];
            if (rNode) {
                const height = window.getComputedStyle(rNode).getPropertyValue('height');
                const h = parseFloat(height) || parseInt(this.igxForItemSize, 10);
                const index = this.state.startIndex + i;
                if (!this.isRemote && !this.igxForOf[index]) {
                    continue;
                }
                const margin = this.getMargin(rNode, dimension);
                const oldVal = this.individualSizeCache[index];
                const newVal = (dimension === 'height' ? h : rNode.clientWidth) + margin;
                this.individualSizeCache[index] = newVal;
                const currDiff = newVal - oldVal;
                diffs.push(currDiff);
                totalDiff += currDiff;
                this.sizesCache[index + 1] += totalDiff;
            }
        }
        // update cache
        if (Math.abs(totalDiff) > 0) {
            for (let j = this.state.startIndex + this.state.chunkSize + 1; j < this.sizesCache.length; j++) {
                this.sizesCache[j] += totalDiff;
            }
            // update scrBar heights/widths
            const reducer = (acc, val) => acc + val;
            const hSum = this.individualSizeCache.reduce(reducer);
            if (hSum > this._maxSize) {
                this._virtRatio = hSum / this._maxSize;
            }
            this.scrollComponent.size = Math.min(this.scrollComponent.size + totalDiff, this._maxSize);
            this._virtSize = hSum;
            if (!this.scrollComponent.destroyed) {
                this.scrollComponent.cdr.detectChanges();
            }
            const scrToBottom = this._isScrolledToBottom && !this.dc.instance.notVirtual;
            if (scrToBottom && !this._isAtBottomIndex) {
                const containerSize = parseInt(this.igxForContainerSize, 10);
                const maxVirtScrollTop = this._virtSize - containerSize;
                this._bScrollInternal = true;
                this._virtScrollPosition = maxVirtScrollTop;
                this.scrollPosition = maxVirtScrollTop;
                return;
            }
            if (this._adjustToIndex) {
                // in case scrolled to specific index where after scroll heights are changed
                // need to adjust the offsets so that item is last in view.
                const updatesToIndex = this._adjustToIndex - this.state.startIndex + 1;
                const sumDiffs = diffs.slice(0, updatesToIndex).reduce(reducer);
                if (sumDiffs !== 0) {
                    this.addScroll(sumDiffs);
                }
                this._adjustToIndex = null;
            }
        }
    }
    /**
     * @hidden
     * Reset scroll position.
     * Needed in case scrollbar is hidden/detached but we still need to reset it.
     */
    resetScrollPosition() {
        this.scrollPosition = 0;
        this.scrollComponent.scrollAmount = 0;
    }
    /**
     * @hidden
     */
    removeScrollEventListeners() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this._zone.runOutsideAngular(() => this.scrollComponent?.nativeElement?.removeEventListener('scroll', this.func));
        }
        else {
            this._zone.runOutsideAngular(() => this.scrollComponent?.nativeElement?.removeEventListener('scroll', this.verticalScrollHandler));
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling vertically
     */
    onScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollPosition(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollPosition);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first()).subscribe(this.recalcUpdateSizes.bind(this));
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.chunkLoad.emit(this.state);
        }
    }
    /**
     * @hidden
     * @internal
     */
    updateScroll() {
        if (this.igxForScrollOrientation === "horizontal") {
            const scrollAmount = this.scrollComponent.nativeElement["scrollLeft"];
            this.scrollComponent.scrollAmount = scrollAmount;
            this._updateScrollOffset();
        }
    }
    updateSizes() {
        if (!this.scrollComponent.nativeElement.isConnected)
            return;
        const scrollable = this.isScrollable();
        this.recalcUpdateSizes();
        this._applyChanges();
        this._updateScrollOffset();
        if (scrollable !== this.isScrollable()) {
            this.scrollbarVisibilityChanged.emit();
        }
        else {
            this.contentSizeChange.emit();
        }
    }
    /**
     * @hidden
     */
    fixedUpdateAllElements(inScrollTop) {
        const count = this.isRemote ? this.totalItemCount : this.igxForOf.length;
        let newStart = this.getIndexAt(inScrollTop, this.sizesCache);
        if (newStart + this.state.chunkSize > count) {
            newStart = count - this.state.chunkSize;
        }
        const prevStart = this.state.startIndex;
        const diff = newStart - this.state.startIndex;
        this.state.startIndex = newStart;
        if (diff) {
            this.chunkPreload.emit(this.state);
            if (!this.isRemote) {
                // recalculate and apply page size.
                if (diff && Math.abs(diff) <= MAX_PERF_SCROLL_DIFF) {
                    if (diff > 0) {
                        this.moveApplyScrollNext(prevStart);
                    }
                    else {
                        this.moveApplyScrollPrev(prevStart);
                    }
                }
                else {
                    this.fixedApplyScroll();
                }
            }
        }
        return inScrollTop - this.sizesCache[this.state.startIndex];
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling down/right employing context change with view rearrangement
     */
    moveApplyScrollNext(prevIndex) {
        const start = prevIndex + this.state.chunkSize;
        const end = start + this.state.startIndex - prevIndex;
        const container = this.dc.instance._vcr;
        for (let i = start; i < end && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews.shift();
            if (!embView.destroyed) {
                this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                    || embView.rootNodes[0].nextElementSibling);
                const view = container.detach(0);
                this.updateTemplateContext(embView.context, i);
                container.insert(view);
                this._embeddedViews.push(embView);
            }
        }
    }
    /**
     * @hidden
     * The function applies an optimized state change for scrolling up/left employing context change with view rearrangement
     */
    moveApplyScrollPrev(prevIndex) {
        const container = this.dc.instance._vcr;
        for (let i = prevIndex - 1; i >= this.state.startIndex && this.igxForOf[i] !== undefined; i--) {
            const embView = this._embeddedViews.pop();
            if (!embView.destroyed) {
                this.scrollFocus(embView.rootNodes.find(node => node.nodeType === Node.ELEMENT_NODE)
                    || embView.rootNodes[0].nextElementSibling);
                const view = container.detach(container.length - 1);
                this.updateTemplateContext(embView.context, i);
                container.insert(view, 0);
                this._embeddedViews.unshift(embView);
            }
        }
    }
    /**
     * @hidden
     */
    getContextIndex(input) {
        return this.isRemote ? this.state.startIndex + this.igxForOf.indexOf(input) : this.igxForOf.indexOf(input);
    }
    /**
     * @hidden
     * Function which updates the passed context of an embedded view with the provided index
     * from the view container.
     * Often, called while handling a scroll event.
     */
    updateTemplateContext(context, index = 0) {
        context.$implicit = this.igxForOf[index];
        context.index = this.getContextIndex(this.igxForOf[index]);
        context.count = this.igxForOf.length;
    }
    /**
     * @hidden
     * The function applies an optimized state change through context change for each view
     */
    fixedApplyScroll() {
        let j = 0;
        const endIndex = this.state.startIndex + this.state.chunkSize;
        for (let i = this.state.startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
            const embView = this._embeddedViews[j++];
            this.updateTemplateContext(embView.context, i);
        }
    }
    /**
     * @hidden
     * @internal
     *
     * Clears focus inside the virtualized container on small scroll swaps.
     */
    scrollFocus(node) {
        if (!node) {
            return;
        }
        const document = node.getRootNode();
        const activeElement = document.activeElement;
        // Remove focus in case the the active element is inside the view container.
        // Otherwise we hit an exception while doing the 'small' scrolls swapping.
        // For more information:
        //
        // https://developer.mozilla.org/en-US/docs/Web/API/Node/removeChild
        // https://bugs.chromium.org/p/chromium/issues/detail?id=432392
        if (node && node.contains(activeElement)) {
            activeElement.blur();
        }
    }
    /**
     * @hidden
     * Function that is called when scrolling horizontally
     */
    onHScroll(event) {
        /* in certain situations this may be called when no scrollbar is visible */
        const firstScrollChild = this.scrollComponent.nativeElement.children.item(0);
        if (!parseInt(firstScrollChild.style.width, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollPosition(event.target.scrollLeft);
        }
        else {
            this._bScrollInternal = false;
        }
        const prevStartIndex = this.state.startIndex;
        const scrLeft = event.target.scrollLeft;
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(Math.abs(this._virtScrollPosition));
        if (scrLeft < 0) {
            // RTL
            this.dc.instance._viewContainer.element.nativeElement.style.left = scrollOffset + 'px';
        }
        else {
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
        this._zone.onStable.pipe(first()).subscribe(this.recalcUpdateSizes.bind(this));
        this.dc.changeDetectorRef.detectChanges();
        if (prevStartIndex !== this.state.startIndex) {
            this.chunkLoad.emit(this.state);
        }
    }
    /**
     * Gets the function used to track changes in the items collection.
     * By default the object references are compared. However this can be optimized if you have unique identifier
     * value that can be used for the comparison instead of the object ref or if you have some other property values
     * in the item object that should be tracked for changes.
     * This option is similar to ngForTrackBy.
     * ```typescript
     * const trackFunc = this.parentVirtDir.igxForTrackBy;
     * ```
     */
    get igxForTrackBy() {
        return this._trackByFn;
    }
    /**
     * Sets the function used to track changes in the items collection.
     * This function can be set in scenarios where you want to optimize or
     * customize the tracking of changes for the items in the collection.
     * The igxForTrackBy function takes the index and the current item as arguments and needs to return the unique identifier for this item.
     * ```typescript
     * this.parentVirtDir.igxForTrackBy = (index, item) => {
     *      return item.id + item.width;
     * };
     * ```
     */
    set igxForTrackBy(fn) {
        this._trackByFn = fn;
    }
    /**
     * @hidden
     */
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex = this.state.startIndex;
            let endIndex = this.state.chunkSize + this.state.startIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.chunkLoad.emit(this.state);
            }
        }
    }
    /**
     * @hidden
     */
    _calcMaxBrowserSize() {
        if (!this.platformUtil.isBrowser) {
            return 0;
        }
        const div = this.document.createElement('div');
        const style = div.style;
        style.position = 'absolute';
        const dir = this.igxForScrollOrientation === 'horizontal' ? 'left' : 'top';
        style[dir] = '9999999999999999px';
        this.document.body.appendChild(div);
        const size = Math.abs(div.getBoundingClientRect()[dir]);
        this.document.body.removeChild(div);
        return size;
    }
    /**
     * @hidden
     * Recalculates the chunkSize based on current startIndex and returns the new size.
     * This should be called after this.state.startIndex is updated, not before.
     */
    _calculateChunkSize() {
        let chunkSize = 0;
        if (this.igxForContainerSize !== null && this.igxForContainerSize !== undefined) {
            if (!this.sizesCache || this.sizesCache.length === 0) {
                this.initSizesCache(this.igxForOf);
            }
            chunkSize = this._calcMaxChunkSize();
            if (this.igxForOf && chunkSize > this.igxForOf.length) {
                chunkSize = this.igxForOf.length;
            }
        }
        else {
            if (this.igxForOf) {
                chunkSize = this.igxForOf.length;
            }
        }
        return chunkSize;
    }
    /**
     * @hidden
     */
    getElement(viewref, nodeName) {
        const elem = viewref.element.nativeElement.parentNode.getElementsByTagName(nodeName);
        return elem.length > 0 ? elem[0] : null;
    }
    /**
     * @hidden
     */
    initSizesCache(items) {
        let totalSize = 0;
        let size = 0;
        const dimension = this.igxForSizePropName || 'height';
        let i = 0;
        this.sizesCache = [];
        this.individualSizeCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this._getItemSize(items[i], dimension);
            this.individualSizeCache.push(size);
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            this.initSizesCache(this.igxForOf);
            return;
        }
        const oldHeight = this.individualSizeCache.length > 0 ? this.individualSizeCache.reduce((acc, val) => acc + val) : 0;
        const newHeight = this.initSizesCache(this.igxForOf);
        const diff = oldHeight - newHeight;
        this._adjustScrollPositionAfterSizeChange(diff);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        let i = 0;
        let length = 0;
        let maxLength = 0;
        const arr = [];
        let sum = 0;
        const availableSize = parseInt(this.igxForContainerSize, 10);
        if (!availableSize) {
            return 0;
        }
        const dimension = this.igxForScrollOrientation === 'horizontal' ?
            this.igxForSizePropName : 'height';
        const reducer = (accumulator, currentItem) => accumulator + this._getItemSize(currentItem, dimension);
        for (i; i < this.igxForOf.length; i++) {
            let item = this.igxForOf[i];
            if (dimension === 'height') {
                item = { value: this.igxForOf[i], height: this.individualSizeCache[i] };
            }
            const size = dimension === 'height' ?
                this.individualSizeCache[i] :
                this._getItemSize(item, dimension);
            sum = arr.reduce(reducer, size);
            if (sum < availableSize) {
                arr.push(item);
                length = arr.length;
                if (i === this.igxForOf.length - 1) {
                    // reached end without exceeding
                    // include prev items until size is filled or first item is reached.
                    let curItem = dimension === 'height' ? arr[0].value : arr[0];
                    let prevIndex = this.igxForOf.indexOf(curItem) - 1;
                    while (prevIndex >= 0 && sum <= availableSize) {
                        curItem = dimension === 'height' ? arr[0].value : arr[0];
                        prevIndex = this.igxForOf.indexOf(curItem) - 1;
                        const prevItem = this.igxForOf[prevIndex];
                        const prevSize = dimension === 'height' ?
                            this.individualSizeCache[prevIndex] :
                            parseInt(prevItem[dimension], 10);
                        sum = arr.reduce(reducer, prevSize);
                        arr.unshift(prevItem);
                        length = arr.length;
                    }
                }
            }
            else {
                arr.push(item);
                length = arr.length + 1;
                arr.shift();
            }
            if (length > maxLength) {
                maxLength = length;
            }
        }
        return maxLength;
    }
    /**
     * @hidden
     */
    getIndexAt(left, set) {
        let start = 0;
        let end = set.length - 1;
        if (left === 0) {
            return 0;
        }
        while (start <= end) {
            const midIdx = Math.floor((start + end) / 2);
            const midLeft = set[midIdx];
            const cmp = left - midLeft;
            if (cmp > 0) {
                start = midIdx + 1;
            }
            else if (cmp < 0) {
                end = midIdx - 1;
            }
            else {
                return midIdx;
            }
        }
        return end;
    }
    _recalcScrollBarSize(containerSizeInfo = null) {
        const count = this.isRemote ? this.totalItemCount : (this.igxForOf ? this.igxForOf.length : 0);
        this.dc.instance.notVirtual = !(this.igxForContainerSize && this.dc && this.state.chunkSize < count);
        const scrollable = containerSizeInfo ? this.scrollComponent.size > containerSizeInfo.prevSize : this.isScrollable();
        if (this.igxForScrollOrientation === 'horizontal') {
            const totalWidth = parseInt(this.igxForContainerSize, 10) > 0 ? this._calcSize() : 0;
            if (totalWidth <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
            this.scrollComponent.nativeElement.style.width = this.igxForContainerSize + 'px';
            this.scrollComponent.size = totalWidth;
        }
        if (this.igxForScrollOrientation === 'vertical') {
            const totalHeight = this._calcSize();
            if (totalHeight <= parseInt(this.igxForContainerSize, 10)) {
                this.resetScrollPosition();
            }
            this.scrollComponent.nativeElement.style.height = parseInt(this.igxForContainerSize, 10) + 'px';
            this.scrollComponent.size = totalHeight;
        }
        if (scrollable !== this.isScrollable()) {
            // scrollbar visibility has changed
            this.scrollbarVisibilityChanged.emit();
        }
    }
    _calcSize() {
        let size;
        if (this.individualSizeCache && this.individualSizeCache.length > 0) {
            size = this.individualSizeCache.reduce((acc, val) => acc + val, 0);
        }
        else {
            size = this.initSizesCache(this.igxForOf);
        }
        this._virtSize = size;
        if (size > this._maxSize) {
            this._virtRatio = size / this._maxSize;
            size = this._maxSize;
        }
        return size;
    }
    _recalcOnContainerChange(containerSizeInfo = null) {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize(containerSizeInfo);
        if (prevChunkSize !== this.state.chunkSize) {
            this.chunkLoad.emit(this.state);
        }
    }
    /**
     * @hidden
     * Removes an element from the embedded views and updates chunkSize.
     */
    removeLastElem() {
        const oldElem = this._embeddedViews.pop();
        this.beforeViewDestroyed.emit(oldElem);
        // also detach from ViewContainerRef to make absolutely sure this is removed from the view container.
        this.dc.instance._vcr.detach(this.dc.instance._vcr.length - 1);
        oldElem.destroy();
        this.state.chunkSize--;
    }
    /**
     * @hidden
     * If there exists an element that we can create embedded view for creates it, appends it and updates chunkSize
     */
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxForOfContext(input, this.igxForOf, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
        this._zone.run(() => this.cdr.markForCheck());
    }
    /**
     * Recalculates chunkSize and adds/removes elements if need due to the change.
     * this.state.chunkSize is updated in @addLastElem() or @removeLastElem()
     */
    applyChunkSizeChange() {
        const chunkSize = this.isRemote ? (this.igxForOf ? this.igxForOf.length : 0) : this._calculateChunkSize();
        if (chunkSize > this.state.chunkSize) {
            const diff = chunkSize - this.state.chunkSize;
            for (let i = 0; i < diff; i++) {
                this.addLastElem();
            }
        }
        else if (chunkSize < this.state.chunkSize) {
            const diff = this.state.chunkSize - chunkSize;
            for (let i = 0; i < diff; i++) {
                this.removeLastElem();
            }
        }
    }
    _calcVirtualScrollPosition(scrollPosition) {
        const containerSize = parseInt(this.igxForContainerSize, 10);
        const maxRealScrollPosition = this.scrollComponent.size - containerSize;
        const realPercentScrolled = maxRealScrollPosition !== 0 ? scrollPosition / maxRealScrollPosition : 0;
        const maxVirtScroll = this._virtSize - containerSize;
        this._virtScrollPosition = realPercentScrolled * maxVirtScroll;
    }
    _getItemSize(item, dimension) {
        const dim = item ? item[dimension] : null;
        return typeof dim === 'number' ? dim : parseInt(this.igxForItemSize, 10) || 0;
    }
    _updateScrollOffset() {
        let scrollOffset = 0;
        let currentScroll = this.scrollPosition;
        if (this._virtRatio !== 1) {
            this._calcVirtualScrollPosition(this.scrollPosition);
            currentScroll = this._virtScrollPosition;
        }
        const scroll = this.scrollComponent.nativeElement;
        scrollOffset = scroll && this.scrollComponent.size ?
            currentScroll - this.sizesCache[this.state.startIndex] : 0;
        const dir = this.igxForScrollOrientation === 'horizontal' ? 'left' : 'top';
        this.dc.instance._viewContainer.element.nativeElement.style[dir] = -(scrollOffset) + 'px';
    }
    _adjustScrollPositionAfterSizeChange(sizeDiff) {
        // if data has been changed while container is scrolled
        // should update scroll top/left according to change so that same startIndex is in view
        if (Math.abs(sizeDiff) > 0 && this.scrollPosition > 0) {
            this.recalcUpdateSizes();
            const offset = this.igxForScrollOrientation === 'horizontal' ?
                parseInt(this.dc.instance._viewContainer.element.nativeElement.style.left, 10) :
                parseInt(this.dc.instance._viewContainer.element.nativeElement.style.top, 10);
            const newSize = this.sizesCache[this.state.startIndex] - offset;
            this.scrollPosition = newSize;
            if (this.scrollPosition !== newSize) {
                this.scrollComponent.scrollAmount = newSize;
            }
        }
    }
    getMargin(node, dimension) {
        const styles = window.getComputedStyle(node);
        if (dimension === 'height') {
            return parseFloat(styles['marginTop']) +
                parseFloat(styles['marginBottom']) || 0;
        }
        return parseFloat(styles['marginLeft']) +
            parseFloat(styles['marginRight']) || 0;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxForOfDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i1.IgxForOfScrollSyncService }, { token: i2.PlatformUtil }, { token: DOCUMENT }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: IgxForOfDirective, isStandalone: true, selector: "[igxFor][igxForOf]", inputs: { igxForOf: "igxForOf", igxForSizePropName: "igxForSizePropName", igxForScrollOrientation: "igxForScrollOrientation", igxForScrollContainer: "igxForScrollContainer", igxForContainerSize: "igxForContainerSize", igxForItemSize: "igxForItemSize", igxForTotalItemCount: "igxForTotalItemCount", igxForTrackBy: "igxForTrackBy" }, outputs: { chunkLoad: "chunkLoad", scrollbarVisibilityChanged: "scrollbarVisibilityChanged", contentSizeChange: "contentSizeChange", dataChanged: "dataChanged", beforeViewDestroyed: "beforeViewDestroyed", chunkPreload: "chunkPreload" }, providers: [
            IgxForOfScrollSyncService,
            { provide: IgxForOfToken, useExisting: IgxForOfDirective }
        ], usesInheritance: true, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxForOfDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxFor][igxForOf]',
                    providers: [
                        IgxForOfScrollSyncService,
                        { provide: IgxForOfToken, useExisting: IgxForOfDirective }
                    ],
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i1.IgxForOfScrollSyncService }, { type: i2.PlatformUtil }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }], propDecorators: { igxForOf: [{
                type: Input
            }], igxForSizePropName: [{
                type: Input
            }], igxForScrollOrientation: [{
                type: Input
            }], igxForScrollContainer: [{
                type: Input
            }], igxForContainerSize: [{
                type: Input
            }], igxForItemSize: [{
                type: Input
            }], chunkLoad: [{
                type: Output
            }], scrollbarVisibilityChanged: [{
                type: Output
            }], contentSizeChange: [{
                type: Output
            }], dataChanged: [{
                type: Output
            }], beforeViewDestroyed: [{
                type: Output
            }], chunkPreload: [{
                type: Output
            }], igxForTotalItemCount: [{
                type: Input
            }], igxForTrackBy: [{
                type: Input
            }] } });
export const getTypeNameForDebugging = (type) => type.name || typeof type;
export class IgxGridForOfContext extends IgxForOfContext {
    constructor($implicit, igxGridForOf, index, count) {
        super($implicit, igxGridForOf, index, count);
        this.igxGridForOf = igxGridForOf;
    }
}
export class IgxGridForOfDirective extends IgxForOfDirective {
    set igxGridForOf(value) {
        this.igxForOf = value;
    }
    get igxGridForOf() {
        return this.igxForOf;
    }
    /**
     * @hidden
     * @internal
     */
    get sizesCache() {
        if (this.igxForScrollOrientation === 'horizontal') {
            if (this.igxGridForOfUniqueSizeCache || this.syncService.isMaster(this)) {
                return this._sizesCache;
            }
            return this.syncService.sizesCache(this.igxForScrollOrientation);
        }
        else {
            return this._sizesCache;
        }
    }
    /**
     * @hidden
     * @internal
     */
    set sizesCache(value) {
        this._sizesCache = value;
    }
    get itemsDimension() {
        return this.igxForSizePropName || 'height';
    }
    recalcUpdateSizes() {
        if (this.igxGridForOfVariableSizes && this.igxForScrollOrientation === 'vertical') {
            super.recalcUpdateSizes();
        }
    }
    constructor(_viewContainer, _template, _differs, cdr, _zone, _platformUtil, _document, syncScrollService, syncService) {
        super(_viewContainer, _template, _differs, cdr, _zone, syncScrollService, _platformUtil, _document);
        this.syncService = syncService;
        this.igxGridForOfUniqueSizeCache = false;
        this.igxGridForOfVariableSizes = true;
        /**
         * @hidden @internal
         * An event that is emitted after data has been changed but before the view is refreshed
         */
        this.dataChanging = new EventEmitter();
    }
    /**
     * @hidden @internal
     * Asserts the correct type of the context for the template that `IgxGridForOfDirective` will render.
     *
     * The presence of this method is a signal to the Ivy template type-check compiler that the
     * `IgxGridForOfDirective` structural directive renders its template with a specific context type.
     */
    static ngTemplateContextGuard(dir, ctx) {
        return true;
    }
    ngOnInit() {
        this.syncService.setMaster(this);
        super.ngOnInit();
        this.removeScrollEventListeners();
    }
    ngOnChanges(changes) {
        const forOf = 'igxGridForOf';
        this.syncService.setMaster(this);
        if (forOf in changes) {
            const value = changes[forOf].currentValue;
            if (!this._differ && value) {
                try {
                    this._differ = this._differs.find(value).create(this.igxForTrackBy);
                }
                catch (e) {
                    throw new Error(`Cannot find a differ supporting object "${value}" of type "${getTypeNameForDebugging(value)}".
                     NgFor only supports binding to Iterables such as Arrays.`);
                }
            }
            if (this.igxForScrollOrientation === 'horizontal') {
                // in case collection has changes, reset sync service
                this.syncService.setMaster(this, this.igxGridForOfUniqueSizeCache);
            }
        }
        const defaultItemSize = 'igxForItemSize';
        if (defaultItemSize in changes && !changes[defaultItemSize].firstChange &&
            this.igxForScrollOrientation === 'vertical' && this.igxForOf) {
            // handle default item size changed.
            this.initSizesCache(this.igxForOf);
        }
        const containerSize = 'igxForContainerSize';
        if (containerSize in changes && !changes[containerSize].firstChange && this.igxForOf) {
            const prevSize = parseInt(changes[containerSize].previousValue, 10);
            const newSize = parseInt(changes[containerSize].currentValue, 10);
            this._recalcOnContainerChange({ prevSize, newSize });
        }
    }
    /**
     * @hidden
     * @internal
     */
    assumeMaster() {
        this._sizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
        this.syncService.setMaster(this, true);
    }
    ngDoCheck() {
        if (this._differ) {
            const changes = this._differ.diff(this.igxForOf);
            if (changes) {
                const args = {
                    containerSize: this.igxForContainerSize,
                    state: this.state
                };
                this.dataChanging.emit(args);
                //  re-init cache.
                if (!this.igxForOf) {
                    this.igxForOf = [];
                }
                /* we need to reset the master dir if all rows are removed
                (e.g. because of filtering); if all columns are hidden, rows are
                still rendered empty, so we should not reset master */
                if (!this.igxForOf.length &&
                    this.igxForScrollOrientation === 'vertical') {
                    this.syncService.resetMaster();
                }
                this.syncService.setMaster(this);
                this.igxForContainerSize = args.containerSize;
                const sizeDiff = this._updateSizeCache(changes);
                this._applyChanges();
                if (sizeDiff) {
                    this._adjustScrollPositionAfterSizeChange(sizeDiff);
                }
                this._updateScrollOffset();
                this.dataChanged.emit(args);
            }
        }
    }
    onScroll(event) {
        if (!parseInt(this.scrollComponent.nativeElement.style.height, 10)) {
            return;
        }
        if (!this._bScrollInternal) {
            this._calcVirtualScrollPosition(event.target.scrollTop);
        }
        else {
            this._bScrollInternal = false;
        }
        const scrollOffset = this.fixedUpdateAllElements(this._virtScrollPosition);
        this.dc.instance._viewContainer.element.nativeElement.style.top = -(scrollOffset) + 'px';
        this._zone.onStable.pipe(first()).subscribe(this.recalcUpdateSizes.bind(this));
        this.cdr.markForCheck();
    }
    onHScroll(scrollAmount) {
        /* in certain situations this may be called when no scrollbar is visible */
        const firstScrollChild = this.scrollComponent.nativeElement.children.item(0);
        if (!this.scrollComponent || !parseInt(firstScrollChild.style.width, 10)) {
            return;
        }
        // Updating horizontal chunks
        const scrollOffset = this.fixedUpdateAllElements(Math.abs(scrollAmount));
        if (scrollAmount < 0) {
            // RTL
            this.dc.instance._viewContainer.element.nativeElement.style.left = scrollOffset + 'px';
        }
        else {
            // LTR
            this.dc.instance._viewContainer.element.nativeElement.style.left = -scrollOffset + 'px';
        }
    }
    getItemSize(item) {
        let size = 0;
        const dimension = this.igxForSizePropName || 'height';
        if (this.igxForScrollOrientation === 'vertical') {
            size = this._getItemSize(item, dimension);
            if (item && item.summaries) {
                size = item.max;
            }
            else if (item && item.groups && item.height) {
                size = item.height;
            }
        }
        else {
            size = parseInt(item[dimension], 10) || 0;
        }
        return size;
    }
    initSizesCache(items) {
        if (!this.syncService.isMaster(this) && this.igxForScrollOrientation === 'horizontal') {
            const masterSizesCache = this.syncService.sizesCache(this.igxForScrollOrientation);
            return masterSizesCache[masterSizesCache.length - 1];
        }
        let totalSize = 0;
        let size = 0;
        let i = 0;
        this.sizesCache = [];
        this.individualSizeCache = [];
        this.sizesCache.push(0);
        const count = this.isRemote ? this.totalItemCount : items.length;
        for (i; i < count; i++) {
            size = this.getItemSize(items[i]);
            this.individualSizeCache.push(size);
            totalSize += size;
            this.sizesCache.push(totalSize);
        }
        return totalSize;
    }
    _updateSizeCache(changes = null) {
        const oldSize = this.individualSizeCache.length > 0 ? this.individualSizeCache.reduce((acc, val) => acc + val) : 0;
        let newSize = oldSize;
        if (changes && !this.isRemote) {
            newSize = this.handleCacheChanges(changes);
        }
        else {
            return;
        }
        const diff = oldSize - newSize;
        return diff;
    }
    handleCacheChanges(changes) {
        const identityChanges = [];
        const newHeightCache = [];
        const newSizesCache = [];
        newSizesCache.push(0);
        let newHeight = 0;
        // When there are more than one removed items the changes are not reliable so those with identity change should be default size.
        let numRemovedItems = 0;
        changes.forEachRemovedItem(() => numRemovedItems++);
        // Get the identity changes to determine later if those that have changed their indexes should be assigned default item size.
        changes.forEachIdentityChange((item) => {
            if (item.currentIndex !== item.previousIndex) {
                // Filter out ones that have not changed their index.
                identityChanges[item.currentIndex] = item;
            }
        });
        // Processing each item that is passed to the igxForOf so far seem to be most reliable. We parse the updated list of items.
        changes.forEachItem((item) => {
            if (item.previousIndex !== null &&
                (numRemovedItems < 2 || !identityChanges.length || identityChanges[item.currentIndex])
                && this.igxForScrollOrientation !== "horizontal") {
                // Reuse cache on those who have previousIndex.
                // When there are more than one removed items currently the changes are not readable so ones with identity change
                // should be racalculated.
                newHeightCache[item.currentIndex] = this.individualSizeCache[item.previousIndex];
            }
            else {
                // Assign default item size.
                newHeightCache[item.currentIndex] = this.getItemSize(item.item);
            }
            newSizesCache[item.currentIndex + 1] = newSizesCache[item.currentIndex] + newHeightCache[item.currentIndex];
            newHeight += newHeightCache[item.currentIndex];
        });
        this.individualSizeCache = newHeightCache;
        this.sizesCache = newSizesCache;
        return newHeight;
    }
    addLastElem() {
        let elemIndex = this.state.startIndex + this.state.chunkSize;
        if (!this.isRemote && !this.igxForOf) {
            return;
        }
        if (elemIndex >= this.igxForOf.length) {
            elemIndex = this.igxForOf.length - this.state.chunkSize;
        }
        const input = this.igxForOf[elemIndex];
        const embeddedView = this.dc.instance._vcr.createEmbeddedView(this._template, new IgxGridForOfContext(input, this.igxForOf, this.getContextIndex(input), this.igxForOf.length));
        this._embeddedViews.push(embeddedView);
        this.state.chunkSize++;
    }
    _updateViews(prevChunkSize) {
        if (this.igxForOf && this.igxForOf.length && this.dc) {
            const embeddedViewCopy = Object.assign([], this._embeddedViews);
            let startIndex;
            let endIndex;
            if (this.isRemote) {
                startIndex = 0;
                endIndex = this.igxForOf.length;
            }
            else {
                startIndex = this.getIndexAt(this.scrollPosition, this.sizesCache);
                if (startIndex + this.state.chunkSize > this.igxForOf.length) {
                    startIndex = this.igxForOf.length - this.state.chunkSize;
                }
                this.state.startIndex = startIndex;
                endIndex = this.state.chunkSize + this.state.startIndex;
            }
            for (let i = startIndex; i < endIndex && this.igxForOf[i] !== undefined; i++) {
                const embView = embeddedViewCopy.shift();
                this.updateTemplateContext(embView.context, i);
            }
            if (prevChunkSize !== this.state.chunkSize) {
                this.chunkLoad.emit(this.state);
            }
        }
    }
    _applyChanges() {
        const prevChunkSize = this.state.chunkSize;
        this.applyChunkSizeChange();
        this._recalcScrollBarSize();
        this._updateViews(prevChunkSize);
    }
    /**
     * @hidden
     */
    _calcMaxChunkSize() {
        if (this.igxForScrollOrientation === 'horizontal') {
            if (this.syncService.isMaster(this)) {
                return super._calcMaxChunkSize();
            }
            return this.syncService.chunkSize(this.igxForScrollOrientation);
        }
        else {
            return super._calcMaxChunkSize();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxGridForOfDirective, deps: [{ token: i0.ViewContainerRef }, { token: i0.TemplateRef }, { token: i0.IterableDiffers }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }, { token: i2.PlatformUtil }, { token: DOCUMENT }, { token: i1.IgxForOfScrollSyncService }, { token: i1.IgxForOfSyncService }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "16.1.0", version: "18.0.1", type: IgxGridForOfDirective, isStandalone: true, selector: "[igxGridFor][igxGridForOf]", inputs: { igxGridForOf: "igxGridForOf", igxGridForOfUniqueSizeCache: ["igxGridForOfUniqueSizeCache", "igxGridForOfUniqueSizeCache", booleanAttribute], igxGridForOfVariableSizes: ["igxGridForOfVariableSizes", "igxGridForOfVariableSizes", booleanAttribute] }, outputs: { dataChanging: "dataChanging" }, usesInheritance: true, usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxGridForOfDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[igxGridFor][igxGridForOf]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ViewContainerRef }, { type: i0.TemplateRef }, { type: i0.IterableDiffers }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }, { type: i2.PlatformUtil }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i1.IgxForOfScrollSyncService }, { type: i1.IgxForOfSyncService }], propDecorators: { igxGridForOf: [{
                type: Input
            }], igxGridForOfUniqueSizeCache: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], igxGridForOfVariableSizes: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }], dataChanging: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9yX29mLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL2Zvci1vZi9mb3Jfb2YuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDZEQUE2RDtBQUM3RCxPQUFPLEVBQUUsUUFBUSxFQUFrQixNQUFNLGlCQUFpQixDQUFDO0FBQzNELE9BQU8sRUFHSCxTQUFTLEVBR1QsWUFBWSxFQUNaLEtBQUssRUFRTCxNQUFNLEVBTU4sTUFBTSxFQUNOLGdCQUFnQixFQUNuQixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUNoRSxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSx1Q0FBdUMsQ0FBQztBQUNoRixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQUVwRSxPQUFPLEVBQXVCLHlCQUF5QixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDdkYsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7Ozs7QUFJckQsTUFBTSxvQkFBb0IsR0FBRyxDQUFDLENBQUM7QUFFL0I7O0dBRUc7QUFDSCxNQUFNLE9BQU8sZUFBZTtJQUN4QixZQUNXLFNBQVksRUFDWixRQUFXLEVBQ1gsS0FBYSxFQUNiLEtBQWE7UUFIYixjQUFTLEdBQVQsU0FBUyxDQUFHO1FBQ1osYUFBUSxHQUFSLFFBQVEsQ0FBRztRQUNYLFVBQUssR0FBTCxLQUFLLENBQVE7UUFDYixVQUFLLEdBQUwsS0FBSyxDQUFRO0lBQ3BCLENBQUM7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QkFBZ0IsRUFBRTtnQkFJL0IseUJBQXlCO3NCQUQvQixLQUFLO3VCQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFO2dCQXdDL0IsWUFBWTtzQkFEbEIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIEBhbmd1bGFyLWVzbGludC9uby1jb25mbGljdGluZy1saWZlY3ljbGUgKi9cbmltcG9ydCB7IERPQ1VNRU5ULCBOZ0Zvck9mQ29udGV4dCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIENvbXBvbmVudFJlZixcbiAgICBEaXJlY3RpdmUsXG4gICAgRG9DaGVjayxcbiAgICBFbWJlZGRlZFZpZXdSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIElucHV0LFxuICAgIEl0ZXJhYmxlQ2hhbmdlcyxcbiAgICBJdGVyYWJsZURpZmZlcixcbiAgICBJdGVyYWJsZURpZmZlcnMsXG4gICAgTmdab25lLFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE91dHB1dCxcbiAgICBTaW1wbGVDaGFuZ2VzLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIFRyYWNrQnlGdW5jdGlvbixcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgSW5qZWN0LFxuICAgIGJvb2xlYW5BdHRyaWJ1dGVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IERpc3BsYXlDb250YWluZXJDb21wb25lbnQgfSBmcm9tICcuL2Rpc3BsYXkuY29udGFpbmVyJztcbmltcG9ydCB7IEhWaXJ0dWFsSGVscGVyQ29tcG9uZW50IH0gZnJvbSAnLi9ob3Jpem9udGFsLnZpcnR1YWwuaGVscGVyLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBWaXJ0dWFsSGVscGVyQ29tcG9uZW50IH0gZnJvbSAnLi92aXJ0dWFsLmhlbHBlci5jb21wb25lbnQnO1xuXG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlLCBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlIH0gZnJvbSAnLi9mb3Jfb2Yuc3luYy5zZXJ2aWNlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgZmlsdGVyLCB0aHJvdHRsZVRpbWUsIGZpcnN0IH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgZ2V0UmVzaXplT2JzZXJ2ZXIgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzLCBQbGF0Zm9ybVV0aWwgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IFZpcnR1YWxIZWxwZXJCYXNlRGlyZWN0aXZlIH0gZnJvbSAnLi9iYXNlLmhlbHBlci5jb21wb25lbnQnO1xuXG5jb25zdCBNQVhfUEVSRl9TQ1JPTExfRElGRiA9IDQ7XG5cbi8qKlxuICogIEBwdWJsaWNBcGlcbiAqL1xuZXhwb3J0IGNsYXNzIElneEZvck9mQ29udGV4dDxULCBVIGV4dGVuZHMgVFtdID0gVFtdPiB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyAkaW1wbGljaXQ6IFQsXG4gICAgICAgIHB1YmxpYyBpZ3hGb3JPZjogVSxcbiAgICAgICAgcHVibGljIGluZGV4OiBudW1iZXIsXG4gICAgICAgIHB1YmxpYyBjb3VudDogbnVtYmVyXG4gICAgKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGhlIGZpcnN0IG9yIG5vdFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZmlyc3QoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdGhlIGxhc3Qgb3Igbm90XG4gICAgICovXG4gICAgcHVibGljIGdldCBsYXN0KCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleCA9PT0gdGhpcy5jb3VudCAtIDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgd2hldGhlciB0aGUgZWxlbWVudCBpcyBldmVuIG9yIG5vdFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZXZlbigpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXggJSAyID09PSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgb2RkIG9yIG5vdFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgb2RkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gIXRoaXMuZXZlbjtcbiAgICB9XG5cbn1cblxuLyoqIEBoaWRkZW4gQGludGVybmFsICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSWd4Rm9yT2ZUb2tlbjxULCBVIGV4dGVuZHMgVFtdID0gVFtdPiB7XG4gICAgcHVibGljIGFic3RyYWN0IGlneEZvck9mOiBVICYgVFtdIHwgbnVsbDtcbiAgICBwdWJsaWMgYWJzdHJhY3Qgc3RhdGU6IElGb3JPZlN0YXRlO1xuICAgIHB1YmxpYyBhYnN0cmFjdCB0b3RhbEl0ZW1Db3VudDogbnVtYmVyO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBzY3JvbGxQb3NpdGlvbjogbnVtYmVyO1xuXG4gICAgcHVibGljIGFic3RyYWN0IGNodW5rTG9hZDogRXZlbnRFbWl0dGVyPElGb3JPZlN0YXRlPjtcbiAgICBwdWJsaWMgYWJzdHJhY3QgY2h1bmtQcmVsb2FkOiBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+O1xuXG4gICAgcHVibGljIGFic3RyYWN0IHNjcm9sbFRvKGluZGV4OiBudW1iZXIpOiB2b2lkO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRTY3JvbGxGb3JJbmRleChpbmRleDogbnVtYmVyLCBib3R0b20/OiBib29sZWFuKTogbnVtYmVyO1xuICAgIHB1YmxpYyBhYnN0cmFjdCBnZXRTY3JvbGwoKTogSFRNTEVsZW1lbnQgfCB1bmRlZmluZWQ7XG5cbiAgICAvLyBUT0RPOiBSZS1ldmFsdWF0ZSB1c2UgZm9yIHRoaXMgaW50ZXJuYWxseSwgYmV0dGVyIGV4cG9zZSB0aHJvdWdoIHNlcGFyYXRlIEFQSVxuICAgIHB1YmxpYyBhYnN0cmFjdCBpZ3hGb3JJdGVtU2l6ZTogYW55O1xuICAgIHB1YmxpYyBhYnN0cmFjdCBpZ3hGb3JDb250YWluZXJTaXplOiBhbnk7XG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgYWJzdHJhY3QgZGM6IENvbXBvbmVudFJlZjxhbnk+XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneEZvcl1baWd4Rm9yT2ZdJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSWd4Rm9yT2ZTY3JvbGxTeW5jU2VydmljZSxcbiAgICAgICAgeyBwcm92aWRlOiBJZ3hGb3JPZlRva2VuLCB1c2VFeGlzdGluZzogSWd4Rm9yT2ZEaXJlY3RpdmUgfVxuICAgIF0sXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hGb3JPZkRpcmVjdGl2ZTxULCBVIGV4dGVuZHMgVFtdID0gVFtdPiBleHRlbmRzIElneEZvck9mVG9rZW48VCxVPiBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBEb0NoZWNrLCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXQge1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZGF0YSB0byBiZSByZW5kZXJlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvck9mOiBVICYgVFtdIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IG5hbWUgZnJvbSB3aGljaCB0byByZWFkIHRoZSBzaXplIGluIHRoZSBkYXRhIG9iamVjdC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZ3hGb3JTaXplUHJvcE5hbWU7XG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIHNjcm9sbCBvcmllbnRhdGlvbi5cbiAgICAgKiBTY3JvbGwgb3JpZW50YXRpb24gY2FuIGJlIFwidmVydGljYWxcIiBvciBcImhvcml6b250YWxcIi5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlneEZvclNjcm9sbE9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJztcblxuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsbHkgcGFzcyB0aGUgcGFyZW50IGBpZ3hGb3JgIGluc3RhbmNlIHRvIGNyZWF0ZSBhIHZpcnR1YWwgdGVtcGxhdGUgc2Nyb2xsaW5nIGJvdGggaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgI3Njcm9sbENvbnRhaW5lciBpZ3hGb3IgbGV0LXJvd0RhdGEgW2lneEZvck9mXT1cImRhdGFcIlxuICAgICAqICAgICAgIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCIndmVydGljYWwnXCJcbiAgICAgKiAgICAgICBbaWd4Rm9yQ29udGFpbmVyU2l6ZV09XCInNTAwcHgnXCJcbiAgICAgKiAgICAgICBbaWd4Rm9ySXRlbVNpemVdPVwiJzUwcHgnXCJcbiAgICAgKiAgICAgICBsZXQtcm93SW5kZXg9XCJpbmRleFwiPlxuICAgICAqICAgICAgIDxkaXYgW3N0eWxlLmRpc3BsYXldPVwiJ2ZsZXgnXCIgW3N0eWxlLmhlaWdodF09XCInNTBweCdcIj5cbiAgICAgKiAgICAgICAgICAgPG5nLXRlbXBsYXRlICNjaGlsZENvbnRhaW5lciBpZ3hGb3IgbGV0LWl0ZW0gW2lneEZvck9mXT1cImRhdGFcIlxuICAgICAqICAgICAgICAgICAgICAgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiXG4gICAgICogICAgICAgICAgICAgICBbaWd4Rm9yU2Nyb2xsQ29udGFpbmVyXT1cInBhcmVudFZpcnREaXJcIlxuICAgICAqICAgICAgICAgICAgICAgW2lneEZvckNvbnRhaW5lclNpemVdPVwiJzUwMHB4J1wiPlxuICAgICAqICAgICAgICAgICAgICAgICAgIDxkaXYgW3N0eWxlLm1pbi13aWR0aF09XCInNTBweCdcIj57e3Jvd0luZGV4fX0gOiB7e2l0ZW0udGV4dH19PC9kaXY+XG4gICAgICogICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICogICAgICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZ3hGb3JTY3JvbGxDb250YWluZXI6IGFueTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHB4LWFmZml4ZWQgc2l6ZSBvZiB0aGUgY29udGFpbmVyIGFsb25nIHRoZSBheGlzIG9mIHNjcm9sbGluZy5cbiAgICAgKiBGb3IgXCJob3Jpem9udGFsXCIgb3JpZW50YXRpb24gdGhpcyB2YWx1ZSBpcyB0aGUgd2lkdGggb2YgdGhlIGNvbnRhaW5lciBhbmQgZm9yIFwidmVydGljYWxcIiBpcyB0aGUgaGVpZ2h0LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIGxldC1pdGVtIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvckNvbnRhaW5lclNpemVdPVwiJzUwMHB4J1wiXG4gICAgICogICAgICBbaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb25dPVwiJ2hvcml6b250YWwnXCI+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZ3hGb3JDb250YWluZXJTaXplOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBweC1hZmZpeGVkIHNpemUgb2YgdGhlIGl0ZW0gYWxvbmcgdGhlIGF4aXMgb2Ygc2Nyb2xsaW5nLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGlzIHZhbHVlIGlzIHRoZSB3aWR0aCBvZiB0aGUgY29sdW1uIGFuZCBmb3IgXCJ2ZXJ0aWNhbFwiIGlzIHRoZSBoZWlnaHQgb3IgdGhlIHJvdy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBsZXQtaXRlbSBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIiBbaWd4Rm9ySXRlbVNpemVdPVwiJzUwcHgnXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZ3hGb3JJdGVtU2l6ZTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIGEgbmV3IGNodW5rIGhhcyBiZWVuIGxvYWRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlIGlneEZvciBbaWd4Rm9yT2ZdPVwiZGF0YVwiIFtpZ3hGb3JTY3JvbGxPcmllbnRhdGlvbl09XCInaG9yaXpvbnRhbCdcIiAoY2h1bmtMb2FkKT1cImxvYWRDaHVuaygkZXZlbnQpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbG9hZENodW5rKGUpe1xuICAgICAqIGFsZXJ0KFwiY2h1bmsgbG9hZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNodW5rTG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCB3aGVuIHNjcm9sbGJhciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLlxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBzY3JvbGxiYXJWaXNpYmlsaXR5Q2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8YW55PigpO1xuXG4gICAgLyoqXG4gICAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIHRoZSByZW5kZXJlZCBjb250ZW50IHNpemUgb2YgdGhlIGlneEZvck9mIGhhcyBiZWVuIGNoYW5nZWQuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNvbnRlbnRTaXplQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXIgZGF0YSBoYXMgYmVlbiBjaGFuZ2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIChkYXRhQ2hhbmdlZCk9XCJkYXRhQ2hhbmdlZCgkZXZlbnQpXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogZGF0YUNoYW5nZWQoZSl7XG4gICAgICogYWxlcnQoXCJkYXRhIGNoYW5nZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZGF0YUNoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBiZWZvcmVWaWV3RGVzdHJveWVkID0gbmV3IEV2ZW50RW1pdHRlcjxFbWJlZGRlZFZpZXdSZWY8YW55Pj4oKTtcblxuICAgIC8qKlxuICAgICAqIEFuIGV2ZW50IHRoYXQgaXMgZW1pdHRlZCBvbiBjaHVuayBsb2FkaW5nIHRvIGVtaXQgdGhlIGN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gLSBzdGFydEluZGV4LCBlbmRJbmRleCwgdG90YWxDb3VudC5cbiAgICAgKiBDYW4gYmUgdXNlZCBmb3IgaW1wbGVtZW50aW5nIHJlbW90ZSBsb2FkIG9uIGRlbWFuZCBmb3IgdGhlIGlneEZvciBkYXRhLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8bmctdGVtcGxhdGUgaWd4Rm9yIFtpZ3hGb3JPZl09XCJkYXRhXCIgW2lneEZvclNjcm9sbE9yaWVudGF0aW9uXT1cIidob3Jpem9udGFsJ1wiIChjaHVua1ByZWxvYWQpPVwiY2h1bmtQcmVsb2FkKCRldmVudClcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjaHVua1ByZWxvYWQoZSl7XG4gICAgICogYWxlcnQoXCJjaHVuayBpcyBsb2FkaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGNodW5rUHJlbG9hZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUZvck9mU3RhdGU+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGRjOiBDb21wb25lbnRSZWY8RGlzcGxheUNvbnRhaW5lckNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZGlyZWN0aXZlLiBJdCBjb250YWlucyBgc3RhcnRJbmRleGAgYW5kIGBjaHVua1NpemVgLlxuICAgICAqIHN0YXRlLnN0YXJ0SW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gYXQgd2hpY2ggdGhlIGN1cnJlbnQgdmlzaWJsZSBjaHVuayBiZWdpbnMuXG4gICAgICogc3RhdGUuY2h1bmtTaXplIC0gVGhlIG51bWJlciBvZiBpdGVtcyB0aGUgY3VycmVudCB2aXNpYmxlIGNodW5rIGhvbGRzLlxuICAgICAqIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHVzZWQgd2hlbiBpbXBsZW1lbnRpbmcgcmVtb3RlIHZpcnR1YWxpemF0aW9uIGFzIHRoZXkgcHJvdmlkZSB0aGUgbmVjZXNzYXJ5IHN0YXRlIGluZm9ybWF0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBncmlkU3RhdGUgPSB0aGlzLnBhcmVudFZpcnREaXIuc3RhdGU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHN0YXRlOiBJRm9yT2ZTdGF0ZSA9IHtcbiAgICAgICAgc3RhcnRJbmRleDogMCxcbiAgICAgICAgY2h1bmtTaXplOiAwXG4gICAgfTtcblxuICAgIHByb3RlY3RlZCBmdW5jO1xuICAgIHByb3RlY3RlZCBfc2l6ZXNDYWNoZTogbnVtYmVyW10gPSBbXTtcbiAgICBwcm90ZWN0ZWQgc2Nyb2xsQ29tcG9uZW50OiBWaXJ0dWFsSGVscGVyQmFzZURpcmVjdGl2ZTtcbiAgICBwcm90ZWN0ZWQgX2RpZmZlcjogSXRlcmFibGVEaWZmZXI8VD4gfCBudWxsID0gbnVsbDtcbiAgICBwcm90ZWN0ZWQgX3RyYWNrQnlGbjogVHJhY2tCeUZ1bmN0aW9uPFQ+O1xuICAgIHByb3RlY3RlZCBpbmRpdmlkdWFsU2l6ZUNhY2hlOiBudW1iZXJbXSA9IFtdO1xuICAgIC8qKiBJbnRlcm5hbCB0cmFjayBmb3Igc2Nyb2xsIHRvcCB0aGF0IGlzIGJlaW5nIHZpcnR1YWxpemVkICovXG4gICAgcHJvdGVjdGVkIF92aXJ0U2Nyb2xsUG9zaXRpb24gPSAwO1xuICAgIC8qKiBJZiB0aGUgbmV4dCBvblNjcm9sbCBldmVudCBpcyB0cmlnZ2VyZWQgZHVlIHRvIGludGVybmFsIHNldHRpbmcgb2Ygc2Nyb2xsVG9wICovXG4gICAgcHJvdGVjdGVkIF9iU2Nyb2xsSW50ZXJuYWwgPSBmYWxzZTtcbiAgICAvLyBFbmQgcHJvcGVydGllcyByZWxhdGVkIHRvIHZpcnR1YWwgaGVpZ2h0IGhhbmRsaW5nXG4gICAgcHJvdGVjdGVkIF9lbWJlZGRlZFZpZXdzOiBBcnJheTxFbWJlZGRlZFZpZXdSZWY8YW55Pj4gPSBbXTtcbiAgICBwcm90ZWN0ZWQgY29udGVudFJlc2l6ZU5vdGlmeSA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gICAgcHJvdGVjdGVkIGNvbnRlbnRPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXI7XG4gICAgLyoqIFNpemUgdGhhdCBpcyBiZWluZyB2aXJ0dWFsaXplZC4gKi9cbiAgICBwcm90ZWN0ZWQgX3ZpcnRTaXplID0gMDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgcHJpdmF0ZSBfdG90YWxJdGVtQ291bnQ6IG51bWJlciA9IG51bGw7XG4gICAgcHJpdmF0ZSBfYWRqdXN0VG9JbmRleDtcbiAgICAvLyBTdGFydCBwcm9wZXJ0aWVzIHJlbGF0ZWQgdG8gdmlydHVhbCBzaXplIGhhbmRsaW5nIGR1ZSB0byBicm93c2VyIGxpbWl0YXRpb25cbiAgICAvKiogTWF4aW11bSBzaXplIGZvciBhbiBlbGVtZW50IG9mIHRoZSBicm93c2VyLiAqL1xuICAgIHByaXZhdGUgX21heFNpemU7XG4gICAgLyoqXG4gICAgICogUmF0aW8gZm9yIGhlaWdodCB0aGF0J3MgYmVpbmcgdmlydHVhbGl6YWVkIGFuZCB0aGUgb25lIHZpc2libGVcbiAgICAgKiBJZiBfdmlydEhlaWdodFJhdGlvID0gMSwgdGhlIHZpc2libGUgaGVpZ2h0IGFuZCB0aGUgdmlydHVhbGl6ZWQgYXJlIHRoZSBzYW1lLCBhbHNvIF9tYXhTaXplID4gX3ZpcnRIZWlnaHQuXG4gICAgICovXG4gICAgcHJpdmF0ZSBfdmlydFJhdGlvID0gMTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBjb3VudCBvZiB0aGUgdmlydHVhbCBkYXRhIGl0ZW1zLCB3aGVuIHVzaW5nIHJlbW90ZSBzZXJ2aWNlLlxuICAgICAqIFNpbWlsYXIgdG8gdGhlIHByb3BlcnR5IHRvdGFsSXRlbUNvdW50LCBidXQgdGhpcyB3aWxsIGFsbG93IHNldHRpbmcgdGhlIGRhdGEgY291bnQgaW50byB0aGUgdGVtcGxhdGUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxuZy10ZW1wbGF0ZSBpZ3hGb3IgbGV0LWl0ZW0gW2lneEZvck9mXT1cImRhdGEgfCBhc3luY1wiIFtpZ3hGb3JUb3RhbEl0ZW1Db3VudF09XCJjb3VudCB8IGFzeW5jXCJcbiAgICAgKiAgW2lneEZvckNvbnRhaW5lclNpemVdPVwiJzUwMHB4J1wiIFtpZ3hGb3JJdGVtU2l6ZV09XCInNTBweCdcIj48L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpZ3hGb3JUb3RhbEl0ZW1Db3VudCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1Db3VudDtcbiAgICB9XG4gICAgcHVibGljIHNldCBpZ3hGb3JUb3RhbEl0ZW1Db3VudCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMudG90YWxJdGVtQ291bnQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdG90YWwgY291bnQgb2YgdGhlIHZpcnR1YWwgZGF0YSBpdGVtcywgd2hlbiB1c2luZyByZW1vdGUgc2VydmljZS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLnRvdGFsSXRlbUNvdW50ID0gZGF0YS5Db3VudDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRvdGFsSXRlbUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxJdGVtQ291bnQ7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCB0b3RhbEl0ZW1Db3VudCh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RvdGFsSXRlbUNvdW50ICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsSXRlbUNvdW50ID0gdmFsO1xuICAgICAgICAgICAgLy8gdXBkYXRlIHNpemVzIGluIGNhc2UgdG90YWwgY291bnQgY2hhbmdlcy5cbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZURpZmYgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplIC0gbmV3U2l6ZTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPSBuZXdTaXplO1xuICAgICAgICAgICAgY29uc3QgbGFzdENodW5rRXhjZWVkZWQgPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSA+IHZhbDtcbiAgICAgICAgICAgIGlmIChsYXN0Q2h1bmtFeGNlZWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhcnRJbmRleCA9IHZhbCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fYWRqdXN0U2Nyb2xsUG9zaXRpb25BZnRlclNpemVDaGFuZ2Uoc2l6ZURpZmYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBkaXNwbGF5Q29udGFpbmVyKCk6IEhUTUxFbGVtZW50IHwgdW5kZWZpbmVkIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGM/Lmluc3RhbmNlPy5fdmlld0NvbnRhaW5lcj8uZWxlbWVudD8ubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IHZpcnR1YWxIZWxwZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGlzUmVtb3RlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50b3RhbEl0ZW1Db3VudCAhPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwb3NpdGlvbiA9IGRpcmVjdGl2ZS5zY3JvbGxQb3NpdGlvbjtcbiAgICAgKiBkaXJlY3RpdmUuc2Nyb2xsUG9zaXRpb24gPSB2YWx1ZTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHNjcm9sbFBvc2l0aW9uKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbXBvbmVudC5zY3JvbGxBbW91bnQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgc2Nyb2xsUG9zaXRpb24odmFsOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gdGhpcy5zY3JvbGxDb21wb25lbnQuc2Nyb2xsQW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiB0aGlzLnNjcm9sbENvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zY3JvbGxMZWZ0ID0gdGhpcy5pc1JUTCA/IC12YWwgOiB2YWw7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zY3JvbGxDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsVG9wID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXQgaXNSVEwoKSB7XG4gICAgICAgIGNvbnN0IGRpciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGRpciA9PT0gJ3J0bCc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBzaXplc0NhY2hlKCk6IG51bWJlcltdIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVzQ2FjaGU7XG4gICAgfVxuICAgIHByb3RlY3RlZCBzZXQgc2l6ZXNDYWNoZSh2YWx1ZTogbnVtYmVyW10pIHtcbiAgICAgICAgdGhpcy5fc2l6ZXNDYWNoZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IF9pc1Njcm9sbGVkVG9Cb3R0b20oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRTY3JvbGwoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5nZXRTY3JvbGwoKS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIC8vIFVzZSA9PT0gYW5kIG5vdCA+PSBiZWNhdXNlIGBzY3JvbGxUb3AgKyBjb250YWluZXIgc2l6ZWAgY2FuJ3QgYmUgYmlnZ2VyIHRoYW4gYHNjcm9sbEhlaWdodGAsIHVubGVzcyBzb21ldGhpbmcgaXNuJ3QgdXBkYXRlZC5cbiAgICAgICAgLy8gQWxzbyB1c2UgTWF0aC5yb3VuZCBiZWNhdXNlIENocm9tZSBoYXMgc29tZSBpbmNvbnNpc3RlbmNpZXMgYW5kIGBzY3JvbGxUb3AgKyBjb250YWluZXJgIGNhbiBiZSBmbG9hdCB3aGVuIHpvb21pbmcgdGhlIHBhZ2UuXG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuZ2V0U2Nyb2xsKCkuc2Nyb2xsVG9wICsgdGhpcy5pZ3hGb3JDb250YWluZXJTaXplKSA9PT0gc2Nyb2xsSGVpZ2h0O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0IF9pc0F0Qm90dG9tSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlneEZvck9mICYmIHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID4gdGhpcy5pZ3hGb3JPZi5sZW5ndGg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgX3ZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHByb3RlY3RlZCBfdGVtcGxhdGU6IFRlbXBsYXRlUmVmPE5nRm9yT2ZDb250ZXh0PFQ+PixcbiAgICAgICAgcHJvdGVjdGVkIF9kaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwcm90ZWN0ZWQgX3pvbmU6IE5nWm9uZSxcbiAgICAgICAgcHJvdGVjdGVkIHN5bmNTY3JvbGxTZXJ2aWNlOiBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwsXG4gICAgICAgIEBJbmplY3QoRE9DVU1FTlQpXG4gICAgICAgIHByb3RlY3RlZCBkb2N1bWVudDogYW55LFxuICAgICkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cblxuICAgIHB1YmxpYyB2ZXJ0aWNhbFNjcm9sbEhhbmRsZXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vblNjcm9sbChldmVudCk7XG4gICAgfVxuXG4gICAgcHVibGljIGlzU2Nyb2xsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPiBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB2YyA9IHRoaXMuaWd4Rm9yU2Nyb2xsQ29udGFpbmVyID8gdGhpcy5pZ3hGb3JTY3JvbGxDb250YWluZXIuX3ZpZXdDb250YWluZXIgOiB0aGlzLl92aWV3Q29udGFpbmVyO1xuICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA9IHRoaXMuaWd4Rm9yU2l6ZVByb3BOYW1lIHx8ICd3aWR0aCc7XG4gICAgICAgIHRoaXMuZGMgPSB0aGlzLl92aWV3Q29udGFpbmVyLmNyZWF0ZUNvbXBvbmVudChEaXNwbGF5Q29udGFpbmVyQ29tcG9uZW50LCB7IGluZGV4OiAwIH0pO1xuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLnNjcm9sbERpcmVjdGlvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb247XG4gICAgICAgIGlmICh0aGlzLmlneEZvck9mICYmIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudCA9IHRoaXMuc3luY1Njcm9sbFNlcnZpY2UuZ2V0U2Nyb2xsTWFzdGVyKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5jaHVua1NpemUgPSB0aGlzLl9jYWxjdWxhdGVDaHVua1NpemUoKTtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uubm90VmlydHVhbCA9ICEodGhpcy5pZ3hGb3JDb250YWluZXJTaXplICYmIHRoaXMuc3RhdGUuY2h1bmtTaXplIDwgdGhpcy5pZ3hGb3JPZi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsQ29tcG9uZW50ICYmICF0aGlzLnNjcm9sbENvbXBvbmVudC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggPSBNYXRoLm1pbih0aGlzLmdldEluZGV4QXQodGhpcy5zY3JvbGxQb3NpdGlvbiwgdGhpcy5zaXplc0NhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSB0aGlzLnN0YXRlLmNodW5rU2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4OyBpIDwgdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemUgJiZcbiAgICAgICAgICAgICAgICB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXcgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgbmV3IElneEZvck9mQ29udGV4dDxULCBVPihpbnB1dCwgdGhpcy5pZ3hGb3JPZiwgdGhpcy5nZXRDb250ZXh0SW5kZXgoaW5wdXQpLCB0aGlzLmlneEZvck9mLmxlbmd0aClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21heFNpemUgPSB0aGlzLl9jYWxjTWF4QnJvd3NlclNpemUoKTtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQgPSB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLmdldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxDb21wb25lbnQgfHwgdGhpcy5zY3JvbGxDb21wb25lbnQuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQgPSB2Yy5jcmVhdGVDb21wb25lbnQoVmlydHVhbEhlbHBlckNvbXBvbmVudCkuaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPSB0aGlzLmlneEZvck9mID8gdGhpcy5fY2FsY1NpemUoKSA6IDA7XG4gICAgICAgICAgICB0aGlzLnN5bmNTY3JvbGxTZXJ2aWNlLnNldFNjcm9sbE1hc3Rlcih0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uLCB0aGlzLnNjcm9sbENvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsSGFuZGxlciA9IHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLnZlcnRpY2FsU2Nyb2xsSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5zY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkZXN0cnVjdG9yID0gdGFrZVVudGlsPGFueT4odGhpcy5kZXN0cm95JCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRSZXNpemVOb3RpZnkucGlwZShcbiAgICAgICAgICAgICAgICBmaWx0ZXIoKCkgPT4gdGhpcy5pZ3hGb3JDb250YWluZXJTaXplICYmIHRoaXMuaWd4Rm9yT2YgJiYgdGhpcy5pZ3hGb3JPZi5sZW5ndGggPiAwKSxcbiAgICAgICAgICAgICAgICB0aHJvdHRsZVRpbWUoNDAsIHVuZGVmaW5lZCwgeyBsZWFkaW5nOiBmYWxzZSwgdHJhaWxpbmc6IHRydWUgfSksXG4gICAgICAgICAgICAgICAgZGVzdHJ1Y3RvclxuICAgICAgICAgICAgKS5zdWJzY3JpYmUoKCkgPT4gdGhpcy5fem9uZS5ydW5UYXNrKCgpID0+IHRoaXMudXBkYXRlU2l6ZXMoKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5mdW5jID0gKGV2dCkgPT4gdGhpcy5vbkhTY3JvbGwoZXZ0KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50ID0gdGhpcy5zeW5jU2Nyb2xsU2VydmljZS5nZXRTY3JvbGxNYXN0ZXIodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQgPSB2Yy5jcmVhdGVDb21wb25lbnQoSFZpcnR1YWxIZWxwZXJDb21wb25lbnQpLmluc3RhbmNlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgPSB0aGlzLmlneEZvck9mID8gdGhpcy5fY2FsY1NpemUoKSA6IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jU2Nyb2xsU2VydmljZS5zZXRTY3JvbGxNYXN0ZXIodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiwgdGhpcy5zY3JvbGxDb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuZnVuYyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGMuaW5zdGFuY2Uuc2Nyb2xsQ29udGFpbmVyID0gdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5mdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5zY3JvbGxDb250YWluZXIgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZW50T2JzZXJ2ZXIgPSBuZXcgKGdldFJlc2l6ZU9ic2VydmVyKCkpKCgpID0+IHRoaXMuY29udGVudFJlc2l6ZU5vdGlmeS5uZXh0KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudE9ic2VydmVyLm9ic2VydmUodGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbW92ZVNjcm9sbEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudE9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQXNzZXJ0cyB0aGUgY29ycmVjdCB0eXBlIG9mIHRoZSBjb250ZXh0IGZvciB0aGUgdGVtcGxhdGUgdGhhdCBgaWd4Rm9yT2ZgIHdpbGwgcmVuZGVyLlxuICAgICAqXG4gICAgICogVGhlIHByZXNlbmNlIG9mIHRoaXMgbWV0aG9kIGlzIGEgc2lnbmFsIHRvIHRoZSBJdnkgdGVtcGxhdGUgdHlwZS1jaGVjayBjb21waWxlciB0aGF0IHRoZVxuICAgICAqIGBJZ3hGb3JPZmAgc3RydWN0dXJhbCBkaXJlY3RpdmUgcmVuZGVycyBpdHMgdGVtcGxhdGUgd2l0aCBhIHNwZWNpZmljIGNvbnRleHQgdHlwZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhdGljIG5nVGVtcGxhdGVDb250ZXh0R3VhcmQ8VCwgVSBleHRlbmRzIFRbXT4oZGlyOiBJZ3hGb3JPZkRpcmVjdGl2ZTxULCBVPiwgY3R4OiBhbnkpOlxuICAgICAgICBjdHggaXMgSWd4Rm9yT2ZDb250ZXh0PFQsIFU+IHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGZvck9mID0gJ2lneEZvck9mJztcbiAgICAgICAgaWYgKGZvck9mIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlc1tmb3JPZl0uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQodmFsdWUpLmNyZWF0ZSh0aGlzLmlneEZvclRyYWNrQnkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYENhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0IFwiJHt2YWx1ZX1cIiBvZiB0eXBlIFwiJHtnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh2YWx1ZSl9XCIuXG4gICAgICAgICAgICAgICAgICAgICBOZ0ZvciBvbmx5IHN1cHBvcnRzIGJpbmRpbmcgdG8gSXRlcmFibGVzIHN1Y2ggYXMgQXJyYXlzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0SXRlbVNpemUgPSAnaWd4Rm9ySXRlbVNpemUnO1xuICAgICAgICBpZiAoZGVmYXVsdEl0ZW1TaXplIGluIGNoYW5nZXMgJiYgIWNoYW5nZXNbZGVmYXVsdEl0ZW1TaXplXS5maXJzdENoYW5nZSAmJiB0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGVmYXVsdCBpdGVtIHNpemUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gJ2lneEZvckNvbnRhaW5lclNpemUnO1xuICAgICAgICBpZiAoY29udGFpbmVyU2l6ZSBpbiBjaGFuZ2VzICYmICFjaGFuZ2VzW2NvbnRhaW5lclNpemVdLmZpcnN0Q2hhbmdlICYmIHRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZTaXplID0gcGFyc2VJbnQoY2hhbmdlc1tjb250YWluZXJTaXplXS5wcmV2aW91c1ZhbHVlLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBuZXdTaXplID0gcGFyc2VJbnQoY2hhbmdlc1tjb250YWluZXJTaXplXS5jdXJyZW50VmFsdWUsIDEwKTtcbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY09uQ29udGFpbmVyQ2hhbmdlKHtwcmV2U2l6ZSwgbmV3U2l6ZX0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0RvQ2hlY2soKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLl9kaWZmZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9kaWZmZXIuZGlmZih0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgLy8gIHJlLWluaXQgY2FjaGUuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaWd4Rm9yT2YgPSBbXSBhcyBVO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTaXplQ2FjaGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lclNpemU6IHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogU2hpZnRzIHRoZSBzY3JvbGwgdGh1bWIgcG9zaXRpb24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5hZGRTY3JvbGwoNSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkVG9wIG5lZ2F0aXZlIHZhbHVlIHRvIHNjcm9sbCB1cCBhbmQgcG9zaXRpdmUgdG8gc2Nyb2xsIGRvd247XG4gICAgICovXG4gICAgcHVibGljIGFkZFNjcm9sbFRvcChhZGQ6IG51bWJlcik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGRTY3JvbGwoYWRkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaGlmdHMgdGhlIHNjcm9sbCB0aHVtYiBwb3NpdGlvbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmFkZFNjcm9sbCg1KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGQgbmVnYXRpdmUgdmFsdWUgdG8gc2Nyb2xsIHByZXZpb3VzIGFuZCBwb3NpdGl2ZSB0byBzY3JvbGwgbmV4dDtcbiAgICAgKi9cbiAgICBwdWJsaWMgYWRkU2Nyb2xsKGFkZDogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChhZGQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFZpcnRTY3JvbGxUb3AgPSB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRTaXplIC0gY29udGFpbmVyU2l6ZTtcblxuICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gKz0gYWRkO1xuICAgICAgICB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gPSB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gPiAwID9cbiAgICAgICAgICAgICh0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gPCBtYXhWaXJ0U2Nyb2xsVG9wID8gdGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uIDogbWF4VmlydFNjcm9sbFRvcCkgOlxuICAgICAgICAgICAgMDtcblxuICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uICs9IGFkZCAvIHRoaXMuX3ZpcnRSYXRpbztcbiAgICAgICAgaWYgKE1hdGguYWJzKGFkZCAvIHRoaXMuX3ZpcnRSYXRpbykgPCAxKSB7XG4gICAgICAgICAgICAvLyBBY3R1YWwgc2Nyb2xsIGRlbHRhIHRoYXQgd2FzIGFkZGVkIGlzIHNtYWxsZXIgdGhhbiAxIGFuZCBvblNjcm9sbCBoYW5kbGVyIGRvZXNuJ3QgdHJpZ2dlciB3aGVuIHNjcm9sbGluZyA8IDFweFxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbik7XG4gICAgICAgICAgICAvLyBzY3JvbGxPZmZzZXQgPSBzY3JvbGxPZmZzZXQgIT09IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKSA/IHNjcm9sbE9mZnNldCA6IDA7XG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSAtKHNjcm9sbE9mZnNldCkgKyAncHgnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbWF4UmVhbFNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0IC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgaWYgKCh0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gPiAwICYmIHRoaXMuc2Nyb2xsUG9zaXRpb24gPT09IDApIHx8XG4gICAgICAgICAgICAodGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uIDwgbWF4VmlydFNjcm9sbFRvcCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uID09PSBtYXhSZWFsU2Nyb2xsVG9wKSkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBpcyBhdCB0aGUgdG9wIG9yIGJvdHRvbSwgYnV0IHZpcnR1YWwgb25lIGlzIG5vdCBhdCB0aGUgdG9wIG9yIGJvdHRvbSAodGhlcmUncyBtb3JlIHRvIHNjcm9sbClcbiAgICAgICAgICAgIC8vIFJlY2FsY3VsYXRlIGFjdHVhbCBzY3JvbGwgcG9zaXRpb24gYmFzZWQgb24gdGhlIHZpcnR1YWwgc2Nyb2xsLlxuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiAvIHRoaXMuX3ZpcnRSYXRpbztcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gPT09IDAgJiYgdGhpcy5zY3JvbGxQb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgIC8vIEFjdHVhbCBzY3JvbGwgcG9zaXRpb24gaXMgbm90IGF0IHRoZSB0b3AsIGJ1dCB2aXJ0dWFsIHNjcm9sbCBpcy4gSnVzdCB1cGRhdGUgdGhlIGFjdHVhbCBzY3JvbGxcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA9PT0gbWF4VmlydFNjcm9sbFRvcCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uIDwgbWF4UmVhbFNjcm9sbFRvcCkge1xuICAgICAgICAgICAgLy8gQWN0dWFsIHNjcm9sbCBwb3NpdGlvbiBpcyBub3QgYXQgdGhlIGJvdHRvbSwgYnV0IHZpcnR1YWwgc2Nyb2xsIGlzLiBKdXN0IHVwZGF0ZSB0aGUgYWN1YWwgc2Nyb2xsXG4gICAgICAgICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uID0gbWF4UmVhbFNjcm9sbFRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uICE9PSBvcmlnaW5hbFZpcnRTY3JvbGxUb3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0byB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuc2Nyb2xsVG8oNSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsVG8oaW5kZXg6IG51bWJlcikge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gKHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogdGhpcy5pZ3hGb3JPZi5sZW5ndGgpIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3QgaXNQcmV2SXRlbSA9IGluZGV4IDwgdGhpcy5zdGF0ZS5zdGFydEluZGV4IHx8IHRoaXMuc2Nyb2xsUG9zaXRpb24gPiB0aGlzLnNpemVzQ2FjaGVbaW5kZXhdO1xuICAgICAgICBsZXQgbmV4dFNjcm9sbCA9IGlzUHJldkl0ZW0gPyB0aGlzLnNpemVzQ2FjaGVbaW5kZXhdIDogdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gLSBjb250YWluZXJTaXplO1xuICAgICAgICBpZiAobmV4dFNjcm9sbCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXhWaXJ0U2Nyb2xsVG9wID0gdGhpcy5fdmlydFNpemUgLSBjb250YWluZXJTaXplO1xuICAgICAgICBpZiAobmV4dFNjcm9sbCA+IG1heFZpcnRTY3JvbGxUb3ApIHtcbiAgICAgICAgICAgIG5leHRTY3JvbGwgPSBtYXhWaXJ0U2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA9IG5leHRTY3JvbGw7XG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24gPSB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24gLyB0aGlzLl92aXJ0UmF0aW87XG4gICAgICAgIHRoaXMuX2FkanVzdFRvSW5kZXggPSAhaXNQcmV2SXRlbSA/IGluZGV4IDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGJ5IG9uZSBpdGVtIGludG8gdGhlIGFwcHJvcHJpYXRlIG5leHQgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgdGhlIHJpZ2h0IGNvbHVtbiBhbmQgZm9yIFwidmVydGljYWxcIiB0aGF0IGlzIHRoZSBsb3dlciByb3cuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxOZXh0KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbE5leHQoKSB7XG4gICAgICAgIGNvbnN0IHNjciA9IE1hdGguYWJzKE1hdGguY2VpbCh0aGlzLnNjcm9sbFBvc2l0aW9uKSk7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KHNjciArIHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApLCB0aGlzLnNpemVzQ2FjaGUpO1xuICAgICAgICB0aGlzLnNjcm9sbFRvKGVuZEluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY3JvbGxzIGJ5IG9uZSBpdGVtIGludG8gdGhlIGFwcHJvcHJpYXRlIHByZXZpb3VzIGRpcmVjdGlvbi5cbiAgICAgKiBGb3IgXCJob3Jpem9udGFsXCIgb3JpZW50YXRpb24gdGhhdCB3aWxsIGJlIHRoZSBsZWZ0IGNvbHVtbiBhbmQgZm9yIFwidmVydGljYWxcIiB0aGF0IGlzIHRoZSB1cHBlciByb3cuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxQcmV2KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFByZXYoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG8odGhpcy5zdGF0ZS5zdGFydEluZGV4IC0gMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2Nyb2xscyBieSBvbmUgcGFnZSBpbnRvIHRoZSBhcHByb3ByaWF0ZSBuZXh0IGRpcmVjdGlvbi5cbiAgICAgKiBGb3IgXCJob3Jpem9udGFsXCIgb3JpZW50YXRpb24gdGhhdCB3aWxsIGJlIG9uZSB2aWV3IHRvIHRoZSByaWdodCBhbmQgZm9yIFwidmVydGljYWxcIiB0aGF0IGlzIG9uZSB2aWV3IHRvIHRoZSBib3R0b20uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5zY3JvbGxOZXh0UGFnZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxOZXh0UGFnZSgpIHtcbiAgICAgICAgdGhpcy5hZGRTY3JvbGwocGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjcm9sbHMgYnkgb25lIHBhZ2UgaW50byB0aGUgYXBwcm9wcmlhdGUgcHJldmlvdXMgZGlyZWN0aW9uLlxuICAgICAqIEZvciBcImhvcml6b250YWxcIiBvcmllbnRhdGlvbiB0aGF0IHdpbGwgYmUgb25lIHZpZXcgdG8gdGhlIGxlZnQgYW5kIGZvciBcInZlcnRpY2FsXCIgdGhhdCBpcyBvbmUgdmlldyB0byB0aGUgdG9wLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuc2Nyb2xsUHJldlBhZ2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsUHJldlBhZ2UoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSAocGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkpO1xuICAgICAgICB0aGlzLmFkZFNjcm9sbCgtY29udGFpbmVyU2l6ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb2x1bW5TY3JvbGxMZWZ0KGNvbEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemVzQ2FjaGVbY29sSW5kZXhdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBpdGVtcyB0aGF0IGFyZSBmdWxseSB2aXNpYmxlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuZ2V0SXRlbUNvdW50SW5WaWV3KCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldEl0ZW1Db3VudEluVmlldygpIHtcbiAgICAgICAgbGV0IHN0YXJ0SW5kZXggPSB0aGlzLmdldEluZGV4QXQodGhpcy5zY3JvbGxQb3NpdGlvbiwgdGhpcy5zaXplc0NhY2hlKTtcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsUG9zaXRpb24gLSB0aGlzLnNpemVzQ2FjaGVbc3RhcnRJbmRleF0gPiAwKSB7XG4gICAgICAgICAgICAvLyBmaXNydCBpdGVtIGlzIG5vdCBmdWxseSBpbiB2aWV3XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0aGlzLmdldEluZGV4QXQodGhpcy5zY3JvbGxQb3NpdGlvbiArIHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApLCB0aGlzLnNpemVzQ2FjaGUpO1xuICAgICAgICByZXR1cm4gZW5kSW5kZXggLSBzdGFydEluZGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIHNjcm9sbGJhciBET00gZWxlbWVudC5cbiAgICAgKiBUaGlzIGlzIGVpdGhlciBhIHZlcnRpY2FsIG9yIGhvcml6b250YWwgc2Nyb2xsYmFyIGRlcGVuZGluZyBvbiB0aGUgc3BlY2lmaWVkIGlneEZvclNjcm9sbE9yaWVudGF0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBkaXIuZ2V0U2Nyb2xsKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldFNjcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsQ29tcG9uZW50Py5uYXRpdmVFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXguXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRTaXplQXQoMSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldFNpemVBdChpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpemVzQ2FjaGVbaW5kZXggKyAxXSAtIHRoaXMuc2l6ZXNDYWNoZVtpbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHRvIGdldCB0aGUgbmF0aXZlIHNjcm9sbGJhciBzaXplIHRoYXQgdGhlIGJyb3dzZXJzIHJlbmRlcnMuXG4gICAgICovXG4gICAgcHVibGljIGdldFNjcm9sbE5hdGl2ZVNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbENvbXBvbmVudCA/IHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNjcm9sbE5hdGl2ZVNpemUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5wYXJlbnRWaXJ0RGlyLmdldFNjcm9sbEZvckluZGV4KDEpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRTY3JvbGxGb3JJbmRleChpbmRleDogbnVtYmVyLCBib3R0b20/OiBib29sZWFuKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsID0gYm90dG9tID8gTWF0aC5tYXgoMCwgdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gLSBjb250YWluZXJTaXplKSA6IHRoaXMuc2l6ZXNDYWNoZVtpbmRleF07XG4gICAgICAgIHJldHVybiBzY3JvbGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgYXQgdGhlIHNwZWNpZmllZCBvZmZzZXQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5nZXRJbmRleEF0U2Nyb2xsKDEwMCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldEluZGV4QXRTY3JvbGwoc2Nyb2xsT2Zmc2V0OiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5kZXhBdChzY3JvbGxPZmZzZXQsIHRoaXMuc2l6ZXNDYWNoZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgdGFyZ2V0IGluZGV4IGlzIG91dHNpZGUgdGhlIHZpZXcuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMucGFyZW50VmlydERpci5pc0luZGV4T3V0c2lkZVZpZXcoMTApO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBpc0luZGV4T3V0c2lkZVZpZXcoaW5kZXg6IG51bWJlcikge1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gaW5kZXggPj0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICYmIGluZGV4IDw9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplID9cbiAgICAgICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MubWFwKHZpZXcgPT5cbiAgICAgICAgICAgICAgICB2aWV3LnJvb3ROb2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHx8IHZpZXcucm9vdE5vZGVzWzBdLm5leHRFbGVtZW50U2libGluZylbaW5kZXggLSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIDogbnVsbDtcbiAgICAgICAgY29uc3Qgcm93SGVpZ2h0ID0gdGhpcy5nZXRTaXplQXQoaW5kZXgpO1xuICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lck9mZnNldCA9IC0odGhpcy5zY3JvbGxQb3NpdGlvbiAtIHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdKTtcbiAgICAgICAgY29uc3QgZW5kVG9wT2Zmc2V0ID0gdGFyZ2V0Tm9kZSA/IHRhcmdldE5vZGUub2Zmc2V0VG9wICsgcm93SGVpZ2h0ICsgY29udGFpbmVyT2Zmc2V0IDogY29udGFpbmVyU2l6ZSArIHJvd0hlaWdodDtcbiAgICAgICAgcmV0dXJuICF0YXJnZXROb2RlIHx8IHRhcmdldE5vZGUub2Zmc2V0VG9wIDwgTWF0aC5hYnMoY29udGFpbmVyT2Zmc2V0KVxuICAgICAgICAgICAgfHwgY29udGFpbmVyU2l6ZSAmJiBlbmRUb3BPZmZzZXQgLSBjb250YWluZXJTaXplID4gNTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IHJlY2FsY3VsYXRlcyBhbmQgdXBkYXRlcyBjYWNoZSBzaXplcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVjYWxjVXBkYXRlU2l6ZXMoKSB7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCBkaWZmcyA9IFtdO1xuICAgICAgICBsZXQgdG90YWxEaWZmID0gMDtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuX2VtYmVkZGVkVmlld3MubGVuZ3RoO1xuICAgICAgICBjb25zdCByTm9kZXMgPSB0aGlzLl9lbWJlZGRlZFZpZXdzLm1hcCh2aWV3ID0+XG4gICAgICAgICAgICB2aWV3LnJvb3ROb2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHx8IHZpZXcucm9vdE5vZGVzWzBdLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByTm9kZSA9IHJOb2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChyTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHJOb2RlKS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gcGFyc2VGbG9hdChoZWlnaHQpIHx8IHBhcnNlSW50KHRoaXMuaWd4Rm9ySXRlbVNpemUsIDEwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIGk7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWFyZ2luID0gdGhpcy5nZXRNYXJnaW4ock5vZGUsIGRpbWVuc2lvbik7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsID0gdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlW2luZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWwgPSAoZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IGggOiByTm9kZS5jbGllbnRXaWR0aCkgKyBtYXJnaW47XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlW2luZGV4XSA9IG5ld1ZhbDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyRGlmZiA9IG5ld1ZhbCAtIG9sZFZhbDtcbiAgICAgICAgICAgICAgICBkaWZmcy5wdXNoKGN1cnJEaWZmKTtcbiAgICAgICAgICAgICAgICB0b3RhbERpZmYgKz0gY3VyckRpZmY7XG4gICAgICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlW2luZGV4ICsgMV0gKz0gdG90YWxEaWZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgICAgICBpZiAoTWF0aC5hYnModG90YWxEaWZmKSA+IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSArIDE7IGogPCB0aGlzLnNpemVzQ2FjaGUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGVbal0gKz0gdG90YWxEaWZmO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB1cGRhdGUgc2NyQmFyIGhlaWdodHMvd2lkdGhzXG4gICAgICAgICAgICBjb25zdCByZWR1Y2VyID0gKGFjYywgdmFsKSA9PiBhY2MgKyB2YWw7XG5cbiAgICAgICAgICAgIGNvbnN0IGhTdW0gPSB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUucmVkdWNlKHJlZHVjZXIpO1xuICAgICAgICAgICAgaWYgKGhTdW0gPiB0aGlzLl9tYXhTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlydFJhdGlvID0gaFN1bSAvIHRoaXMuX21heFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID0gTWF0aC5taW4odGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSArIHRvdGFsRGlmZiwgdGhpcy5fbWF4U2l6ZSk7XG4gICAgICAgICAgICB0aGlzLl92aXJ0U2l6ZSA9IGhTdW07XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsQ29tcG9uZW50LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzY3JUb0JvdHRvbSA9IHRoaXMuX2lzU2Nyb2xsZWRUb0JvdHRvbSAmJiAhdGhpcy5kYy5pbnN0YW5jZS5ub3RWaXJ0dWFsO1xuICAgICAgICAgICAgaWYgKHNjclRvQm90dG9tICYmICF0aGlzLl9pc0F0Qm90dG9tSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWluZXJTaXplID0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbFRvcCA9IHRoaXMuX3ZpcnRTaXplIC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9iU2Nyb2xsSW50ZXJuYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbiA9IG1heFZpcnRTY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG1heFZpcnRTY3JvbGxUb3A7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2FkanVzdFRvSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIHNjcm9sbGVkIHRvIHNwZWNpZmljIGluZGV4IHdoZXJlIGFmdGVyIHNjcm9sbCBoZWlnaHRzIGFyZSBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byBhZGp1c3QgdGhlIG9mZnNldHMgc28gdGhhdCBpdGVtIGlzIGxhc3QgaW4gdmlldy5cbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVzVG9JbmRleCA9IHRoaXMuX2FkanVzdFRvSW5kZXggLSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1bURpZmZzID0gZGlmZnMuc2xpY2UoMCwgdXBkYXRlc1RvSW5kZXgpLnJlZHVjZShyZWR1Y2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoc3VtRGlmZnMgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRTY3JvbGwoc3VtRGlmZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RUb0luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBSZXNldCBzY3JvbGwgcG9zaXRpb24uXG4gICAgICogTmVlZGVkIGluIGNhc2Ugc2Nyb2xsYmFyIGlzIGhpZGRlbi9kZXRhY2hlZCBidXQgd2Ugc3RpbGwgbmVlZCB0byByZXNldCBpdC5cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVzZXRTY3JvbGxQb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IDA7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNjcm9sbEFtb3VudCA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCByZW1vdmVTY3JvbGxFdmVudExpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgdGhpcy5fem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB0aGlzLnNjcm9sbENvbXBvbmVudD8ubmF0aXZlRWxlbWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5mdW5jKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQ/Lm5hdGl2ZUVsZW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMudmVydGljYWxTY3JvbGxIYW5kbGVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHNjcm9sbGluZyB2ZXJ0aWNhbGx5XG4gICAgICovXG4gICAgcHJvdGVjdGVkIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIC8qIGluIGNlcnRhaW4gc2l0dWF0aW9ucyB0aGlzIG1heSBiZSBjYWxsZWQgd2hlbiBubyBzY3JvbGxiYXIgaXMgdmlzaWJsZSAqL1xuICAgICAgICBpZiAoIXBhcnNlSW50KHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0LCAxMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2JTY3JvbGxJbnRlcm5hbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1ZpcnR1YWxTY3JvbGxQb3NpdGlvbihldmVudC50YXJnZXQuc2Nyb2xsVG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZTdGFydEluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICBjb25zdCBzY3JvbGxPZmZzZXQgPSB0aGlzLmZpeGVkVXBkYXRlQWxsRWxlbWVudHModGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uKTtcblxuICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50b3AgPSAtKHNjcm9sbE9mZnNldCkgKyAncHgnO1xuXG4gICAgICAgIHRoaXMuX3pvbmUub25TdGFibGUucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUodGhpcy5yZWNhbGNVcGRhdGVTaXplcy5iaW5kKHRoaXMpKTtcblxuICAgICAgICB0aGlzLmRjLmNoYW5nZURldGVjdG9yUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHByZXZTdGFydEluZGV4ICE9PSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlU2Nyb2xsKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEFtb3VudCA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnRbXCJzY3JvbGxMZWZ0XCJdO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2Nyb2xsQW1vdW50ID0gc2Nyb2xsQW1vdW50O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdXBkYXRlU2l6ZXMoKSB7XG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5pc0Nvbm5lY3RlZCkgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY3JvbGxhYmxlID0gdGhpcy5pc1Njcm9sbGFibGUoKTtcbiAgICAgICAgdGhpcy5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICB0aGlzLl9hcHBseUNoYW5nZXMoKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsT2Zmc2V0KCk7XG4gICAgICAgIGlmIChzY3JvbGxhYmxlICE9PSB0aGlzLmlzU2Nyb2xsYWJsZSgpKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbGJhclZpc2liaWxpdHlDaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudFNpemVDaGFuZ2UuZW1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBmaXhlZFVwZGF0ZUFsbEVsZW1lbnRzKGluU2Nyb2xsVG9wOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogdGhpcy5pZ3hGb3JPZi5sZW5ndGg7XG4gICAgICAgIGxldCBuZXdTdGFydCA9IHRoaXMuZ2V0SW5kZXhBdChpblNjcm9sbFRvcCwgdGhpcy5zaXplc0NhY2hlKTtcblxuICAgICAgICBpZiAobmV3U3RhcnQgKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSA+IGNvdW50KSB7XG4gICAgICAgICAgICBuZXdTdGFydCA9IGNvdW50IC0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwcmV2U3RhcnQgPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IGRpZmYgPSBuZXdTdGFydCAtIHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgdGhpcy5zdGF0ZS5zdGFydEluZGV4ID0gbmV3U3RhcnQ7XG5cbiAgICAgICAgaWYgKGRpZmYpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtQcmVsb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNSZW1vdGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIHJlY2FsY3VsYXRlIGFuZCBhcHBseSBwYWdlIHNpemUuXG4gICAgICAgICAgICAgICAgaWYgKGRpZmYgJiYgTWF0aC5hYnMoZGlmZikgPD0gTUFYX1BFUkZfU0NST0xMX0RJRkYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVBcHBseVNjcm9sbE5leHQocHJldlN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZUFwcGx5U2Nyb2xsUHJldihwcmV2U3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maXhlZEFwcGx5U2Nyb2xsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGluU2Nyb2xsVG9wIC0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFRoZSBmdW5jdGlvbiBhcHBsaWVzIGFuIG9wdGltaXplZCBzdGF0ZSBjaGFuZ2UgZm9yIHNjcm9sbGluZyBkb3duL3JpZ2h0IGVtcGxveWluZyBjb250ZXh0IGNoYW5nZSB3aXRoIHZpZXcgcmVhcnJhbmdlbWVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtb3ZlQXBwbHlTY3JvbGxOZXh0KHByZXZJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcHJldkluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgdGhpcy5zdGF0ZS5zdGFydEluZGV4IC0gcHJldkluZGV4O1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IgYXMgVmlld0NvbnRhaW5lclJlZjtcblxuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQgJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYlZpZXcgPSB0aGlzLl9lbWJlZGRlZFZpZXdzLnNoaWZ0KCk7XG4gICAgICAgICAgICBpZiAoIWVtYlZpZXcuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxGb2N1cyhlbWJWaWV3LnJvb3ROb2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpXG4gICAgICAgICAgICAgICAgICAgIHx8IGVtYlZpZXcucm9vdE5vZGVzWzBdLm5leHRFbGVtZW50U2libGluZyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlldyA9IGNvbnRhaW5lci5kZXRhY2goMCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dChlbWJWaWV3LmNvbnRleHQsIGkpO1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5pbnNlcnQodmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYlZpZXcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFRoZSBmdW5jdGlvbiBhcHBsaWVzIGFuIG9wdGltaXplZCBzdGF0ZSBjaGFuZ2UgZm9yIHNjcm9sbGluZyB1cC9sZWZ0IGVtcGxveWluZyBjb250ZXh0IGNoYW5nZSB3aXRoIHZpZXcgcmVhcnJhbmdlbWVudFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBtb3ZlQXBwbHlTY3JvbGxQcmV2KHByZXZJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuZGMuaW5zdGFuY2UuX3ZjciBhcyBWaWV3Q29udGFpbmVyUmVmO1xuICAgICAgICBmb3IgKGxldCBpID0gcHJldkluZGV4IC0gMTsgaSA+PSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYlZpZXcgPSB0aGlzLl9lbWJlZGRlZFZpZXdzLnBvcCgpO1xuICAgICAgICAgICAgaWYgKCFlbWJWaWV3LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRm9jdXMoZW1iVmlldy5yb290Tm9kZXMuZmluZChub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKVxuICAgICAgICAgICAgICAgICAgICB8fCBlbWJWaWV3LnJvb3ROb2Rlc1swXS5uZXh0RWxlbWVudFNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjb250YWluZXIuZGV0YWNoKGNvbnRhaW5lci5sZW5ndGggLSAxKTtcblxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGVtcGxhdGVDb250ZXh0KGVtYlZpZXcuY29udGV4dCwgaSk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmluc2VydCh2aWV3LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lbWJlZGRlZFZpZXdzLnVuc2hpZnQoZW1iVmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldENvbnRleHRJbmRleChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1JlbW90ZSA/IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuaWd4Rm9yT2YuaW5kZXhPZihpbnB1dCkgOiB0aGlzLmlneEZvck9mLmluZGV4T2YoaW5wdXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBGdW5jdGlvbiB3aGljaCB1cGRhdGVzIHRoZSBwYXNzZWQgY29udGV4dCBvZiBhbiBlbWJlZGRlZCB2aWV3IHdpdGggdGhlIHByb3ZpZGVkIGluZGV4XG4gICAgICogZnJvbSB0aGUgdmlldyBjb250YWluZXIuXG4gICAgICogT2Z0ZW4sIGNhbGxlZCB3aGlsZSBoYW5kbGluZyBhIHNjcm9sbCBldmVudC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlVGVtcGxhdGVDb250ZXh0KGNvbnRleHQ6IGFueSwgaW5kZXggPSAwKTogdm9pZCB7XG4gICAgICAgIGNvbnRleHQuJGltcGxpY2l0ID0gdGhpcy5pZ3hGb3JPZltpbmRleF07XG4gICAgICAgIGNvbnRleHQuaW5kZXggPSB0aGlzLmdldENvbnRleHRJbmRleCh0aGlzLmlneEZvck9mW2luZGV4XSk7XG4gICAgICAgIGNvbnRleHQuY291bnQgPSB0aGlzLmlneEZvck9mLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogVGhlIGZ1bmN0aW9uIGFwcGxpZXMgYW4gb3B0aW1pemVkIHN0YXRlIGNoYW5nZSB0aHJvdWdoIGNvbnRleHQgY2hhbmdlIGZvciBlYWNoIHZpZXdcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZml4ZWRBcHBseVNjcm9sbCgpOiB2b2lkIHtcbiAgICAgICAgbGV0IGogPSAwO1xuICAgICAgICBjb25zdCBlbmRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleCArIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4OyBpIDwgZW5kSW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYlZpZXcgPSB0aGlzLl9lbWJlZGRlZFZpZXdzW2orK107XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVRlbXBsYXRlQ29udGV4dChlbWJWaWV3LmNvbnRleHQsIGkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqXG4gICAgICogQ2xlYXJzIGZvY3VzIGluc2lkZSB0aGUgdmlydHVhbGl6ZWQgY29udGFpbmVyIG9uIHNtYWxsIHNjcm9sbCBzd2Fwcy5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2Nyb2xsRm9jdXMobm9kZT86IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gbm9kZS5nZXRSb290Tm9kZSgpIGFzIERvY3VtZW50IHwgU2hhZG93Um9vdDtcbiAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYXMgSFRNTEVsZW1lbnQ7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGZvY3VzIGluIGNhc2UgdGhlIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBpbnNpZGUgdGhlIHZpZXcgY29udGFpbmVyLlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgaGl0IGFuIGV4Y2VwdGlvbiB3aGlsZSBkb2luZyB0aGUgJ3NtYWxsJyBzY3JvbGxzIHN3YXBwaW5nLlxuICAgICAgICAvLyBGb3IgbW9yZSBpbmZvcm1hdGlvbjpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL05vZGUvcmVtb3ZlQ2hpbGRcbiAgICAgICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDMyMzkyXG4gICAgICAgIGlmIChub2RlICYmIG5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkIHdoZW4gc2Nyb2xsaW5nIGhvcml6b250YWxseVxuICAgICAqL1xuICAgIHByb3RlY3RlZCBvbkhTY3JvbGwoZXZlbnQpIHtcbiAgICAgICAgLyogaW4gY2VydGFpbiBzaXR1YXRpb25zIHRoaXMgbWF5IGJlIGNhbGxlZCB3aGVuIG5vIHNjcm9sbGJhciBpcyB2aXNpYmxlICovXG4gICAgICAgIGNvbnN0IGZpcnN0U2Nyb2xsQ2hpbGQgPSB0aGlzLnNjcm9sbENvbXBvbmVudC5uYXRpdmVFbGVtZW50LmNoaWxkcmVuLml0ZW0oMCkgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgIGlmICghcGFyc2VJbnQoZmlyc3RTY3JvbGxDaGlsZC5zdHlsZS53aWR0aCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9iU2Nyb2xsSW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNWaXJ0dWFsU2Nyb2xsUG9zaXRpb24oZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYlNjcm9sbEludGVybmFsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlN0YXJ0SW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGNvbnN0IHNjckxlZnQgPSBldmVudC50YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICAgICAgLy8gVXBkYXRpbmcgaG9yaXpvbnRhbCBjaHVua3NcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKE1hdGguYWJzKHRoaXMuX3ZpcnRTY3JvbGxQb3NpdGlvbikpO1xuICAgICAgICBpZiAoc2NyTGVmdCA8IDApIHtcbiAgICAgICAgICAgIC8vIFJUTFxuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IHNjcm9sbE9mZnNldCArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gLXNjcm9sbE9mZnNldCArICdweCc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fem9uZS5vblN0YWJsZS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSh0aGlzLnJlY2FsY1VwZGF0ZVNpemVzLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMuZGMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICBpZiAocHJldlN0YXJ0SW5kZXggIT09IHRoaXMuc3RhdGUuc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgdGhpcy5jaHVua0xvYWQuZW1pdCh0aGlzLnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgY2hhbmdlcyBpbiB0aGUgaXRlbXMgY29sbGVjdGlvbi5cbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBvYmplY3QgcmVmZXJlbmNlcyBhcmUgY29tcGFyZWQuIEhvd2V2ZXIgdGhpcyBjYW4gYmUgb3B0aW1pemVkIGlmIHlvdSBoYXZlIHVuaXF1ZSBpZGVudGlmaWVyXG4gICAgICogdmFsdWUgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZiB0aGUgb2JqZWN0IHJlZiBvciBpZiB5b3UgaGF2ZSBzb21lIG90aGVyIHByb3BlcnR5IHZhbHVlc1xuICAgICAqIGluIHRoZSBpdGVtIG9iamVjdCB0aGF0IHNob3VsZCBiZSB0cmFja2VkIGZvciBjaGFuZ2VzLlxuICAgICAqIFRoaXMgb3B0aW9uIGlzIHNpbWlsYXIgdG8gbmdGb3JUcmFja0J5LlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0cmFja0Z1bmMgPSB0aGlzLnBhcmVudFZpcnREaXIuaWd4Rm9yVHJhY2tCeTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaWd4Rm9yVHJhY2tCeSgpOiBUcmFja0J5RnVuY3Rpb248VD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2tCeUZuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGZ1bmN0aW9uIHVzZWQgdG8gdHJhY2sgY2hhbmdlcyBpbiB0aGUgaXRlbXMgY29sbGVjdGlvbi5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBzZXQgaW4gc2NlbmFyaW9zIHdoZXJlIHlvdSB3YW50IHRvIG9wdGltaXplIG9yXG4gICAgICogY3VzdG9taXplIHRoZSB0cmFja2luZyBvZiBjaGFuZ2VzIGZvciB0aGUgaXRlbXMgaW4gdGhlIGNvbGxlY3Rpb24uXG4gICAgICogVGhlIGlneEZvclRyYWNrQnkgZnVuY3Rpb24gdGFrZXMgdGhlIGluZGV4IGFuZCB0aGUgY3VycmVudCBpdGVtIGFzIGFyZ3VtZW50cyBhbmQgbmVlZHMgdG8gcmV0dXJuIHRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBpdGVtLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLnBhcmVudFZpcnREaXIuaWd4Rm9yVHJhY2tCeSA9IChpbmRleCwgaXRlbSkgPT4ge1xuICAgICAqICAgICAgcmV0dXJuIGl0ZW0uaWQgKyBpdGVtLndpZHRoO1xuICAgICAqIH07XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCBpZ3hGb3JUcmFja0J5KGZuOiBUcmFja0J5RnVuY3Rpb248VD4pIHtcbiAgICAgICAgdGhpcy5fdHJhY2tCeUZuID0gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfYXBwbHlDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBwcmV2Q2h1bmtTaXplID0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIHRoaXMuYXBwbHlDaHVua1NpemVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjU2Nyb2xsQmFyU2l6ZSgpO1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZiAmJiB0aGlzLmlneEZvck9mLmxlbmd0aCAmJiB0aGlzLmRjKSB7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXdDb3B5ID0gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5fZW1iZWRkZWRWaWV3cyk7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHRoaXMuc3RhdGUuc3RhcnRJbmRleDtcbiAgICAgICAgICAgIGxldCBlbmRJbmRleCA9IHRoaXMuc3RhdGUuY2h1bmtTaXplICsgdGhpcy5zdGF0ZS5zdGFydEluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleCAmJiB0aGlzLmlneEZvck9mW2ldICE9PSB1bmRlZmluZWQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtYlZpZXcgPSBlbWJlZGRlZFZpZXdDb3B5LnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVUZW1wbGF0ZUNvbnRleHQoZW1iVmlldy5jb250ZXh0LCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2Q2h1bmtTaXplICE9PSB0aGlzLnN0YXRlLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtMb2FkLmVtaXQodGhpcy5zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9jYWxjTWF4QnJvd3NlclNpemUoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCF0aGlzLnBsYXRmb3JtVXRpbC5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpdiA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZGl2LnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGNvbnN0IGRpciA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgICBzdHlsZVtkaXJdID0gJzk5OTk5OTk5OTk5OTk5OTlweCc7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICBjb25zdCBzaXplID0gTWF0aC5hYnMoZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2Rpcl0pO1xuICAgICAgICB0aGlzLmRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoZGl2KTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJlY2FsY3VsYXRlcyB0aGUgY2h1bmtTaXplIGJhc2VkIG9uIGN1cnJlbnQgc3RhcnRJbmRleCBhbmQgcmV0dXJucyB0aGUgbmV3IHNpemUuXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIHRoaXMuc3RhdGUuc3RhcnRJbmRleCBpcyB1cGRhdGVkLCBub3QgYmVmb3JlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfY2FsY3VsYXRlQ2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGxldCBjaHVua1NpemUgPSAwO1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JDb250YWluZXJTaXplICE9PSBudWxsICYmIHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2l6ZXNDYWNoZSB8fCB0aGlzLnNpemVzQ2FjaGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0U2l6ZXNDYWNoZSh0aGlzLmlneEZvck9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IHRoaXMuX2NhbGNNYXhDaHVua1NpemUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlneEZvck9mICYmIGNodW5rU2l6ZSA+IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtTaXplID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgICAgIGNodW5rU2l6ZSA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaHVua1NpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFbGVtZW50KHZpZXdyZWYsIG5vZGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGVsZW0gPSB2aWV3cmVmLmVsZW1lbnQubmF0aXZlRWxlbWVudC5wYXJlbnROb2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5vZGVOYW1lKTtcbiAgICAgICAgcmV0dXJuIGVsZW0ubGVuZ3RoID4gMCA/IGVsZW1bMF0gOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgaW5pdFNpemVzQ2FjaGUoaXRlbXM6IFUpOiBudW1iZXIge1xuICAgICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNpemVQcm9wTmFtZSB8fCAnaGVpZ2h0JztcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLnNpemVzQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlID0gW107XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZS5wdXNoKDApO1xuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuaXNSZW1vdGUgPyB0aGlzLnRvdGFsSXRlbUNvdW50IDogaXRlbXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGk7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplID0gdGhpcy5fZ2V0SXRlbVNpemUoaXRlbXNbaV0sIGRpbWVuc2lvbik7XG4gICAgICAgICAgICB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUucHVzaChzaXplKTtcbiAgICAgICAgICAgIHRvdGFsU2l6ZSArPSBzaXplO1xuICAgICAgICAgICAgdGhpcy5zaXplc0NhY2hlLnB1c2godG90YWxTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWxTaXplO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfdXBkYXRlU2l6ZUNhY2hlKCkge1xuICAgICAgICBpZiAodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZEhlaWdodCA9IHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZS5sZW5ndGggPiAwID8gdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlLnJlZHVjZSgoYWNjLCB2YWwpID0+IGFjYyArIHZhbCkgOiAwO1xuICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuXG4gICAgICAgIGNvbnN0IGRpZmYgPSBvbGRIZWlnaHQgLSBuZXdIZWlnaHQ7XG4gICAgICAgIHRoaXMuX2FkanVzdFNjcm9sbFBvc2l0aW9uQWZ0ZXJTaXplQ2hhbmdlKGRpZmYpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX2NhbGNNYXhDaHVua1NpemUoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IG1heExlbmd0aCA9IDA7XG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICBpZiAoIWF2YWlsYWJsZVNpemUpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/XG4gICAgICAgICAgICB0aGlzLmlneEZvclNpemVQcm9wTmFtZSA6ICdoZWlnaHQnO1xuICAgICAgICBjb25zdCByZWR1Y2VyID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50SXRlbSkgPT4gYWNjdW11bGF0b3IgKyB0aGlzLl9nZXRJdGVtU2l6ZShjdXJyZW50SXRlbSwgZGltZW5zaW9uKTtcbiAgICAgICAgZm9yIChpOyBpIDwgdGhpcy5pZ3hGb3JPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGl0ZW06IFQgfCB7IHZhbHVlOiBULCBoZWlnaHQ6IG51bWJlciB9ID0gdGhpcy5pZ3hGb3JPZltpXTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb24gPT09ICdoZWlnaHQnKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IHsgdmFsdWU6IHRoaXMuaWd4Rm9yT2ZbaV0sIGhlaWdodDogdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlW2ldIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaXplID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlW2ldIDpcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXRJdGVtU2l6ZShpdGVtLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgc3VtID0gYXJyLnJlZHVjZShyZWR1Y2VyLCBzaXplKTtcbiAgICAgICAgICAgIGlmIChzdW0gPCBhdmFpbGFibGVTaXplKSB7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goaXRlbSk7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gYXJyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlYWNoZWQgZW5kIHdpdGhvdXQgZXhjZWVkaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGluY2x1ZGUgcHJldiBpdGVtcyB1bnRpbCBzaXplIGlzIGZpbGxlZCBvciBmaXJzdCBpdGVtIGlzIHJlYWNoZWQuXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJJdGVtID0gZGltZW5zaW9uID09PSAnaGVpZ2h0JyA/IGFyclswXS52YWx1ZSA6IGFyclswXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXZJbmRleCA9IHRoaXMuaWd4Rm9yT2YuaW5kZXhPZihjdXJJdGVtKSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcmV2SW5kZXggPj0gMCAmJiBzdW0gPD0gYXZhaWxhYmxlU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VySXRlbSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgPyBhcnJbMF0udmFsdWUgOiBhcnJbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2SW5kZXggPSB0aGlzLmlneEZvck9mLmluZGV4T2YoY3VySXRlbSkgLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkl0ZW0gPSB0aGlzLmlneEZvck9mW3ByZXZJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IGRpbWVuc2lvbiA9PT0gJ2hlaWdodCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZVtwcmV2SW5kZXhdIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJzZUludChwcmV2SXRlbVtkaW1lbnNpb25dLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gPSBhcnIucmVkdWNlKHJlZHVjZXIsIHByZXZTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci51bnNoaWZ0KHByZXZJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGFyci5sZW5ndGggKyAxO1xuICAgICAgICAgICAgICAgIGFyci5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1heExlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4TGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0SW5kZXhBdChsZWZ0LCBzZXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgbGV0IGVuZCA9IHNldC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXJ0IDw9IGVuZCkge1xuICAgICAgICAgICAgY29uc3QgbWlkSWR4ID0gTWF0aC5mbG9vcigoc3RhcnQgKyBlbmQpIC8gMik7XG4gICAgICAgICAgICBjb25zdCBtaWRMZWZ0ID0gc2V0W21pZElkeF07XG4gICAgICAgICAgICBjb25zdCBjbXAgPSBsZWZ0IC0gbWlkTGVmdDtcbiAgICAgICAgICAgIGlmIChjbXAgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBtaWRJZHggKyAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gbWlkSWR4IC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1pZElkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5kO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfcmVjYWxjU2Nyb2xsQmFyU2l6ZShjb250YWluZXJTaXplSW5mbyA9IG51bGwpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmlzUmVtb3RlID8gdGhpcy50b3RhbEl0ZW1Db3VudCA6ICh0aGlzLmlneEZvck9mID8gdGhpcy5pZ3hGb3JPZi5sZW5ndGggOiAwKTtcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5ub3RWaXJ0dWFsID0gISh0aGlzLmlneEZvckNvbnRhaW5lclNpemUgJiYgdGhpcy5kYyAmJiB0aGlzLnN0YXRlLmNodW5rU2l6ZSA8IGNvdW50KTtcbiAgICAgICAgY29uc3Qgc2Nyb2xsYWJsZSA9IGNvbnRhaW5lclNpemVJbmZvID8gdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA+IGNvbnRhaW5lclNpemVJbmZvLnByZXZTaXplIDogdGhpcy5pc1Njcm9sbGFibGUoKTtcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAgICAgY29uc3QgdG90YWxXaWR0aCA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApID4gMCA/IHRoaXMuX2NhbGNTaXplKCkgOiAwO1xuICAgICAgICAgICAgaWYgKHRvdGFsV2lkdGggPD0gcGFyc2VJbnQodGhpcy5pZ3hGb3JDb250YWluZXJTaXplLCAxMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLmlneEZvckNvbnRhaW5lclNpemUgKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQuc2l6ZSA9IHRvdGFsV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsSGVpZ2h0ID0gdGhpcy5fY2FsY1NpemUoKTtcbiAgICAgICAgICAgIGlmICh0b3RhbEhlaWdodCA8PSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5oZWlnaHQgPSBwYXJzZUludCh0aGlzLmlneEZvckNvbnRhaW5lclNpemUsIDEwKSArICdweCc7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplID0gdG90YWxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbGFibGUgIT09IHRoaXMuaXNTY3JvbGxhYmxlKCkpIHtcbiAgICAgICAgICAgIC8vIHNjcm9sbGJhciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGJhclZpc2liaWxpdHlDaGFuZ2VkLmVtaXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBfY2FsY1NpemUoKTogbnVtYmVyIHtcbiAgICAgICAgbGV0IHNpemU7XG4gICAgICAgIGlmICh0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUgJiYgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmluaXRTaXplc0NhY2hlKHRoaXMuaWd4Rm9yT2YpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ZpcnRTaXplID0gc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPiB0aGlzLl9tYXhTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl92aXJ0UmF0aW8gPSBzaXplIC8gdGhpcy5fbWF4U2l6ZTtcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLl9tYXhTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBfcmVjYWxjT25Db250YWluZXJDaGFuZ2UoY29udGFpbmVyU2l6ZUluZm8gPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHByZXZDaHVua1NpemUgPSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgdGhpcy5hcHBseUNodW5rU2l6ZUNoYW5nZSgpO1xuICAgICAgICB0aGlzLl9yZWNhbGNTY3JvbGxCYXJTaXplKGNvbnRhaW5lclNpemVJbmZvKTtcbiAgICAgICAgaWYgKHByZXZDaHVua1NpemUgIT09IHRoaXMuc3RhdGUuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBmcm9tIHRoZSBlbWJlZGRlZCB2aWV3cyBhbmQgdXBkYXRlcyBjaHVua1NpemUuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJlbW92ZUxhc3RFbGVtKCkge1xuICAgICAgICBjb25zdCBvbGRFbGVtID0gdGhpcy5fZW1iZWRkZWRWaWV3cy5wb3AoKTtcbiAgICAgICAgdGhpcy5iZWZvcmVWaWV3RGVzdHJveWVkLmVtaXQob2xkRWxlbSk7XG4gICAgICAgIC8vIGFsc28gZGV0YWNoIGZyb20gVmlld0NvbnRhaW5lclJlZiB0byBtYWtlIGFic29sdXRlbHkgc3VyZSB0aGlzIGlzIHJlbW92ZWQgZnJvbSB0aGUgdmlldyBjb250YWluZXIuXG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3Zjci5kZXRhY2godGhpcy5kYy5pbnN0YW5jZS5fdmNyLmxlbmd0aCAtIDEpO1xuICAgICAgICBvbGRFbGVtLmRlc3Ryb3koKTtcblxuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZS0tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBJZiB0aGVyZSBleGlzdHMgYW4gZWxlbWVudCB0aGF0IHdlIGNhbiBjcmVhdGUgZW1iZWRkZWQgdmlldyBmb3IgY3JlYXRlcyBpdCwgYXBwZW5kcyBpdCBhbmQgdXBkYXRlcyBjaHVua1NpemVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWRkTGFzdEVsZW0oKSB7XG4gICAgICAgIGxldCBlbGVtSW5kZXggPSB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVtb3RlICYmICF0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZWxlbUluZGV4ID49IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICBlbGVtSW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5pZ3hGb3JPZltlbGVtSW5kZXhdO1xuICAgICAgICBjb25zdCBlbWJlZGRlZFZpZXcgPSB0aGlzLmRjLmluc3RhbmNlLl92Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KFxuICAgICAgICAgICAgdGhpcy5fdGVtcGxhdGUsXG4gICAgICAgICAgICBuZXcgSWd4Rm9yT2ZDb250ZXh0PFQsIFU+KGlucHV0LCB0aGlzLmlneEZvck9mLCB0aGlzLmdldENvbnRleHRJbmRleChpbnB1dCksIHRoaXMuaWd4Rm9yT2YubGVuZ3RoKVxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMuX2VtYmVkZGVkVmlld3MucHVzaChlbWJlZGRlZFZpZXcpO1xuICAgICAgICB0aGlzLnN0YXRlLmNodW5rU2l6ZSsrO1xuXG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWNhbGN1bGF0ZXMgY2h1bmtTaXplIGFuZCBhZGRzL3JlbW92ZXMgZWxlbWVudHMgaWYgbmVlZCBkdWUgdG8gdGhlIGNoYW5nZS5cbiAgICAgKiB0aGlzLnN0YXRlLmNodW5rU2l6ZSBpcyB1cGRhdGVkIGluIEBhZGRMYXN0RWxlbSgpIG9yIEByZW1vdmVMYXN0RWxlbSgpXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGFwcGx5Q2h1bmtTaXplQ2hhbmdlKCkge1xuICAgICAgICBjb25zdCBjaHVua1NpemUgPSB0aGlzLmlzUmVtb3RlID8gKHRoaXMuaWd4Rm9yT2YgPyB0aGlzLmlneEZvck9mLmxlbmd0aCA6IDApIDogdGhpcy5fY2FsY3VsYXRlQ2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChjaHVua1NpemUgPiB0aGlzLnN0YXRlLmNodW5rU2l6ZSkge1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGNodW5rU2l6ZSAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExhc3RFbGVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmtTaXplIDwgdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSB0aGlzLnN0YXRlLmNodW5rU2l6ZSAtIGNodW5rU2l6ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMYXN0RWxlbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9jYWxjVmlydHVhbFNjcm9sbFBvc2l0aW9uKHNjcm9sbFBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IHBhcnNlSW50KHRoaXMuaWd4Rm9yQ29udGFpbmVyU2l6ZSwgMTApO1xuICAgICAgICBjb25zdCBtYXhSZWFsU2Nyb2xsUG9zaXRpb24gPSB0aGlzLnNjcm9sbENvbXBvbmVudC5zaXplIC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgY29uc3QgcmVhbFBlcmNlbnRTY3JvbGxlZCA9IG1heFJlYWxTY3JvbGxQb3NpdGlvbiAhPT0gMCA/IHNjcm9sbFBvc2l0aW9uIC8gbWF4UmVhbFNjcm9sbFBvc2l0aW9uIDogMDtcbiAgICAgICAgY29uc3QgbWF4VmlydFNjcm9sbCA9IHRoaXMuX3ZpcnRTaXplIC0gY29udGFpbmVyU2l6ZTtcbiAgICAgICAgdGhpcy5fdmlydFNjcm9sbFBvc2l0aW9uID0gcmVhbFBlcmNlbnRTY3JvbGxlZCAqIG1heFZpcnRTY3JvbGw7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9nZXRJdGVtU2l6ZShpdGVtLCBkaW1lbnNpb246IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IGRpbSA9IGl0ZW0gPyBpdGVtW2RpbWVuc2lvbl0gOiBudWxsO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGRpbSA9PT0gJ251bWJlcicgPyBkaW0gOiBwYXJzZUludCh0aGlzLmlneEZvckl0ZW1TaXplLCAxMCkgfHwgMDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX3VwZGF0ZVNjcm9sbE9mZnNldCgpIHtcbiAgICAgICAgbGV0IHNjcm9sbE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50U2Nyb2xsID0gdGhpcy5zY3JvbGxQb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuX3ZpcnRSYXRpbyAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1ZpcnR1YWxTY3JvbGxQb3NpdGlvbih0aGlzLnNjcm9sbFBvc2l0aW9uKTtcbiAgICAgICAgICAgIGN1cnJlbnRTY3JvbGwgPSB0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Nyb2xsID0gdGhpcy5zY3JvbGxDb21wb25lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgc2Nyb2xsT2Zmc2V0ID0gc2Nyb2xsICYmIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNpemUgP1xuICAgICAgICBjdXJyZW50U2Nyb2xsIC0gdGhpcy5zaXplc0NhY2hlW3RoaXMuc3RhdGUuc3RhcnRJbmRleF0gOiAwO1xuICAgICAgICBjb25zdCBkaXIgPSB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGVbZGlyXSA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9hZGp1c3RTY3JvbGxQb3NpdGlvbkFmdGVyU2l6ZUNoYW5nZShzaXplRGlmZikge1xuICAgICAgICAvLyBpZiBkYXRhIGhhcyBiZWVuIGNoYW5nZWQgd2hpbGUgY29udGFpbmVyIGlzIHNjcm9sbGVkXG4gICAgICAgIC8vIHNob3VsZCB1cGRhdGUgc2Nyb2xsIHRvcC9sZWZ0IGFjY29yZGluZyB0byBjaGFuZ2Ugc28gdGhhdCBzYW1lIHN0YXJ0SW5kZXggaXMgaW4gdmlld1xuICAgICAgICBpZiAoTWF0aC5hYnMoc2l6ZURpZmYpID4gMCAmJiB0aGlzLnNjcm9sbFBvc2l0aW9uID4gMCkge1xuICAgICAgICAgICAgdGhpcy5yZWNhbGNVcGRhdGVTaXplcygpO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID9cbiAgICAgICAgICAgICAgICBwYXJzZUludCh0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0LCAxMCkgOlxuICAgICAgICAgICAgICAgIHBhcnNlSW50KHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCwgMTApO1xuICAgICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMuc2l6ZXNDYWNoZVt0aGlzLnN0YXRlLnN0YXJ0SW5kZXhdIC0gb2Zmc2V0O1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvbiA9IG5ld1NpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGxQb3NpdGlvbiAhPT0gbmV3U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29tcG9uZW50LnNjcm9sbEFtb3VudCA9IG5ld1NpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGdldE1hcmdpbihub2RlLCBkaW1lbnNpb246IHN0cmluZyk6IG51bWJlciB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgICAgICBpZiAoZGltZW5zaW9uID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydtYXJnaW5Ub3AnXSkgK1xuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQoc3R5bGVzWydtYXJnaW5Cb3R0b20nXSkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ21hcmdpbkxlZnQnXSkgK1xuICAgICAgICAgICAgcGFyc2VGbG9hdChzdHlsZXNbJ21hcmdpblJpZ2h0J10pIHx8IDA7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgZ2V0VHlwZU5hbWVGb3JEZWJ1Z2dpbmcgPSAodHlwZTogYW55KTogc3RyaW5nID0+IHR5cGUubmFtZSB8fCB0eXBlb2YgdHlwZTtcblxuZXhwb3J0IGludGVyZmFjZSBJRm9yT2ZTdGF0ZSBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICBzdGFydEluZGV4PzogbnVtYmVyO1xuICAgIGNodW5rU2l6ZT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJRm9yT2ZEYXRhQ2hhbmdpbmdFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgY29udGFpbmVyU2l6ZTogbnVtYmVyO1xuICAgIHN0YXRlOiBJRm9yT2ZTdGF0ZTtcbn1cblxuZXhwb3J0IGNsYXNzIElneEdyaWRGb3JPZkNvbnRleHQ8VCwgVSBleHRlbmRzIFRbXSA9IFRbXT4gZXh0ZW5kcyBJZ3hGb3JPZkNvbnRleHQ8VCwgVT4ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAkaW1wbGljaXQ6IFQsXG4gICAgICAgIHB1YmxpYyBpZ3hHcmlkRm9yT2Y6IFUsXG4gICAgICAgIGluZGV4OiBudW1iZXIsXG4gICAgICAgIGNvdW50OiBudW1iZXJcbiAgICApIHtcbiAgICAgICAgc3VwZXIoJGltcGxpY2l0LCBpZ3hHcmlkRm9yT2YsIGluZGV4LCBjb3VudCk7XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hHcmlkRm9yXVtpZ3hHcmlkRm9yT2ZdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneEdyaWRGb3JPZkRpcmVjdGl2ZTxULCBVIGV4dGVuZHMgVFtdID0gVFtdPiBleHRlbmRzIElneEZvck9mRGlyZWN0aXZlPFQsIFU+IGltcGxlbWVudHMgT25Jbml0LCBPbkNoYW5nZXMsIERvQ2hlY2sge1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBpZ3hHcmlkRm9yT2YodmFsdWU6IFUgJiBUW10gfCBudWxsKSB7XG4gICAgICAgIHRoaXMuaWd4Rm9yT2YgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGlneEdyaWRGb3JPZigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWd4Rm9yT2Y7XG4gICAgfVxuXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIGlneEdyaWRGb3JPZlVuaXF1ZVNpemVDYWNoZSA9IGZhbHNlO1xuXG4gICAgQElucHV0KHsgdHJhbnNmb3JtOiBib29sZWFuQXR0cmlidXRlIH0pXG4gICAgcHVibGljIGlneEdyaWRGb3JPZlZhcmlhYmxlU2l6ZXMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgc2l6ZXNDYWNoZSgpOiBudW1iZXJbXSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlneEdyaWRGb3JPZlVuaXF1ZVNpemVDYWNoZSB8fCB0aGlzLnN5bmNTZXJ2aWNlLmlzTWFzdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVzQ2FjaGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jU2VydmljZS5zaXplc0NhY2hlKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpemVzQ2FjaGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBzZXQgc2l6ZXNDYWNoZSh2YWx1ZTogbnVtYmVyW10pIHtcbiAgICAgICAgdGhpcy5fc2l6ZXNDYWNoZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgaXRlbXNEaW1lbnNpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlneEZvclNpemVQcm9wTmFtZSB8fCAnaGVpZ2h0JztcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgcmVjYWxjVXBkYXRlU2l6ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEdyaWRGb3JPZlZhcmlhYmxlU2l6ZXMgJiYgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgICAgICAgc3VwZXIucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQW4gZXZlbnQgdGhhdCBpcyBlbWl0dGVkIGFmdGVyIGRhdGEgaGFzIGJlZW4gY2hhbmdlZCBidXQgYmVmb3JlIHRoZSB2aWV3IGlzIHJlZnJlc2hlZFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkYXRhQ2hhbmdpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncz4oKTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBfdmlld0NvbnRhaW5lcjogVmlld0NvbnRhaW5lclJlZixcbiAgICAgICAgX3RlbXBsYXRlOiBUZW1wbGF0ZVJlZjxOZ0Zvck9mQ29udGV4dDxUPj4sXG4gICAgICAgIF9kaWZmZXJzOiBJdGVyYWJsZURpZmZlcnMsXG4gICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIF96b25lOiBOZ1pvbmUsXG4gICAgICAgIF9wbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCxcbiAgICAgICAgQEluamVjdChET0NVTUVOVCkgX2RvY3VtZW50OiBhbnksXG4gICAgICAgIHN5bmNTY3JvbGxTZXJ2aWNlOiBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlLFxuICAgICAgICBwcm90ZWN0ZWQgc3luY1NlcnZpY2U6IElneEZvck9mU3luY1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoX3ZpZXdDb250YWluZXIsIF90ZW1wbGF0ZSwgX2RpZmZlcnMsIGNkciwgX3pvbmUsIHN5bmNTY3JvbGxTZXJ2aWNlLCBfcGxhdGZvcm1VdGlsLCBfZG9jdW1lbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQXNzZXJ0cyB0aGUgY29ycmVjdCB0eXBlIG9mIHRoZSBjb250ZXh0IGZvciB0aGUgdGVtcGxhdGUgdGhhdCBgSWd4R3JpZEZvck9mRGlyZWN0aXZlYCB3aWxsIHJlbmRlci5cbiAgICAgKlxuICAgICAqIFRoZSBwcmVzZW5jZSBvZiB0aGlzIG1ldGhvZCBpcyBhIHNpZ25hbCB0byB0aGUgSXZ5IHRlbXBsYXRlIHR5cGUtY2hlY2sgY29tcGlsZXIgdGhhdCB0aGVcbiAgICAgKiBgSWd4R3JpZEZvck9mRGlyZWN0aXZlYCBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZSByZW5kZXJzIGl0cyB0ZW1wbGF0ZSB3aXRoIGEgc3BlY2lmaWMgY29udGV4dCB0eXBlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgb3ZlcnJpZGUgbmdUZW1wbGF0ZUNvbnRleHRHdWFyZDxULCBVIGV4dGVuZHMgVFtdPihkaXI6IElneEdyaWRGb3JPZkRpcmVjdGl2ZTxULCBVPiwgY3R4OiBhbnkpOlxuICAgICAgICBjdHggaXMgSWd4R3JpZEZvck9mQ29udGV4dDxULCBVPiB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgIHN1cGVyLm5nT25Jbml0KCk7XG4gICAgICAgIHRoaXMucmVtb3ZlU2Nyb2xsRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgICAgICBjb25zdCBmb3JPZiA9ICdpZ3hHcmlkRm9yT2YnO1xuICAgICAgICB0aGlzLnN5bmNTZXJ2aWNlLnNldE1hc3Rlcih0aGlzKTtcbiAgICAgICAgaWYgKGZvck9mIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlc1tmb3JPZl0uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kaWZmZXIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaWZmZXIgPSB0aGlzLl9kaWZmZXJzLmZpbmQodmFsdWUpLmNyZWF0ZSh0aGlzLmlneEZvclRyYWNrQnkpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgYENhbm5vdCBmaW5kIGEgZGlmZmVyIHN1cHBvcnRpbmcgb2JqZWN0IFwiJHt2YWx1ZX1cIiBvZiB0eXBlIFwiJHtnZXRUeXBlTmFtZUZvckRlYnVnZ2luZyh2YWx1ZSl9XCIuXG4gICAgICAgICAgICAgICAgICAgICBOZ0ZvciBvbmx5IHN1cHBvcnRzIGJpbmRpbmcgdG8gSXRlcmFibGVzIHN1Y2ggYXMgQXJyYXlzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBjYXNlIGNvbGxlY3Rpb24gaGFzIGNoYW5nZXMsIHJlc2V0IHN5bmMgc2VydmljZVxuICAgICAgICAgICAgICAgIHRoaXMuc3luY1NlcnZpY2Uuc2V0TWFzdGVyKHRoaXMsIHRoaXMuaWd4R3JpZEZvck9mVW5pcXVlU2l6ZUNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0SXRlbVNpemUgPSAnaWd4Rm9ySXRlbVNpemUnO1xuICAgICAgICBpZiAoZGVmYXVsdEl0ZW1TaXplIGluIGNoYW5nZXMgJiYgIWNoYW5nZXNbZGVmYXVsdEl0ZW1TaXplXS5maXJzdENoYW5nZSAmJlxuICAgICAgICAgICAgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiB0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgZGVmYXVsdCBpdGVtIHNpemUgY2hhbmdlZC5cbiAgICAgICAgICAgIHRoaXMuaW5pdFNpemVzQ2FjaGUodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGFpbmVyU2l6ZSA9ICdpZ3hGb3JDb250YWluZXJTaXplJztcbiAgICAgICAgaWYgKGNvbnRhaW5lclNpemUgaW4gY2hhbmdlcyAmJiAhY2hhbmdlc1tjb250YWluZXJTaXplXS5maXJzdENoYW5nZSAmJiB0aGlzLmlneEZvck9mKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2U2l6ZSA9IHBhcnNlSW50KGNoYW5nZXNbY29udGFpbmVyU2l6ZV0ucHJldmlvdXNWYWx1ZSwgMTApO1xuICAgICAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHBhcnNlSW50KGNoYW5nZXNbY29udGFpbmVyU2l6ZV0uY3VycmVudFZhbHVlLCAxMCk7XG4gICAgICAgICAgICB0aGlzLl9yZWNhbGNPbkNvbnRhaW5lckNoYW5nZSh7cHJldlNpemUsIG5ld1NpemV9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYXNzdW1lTWFzdGVyKCk6IHZvaWQge1xuICAgICAgICB0aGlzLl9zaXplc0NhY2hlID0gdGhpcy5zeW5jU2VydmljZS5zaXplc0NhY2hlKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgICAgICB0aGlzLnN5bmNTZXJ2aWNlLnNldE1hc3Rlcih0aGlzLCB0cnVlKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgbmdEb0NoZWNrKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlmZmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gdGhpcy5fZGlmZmVyLmRpZmYodGhpcy5pZ3hGb3JPZik7XG4gICAgICAgICAgICBpZiAoY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IElGb3JPZkRhdGFDaGFuZ2luZ0V2ZW50QXJncyA9IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyU2l6ZTogdGhpcy5pZ3hGb3JDb250YWluZXJTaXplLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGhpcy5zdGF0ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdpbmcuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICAvLyAgcmUtaW5pdCBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaWd4Rm9yT2YpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JPZiA9IFtdIGFzIFU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIHdlIG5lZWQgdG8gcmVzZXQgdGhlIG1hc3RlciBkaXIgaWYgYWxsIHJvd3MgYXJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAoZS5nLiBiZWNhdXNlIG9mIGZpbHRlcmluZyk7IGlmIGFsbCBjb2x1bW5zIGFyZSBoaWRkZW4sIHJvd3MgYXJlXG4gICAgICAgICAgICAgICAgc3RpbGwgcmVuZGVyZWQgZW1wdHksIHNvIHdlIHNob3VsZCBub3QgcmVzZXQgbWFzdGVyICovXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlneEZvck9mLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3luY1NlcnZpY2UucmVzZXRNYXN0ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jU2VydmljZS5zZXRNYXN0ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5pZ3hGb3JDb250YWluZXJTaXplID0gYXJncy5jb250YWluZXJTaXplO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemVEaWZmID0gdGhpcy5fdXBkYXRlU2l6ZUNhY2hlKGNoYW5nZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgIGlmIChzaXplRGlmZikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGp1c3RTY3JvbGxQb3NpdGlvbkFmdGVyU2l6ZUNoYW5nZShzaXplRGlmZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE9mZnNldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBvblNjcm9sbChldmVudCkge1xuICAgICAgICBpZiAoIXBhcnNlSW50KHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUuaGVpZ2h0LCAxMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2JTY3JvbGxJbnRlcm5hbCkge1xuICAgICAgICAgICAgdGhpcy5fY2FsY1ZpcnR1YWxTY3JvbGxQb3NpdGlvbihldmVudC50YXJnZXQuc2Nyb2xsVG9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2JTY3JvbGxJbnRlcm5hbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjcm9sbE9mZnNldCA9IHRoaXMuZml4ZWRVcGRhdGVBbGxFbGVtZW50cyh0aGlzLl92aXJ0U2Nyb2xsUG9zaXRpb24pO1xuXG4gICAgICAgIHRoaXMuZGMuaW5zdGFuY2UuX3ZpZXdDb250YWluZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRvcCA9IC0oc2Nyb2xsT2Zmc2V0KSArICdweCc7XG5cbiAgICAgICAgdGhpcy5fem9uZS5vblN0YWJsZS5waXBlKGZpcnN0KCkpLnN1YnNjcmliZSh0aGlzLnJlY2FsY1VwZGF0ZVNpemVzLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmNkci5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgb25IU2Nyb2xsKHNjcm9sbEFtb3VudCkge1xuICAgICAgICAvKiBpbiBjZXJ0YWluIHNpdHVhdGlvbnMgdGhpcyBtYXkgYmUgY2FsbGVkIHdoZW4gbm8gc2Nyb2xsYmFyIGlzIHZpc2libGUgKi9cbiAgICAgICAgY29uc3QgZmlyc3RTY3JvbGxDaGlsZCA9IHRoaXMuc2Nyb2xsQ29tcG9uZW50Lm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4uaXRlbSgwKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgaWYgKCF0aGlzLnNjcm9sbENvbXBvbmVudCB8fCAhcGFyc2VJbnQoZmlyc3RTY3JvbGxDaGlsZC5zdHlsZS53aWR0aCwgMTApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRpbmcgaG9yaXpvbnRhbCBjaHVua3NcbiAgICAgICAgY29uc3Qgc2Nyb2xsT2Zmc2V0ID0gdGhpcy5maXhlZFVwZGF0ZUFsbEVsZW1lbnRzKE1hdGguYWJzKHNjcm9sbEFtb3VudCkpO1xuICAgICAgICBpZiAoc2Nyb2xsQW1vdW50IDwgMCkge1xuICAgICAgICAgICAgLy8gUlRMXG4gICAgICAgICAgICB0aGlzLmRjLmluc3RhbmNlLl92aWV3Q29udGFpbmVyLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gc2Nyb2xsT2Zmc2V0ICsgJ3B4JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIExUUlxuICAgICAgICAgICAgdGhpcy5kYy5pbnN0YW5jZS5fdmlld0NvbnRhaW5lci5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUubGVmdCA9IC1zY3JvbGxPZmZzZXQgKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldEl0ZW1TaXplKGl0ZW0pIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLmlneEZvclNpemVQcm9wTmFtZSB8fCAnaGVpZ2h0JztcbiAgICAgICAgaWYgKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLl9nZXRJdGVtU2l6ZShpdGVtLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5zdW1tYXJpZXMpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gaXRlbS5tYXg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5ncm91cHMgJiYgaXRlbS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gaXRlbS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaXplID0gcGFyc2VJbnQoaXRlbVtkaW1lbnNpb25dLCAxMCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgb3ZlcnJpZGUgaW5pdFNpemVzQ2FjaGUoaXRlbXM6IFUpOiBudW1iZXIge1xuICAgICAgICBpZiAoIXRoaXMuc3luY1NlcnZpY2UuaXNNYXN0ZXIodGhpcykgJiYgdGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnKSB7XG4gICAgICAgICAgICBjb25zdCBtYXN0ZXJTaXplc0NhY2hlID0gdGhpcy5zeW5jU2VydmljZS5zaXplc0NhY2hlKHRoaXMuaWd4Rm9yU2Nyb2xsT3JpZW50YXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIG1hc3RlclNpemVzQ2FjaGVbbWFzdGVyU2l6ZXNDYWNoZS5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdG90YWxTaXplID0gMDtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZSA9IFtdO1xuICAgICAgICB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUgPSBbXTtcbiAgICAgICAgdGhpcy5zaXplc0NhY2hlLnB1c2goMCk7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5pc1JlbW90ZSA/IHRoaXMudG90YWxJdGVtQ291bnQgOiBpdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHNpemUgPSB0aGlzLmdldEl0ZW1TaXplKGl0ZW1zW2ldKTtcbiAgICAgICAgICAgIHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZS5wdXNoKHNpemUpO1xuICAgICAgICAgICAgdG90YWxTaXplICs9IHNpemU7XG4gICAgICAgICAgICB0aGlzLnNpemVzQ2FjaGUucHVzaCh0b3RhbFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbFNpemU7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIF91cGRhdGVTaXplQ2FjaGUoY2hhbmdlczogSXRlcmFibGVDaGFuZ2VzPFQ+ID0gbnVsbCkge1xuICAgICAgICBjb25zdCBvbGRTaXplID0gdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlLmxlbmd0aCA+IDAgPyB0aGlzLmluZGl2aWR1YWxTaXplQ2FjaGUucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsKSA6IDA7XG4gICAgICAgIGxldCBuZXdTaXplID0gb2xkU2l6ZTtcbiAgICAgICAgaWYgKGNoYW5nZXMgJiYgIXRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgIG5ld1NpemUgPSB0aGlzLmhhbmRsZUNhY2hlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRpZmYgPSBvbGRTaXplIC0gbmV3U2l6ZTtcbiAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGhhbmRsZUNhY2hlQ2hhbmdlcyhjaGFuZ2VzOiBJdGVyYWJsZUNoYW5nZXM8VD4pIHtcbiAgICAgICAgY29uc3QgaWRlbnRpdHlDaGFuZ2VzID0gW107XG4gICAgICAgIGNvbnN0IG5ld0hlaWdodENhY2hlID0gW107XG4gICAgICAgIGNvbnN0IG5ld1NpemVzQ2FjaGUgPSBbXTtcbiAgICAgICAgbmV3U2l6ZXNDYWNoZS5wdXNoKDApO1xuICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gMDtcblxuICAgICAgICAvLyBXaGVuIHRoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHJlbW92ZWQgaXRlbXMgdGhlIGNoYW5nZXMgYXJlIG5vdCByZWxpYWJsZSBzbyB0aG9zZSB3aXRoIGlkZW50aXR5IGNoYW5nZSBzaG91bGQgYmUgZGVmYXVsdCBzaXplLlxuICAgICAgICBsZXQgbnVtUmVtb3ZlZEl0ZW1zID0gMDtcbiAgICAgICAgY2hhbmdlcy5mb3JFYWNoUmVtb3ZlZEl0ZW0oKCkgPT4gbnVtUmVtb3ZlZEl0ZW1zKyspO1xuXG4gICAgICAgIC8vIEdldCB0aGUgaWRlbnRpdHkgY2hhbmdlcyB0byBkZXRlcm1pbmUgbGF0ZXIgaWYgdGhvc2UgdGhhdCBoYXZlIGNoYW5nZWQgdGhlaXIgaW5kZXhlcyBzaG91bGQgYmUgYXNzaWduZWQgZGVmYXVsdCBpdGVtIHNpemUuXG4gICAgICAgIGNoYW5nZXMuZm9yRWFjaElkZW50aXR5Q2hhbmdlKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5jdXJyZW50SW5kZXggIT09IGl0ZW0ucHJldmlvdXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBvdXQgb25lcyB0aGF0IGhhdmUgbm90IGNoYW5nZWQgdGhlaXIgaW5kZXguXG4gICAgICAgICAgICAgICAgaWRlbnRpdHlDaGFuZ2VzW2l0ZW0uY3VycmVudEluZGV4XSA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFByb2Nlc3NpbmcgZWFjaCBpdGVtIHRoYXQgaXMgcGFzc2VkIHRvIHRoZSBpZ3hGb3JPZiBzbyBmYXIgc2VlbSB0byBiZSBtb3N0IHJlbGlhYmxlLiBXZSBwYXJzZSB0aGUgdXBkYXRlZCBsaXN0IG9mIGl0ZW1zLlxuICAgICAgICBjaGFuZ2VzLmZvckVhY2hJdGVtKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXRlbS5wcmV2aW91c0luZGV4ICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgKG51bVJlbW92ZWRJdGVtcyA8IDIgfHwgIWlkZW50aXR5Q2hhbmdlcy5sZW5ndGggfHwgaWRlbnRpdHlDaGFuZ2VzW2l0ZW0uY3VycmVudEluZGV4XSlcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uICE9PSBcImhvcml6b250YWxcIikge1xuICAgICAgICAgICAgICAgIC8vIFJldXNlIGNhY2hlIG9uIHRob3NlIHdobyBoYXZlIHByZXZpb3VzSW5kZXguXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBhcmUgbW9yZSB0aGFuIG9uZSByZW1vdmVkIGl0ZW1zIGN1cnJlbnRseSB0aGUgY2hhbmdlcyBhcmUgbm90IHJlYWRhYmxlIHNvIG9uZXMgd2l0aCBpZGVudGl0eSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgcmFjYWxjdWxhdGVkLlxuICAgICAgICAgICAgICAgIG5ld0hlaWdodENhY2hlW2l0ZW0uY3VycmVudEluZGV4XSA9IHRoaXMuaW5kaXZpZHVhbFNpemVDYWNoZVtpdGVtLnByZXZpb3VzSW5kZXhdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBc3NpZ24gZGVmYXVsdCBpdGVtIHNpemUuXG4gICAgICAgICAgICAgICAgbmV3SGVpZ2h0Q2FjaGVbaXRlbS5jdXJyZW50SW5kZXhdID0gdGhpcy5nZXRJdGVtU2l6ZShpdGVtLml0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3U2l6ZXNDYWNoZVtpdGVtLmN1cnJlbnRJbmRleCArIDFdID0gbmV3U2l6ZXNDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF0gKyBuZXdIZWlnaHRDYWNoZVtpdGVtLmN1cnJlbnRJbmRleF07XG4gICAgICAgICAgICBuZXdIZWlnaHQgKz0gbmV3SGVpZ2h0Q2FjaGVbaXRlbS5jdXJyZW50SW5kZXhdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbmRpdmlkdWFsU2l6ZUNhY2hlID0gbmV3SGVpZ2h0Q2FjaGU7XG4gICAgICAgIHRoaXMuc2l6ZXNDYWNoZSA9IG5ld1NpemVzQ2FjaGU7XG4gICAgICAgIHJldHVybiBuZXdIZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIGFkZExhc3RFbGVtKCkge1xuICAgICAgICBsZXQgZWxlbUluZGV4ID0gdGhpcy5zdGF0ZS5zdGFydEluZGV4ICsgdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIGlmICghdGhpcy5pc1JlbW90ZSAmJiAhdGhpcy5pZ3hGb3JPZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVsZW1JbmRleCA+PSB0aGlzLmlneEZvck9mLmxlbmd0aCkge1xuICAgICAgICAgICAgZWxlbUluZGV4ID0gdGhpcy5pZ3hGb3JPZi5sZW5ndGggLSB0aGlzLnN0YXRlLmNodW5rU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuaWd4Rm9yT2ZbZWxlbUluZGV4XTtcbiAgICAgICAgY29uc3QgZW1iZWRkZWRWaWV3ID0gdGhpcy5kYy5pbnN0YW5jZS5fdmNyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgICAgICAgIHRoaXMuX3RlbXBsYXRlLFxuICAgICAgICAgICAgbmV3IElneEdyaWRGb3JPZkNvbnRleHQ8VCwgVT4oaW5wdXQsIHRoaXMuaWd4Rm9yT2YsIHRoaXMuZ2V0Q29udGV4dEluZGV4KGlucHV0KSwgdGhpcy5pZ3hGb3JPZi5sZW5ndGgpXG4gICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5fZW1iZWRkZWRWaWV3cy5wdXNoKGVtYmVkZGVkVmlldyk7XG4gICAgICAgIHRoaXMuc3RhdGUuY2h1bmtTaXplKys7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF91cGRhdGVWaWV3cyhwcmV2Q2h1bmtTaXplKSB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvck9mICYmIHRoaXMuaWd4Rm9yT2YubGVuZ3RoICYmIHRoaXMuZGMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVtYmVkZGVkVmlld0NvcHkgPSBPYmplY3QuYXNzaWduKFtdLCB0aGlzLl9lbWJlZGRlZFZpZXdzKTtcbiAgICAgICAgICAgIGxldCBzdGFydEluZGV4O1xuICAgICAgICAgICAgbGV0IGVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNSZW1vdGUpIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBlbmRJbmRleCA9IHRoaXMuaWd4Rm9yT2YubGVuZ3RoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydEluZGV4ID0gdGhpcy5nZXRJbmRleEF0KHRoaXMuc2Nyb2xsUG9zaXRpb24sIHRoaXMuc2l6ZXNDYWNoZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0SW5kZXggKyB0aGlzLnN0YXRlLmNodW5rU2l6ZSA+IHRoaXMuaWd4Rm9yT2YubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0SW5kZXggPSB0aGlzLmlneEZvck9mLmxlbmd0aCAtIHRoaXMuc3RhdGUuY2h1bmtTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXJ0SW5kZXggPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gdGhpcy5zdGF0ZS5jaHVua1NpemUgKyB0aGlzLnN0YXRlLnN0YXJ0SW5kZXg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXggJiYgdGhpcy5pZ3hGb3JPZltpXSAhPT0gdW5kZWZpbmVkOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWJWaWV3ID0gZW1iZWRkZWRWaWV3Q29weS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVGVtcGxhdGVDb250ZXh0KGVtYlZpZXcuY29udGV4dCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkNodW5rU2l6ZSAhPT0gdGhpcy5zdGF0ZS5jaHVua1NpemUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rTG9hZC5lbWl0KHRoaXMuc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBfYXBwbHlDaGFuZ2VzKCkge1xuICAgICAgICBjb25zdCBwcmV2Q2h1bmtTaXplID0gdGhpcy5zdGF0ZS5jaHVua1NpemU7XG4gICAgICAgIHRoaXMuYXBwbHlDaHVua1NpemVDaGFuZ2UoKTtcbiAgICAgICAgdGhpcy5fcmVjYWxjU2Nyb2xsQmFyU2l6ZSgpO1xuICAgICAgICB0aGlzLl91cGRhdGVWaWV3cyhwcmV2Q2h1bmtTaXplKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIF9jYWxjTWF4Q2h1bmtTaXplKCk6IG51bWJlciB7XG4gICAgICAgIGlmICh0aGlzLmlneEZvclNjcm9sbE9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN5bmNTZXJ2aWNlLmlzTWFzdGVyKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLl9jYWxjTWF4Q2h1bmtTaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zeW5jU2VydmljZS5jaHVua1NpemUodGhpcy5pZ3hGb3JTY3JvbGxPcmllbnRhdGlvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuX2NhbGNNYXhDaHVua1NpemUoKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIl19
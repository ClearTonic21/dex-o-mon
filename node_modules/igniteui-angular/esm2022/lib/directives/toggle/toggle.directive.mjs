import { Directive, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output } from '@angular/core';
import { AbsoluteScrollStrategy } from '../../services/overlay/scroll/absolute-scroll-strategy';
import { ConnectedPositioningStrategy } from '../../services/overlay/position/connected-positioning-strategy';
import { filter, first, takeUntil } from 'rxjs/operators';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "../../core/navigation";
import * as i2 from "../../core/utils";
import * as i3 from "../../services/overlay/overlay";
export class IgxToggleDirective {
    /**
     * @hidden
     */
    get collapsed() {
        return this._collapsed;
    }
    /**
     * @hidden
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     */
    get hiddenClass() {
        return this.collapsed;
    }
    get hiddenWebkitClass() {
        const isSafari = this.platform?.isSafari;
        const browserVersion = this.platform?.browserVersion;
        return this.collapsed && isSafari && !!browserVersion && browserVersion < 17.5;
    }
    /**
     * @hidden
     */
    get defaultClass() {
        return !this.collapsed;
    }
    /**
     * @hidden
     */
    constructor(elementRef, cdr, overlayService, navigationService, platform) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.platform = platform;
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (opened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (opening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (closed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.closed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (closing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Emits an event after the toggle element is appended to the overlay container.
         *
         * ```typescript
         * onAppended() {
         *  alert("Content appended!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (appended)='onToggleAppended()'>
         * </div>
         * ```
         */
        this.appended = new EventEmitter();
        this._collapsed = true;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(x => x.id === this._overlayId),
            takeUntil(this.destroy$)
        ];
        this.overlayClosed = (e) => {
            this._collapsed = true;
            this.cdr.detectChanges();
            this.unsubscribe();
            this.overlayService.detach(this.overlayId);
            const args = { owner: this, id: this._overlayId, event: e.event };
            delete this._overlayId;
            this.closed.emit(args);
            this.cdr.markForCheck();
        };
    }
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    open(overlaySettings) {
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        const info = this.overlayService.getOverlayById(this._overlayId);
        const openAnimationStarted = info?.openAnimationPlayer?.hasStarted() ?? false;
        const closeAnimationStarted = info?.closeAnimationPlayer?.hasStarted() ?? false;
        if (openAnimationStarted || !(this._collapsed || closeAnimationStarted)) {
            return;
        }
        const target = overlaySettings && overlaySettings.target;
        // Get the size from the target element
        if (target && target instanceof Element) {
            const styles = window.getComputedStyle(target);
            const componentSize = styles.getPropertyValue('--component-size');
            const globalSize = styles.getPropertyValue('--ig-size');
            const size = componentSize || globalSize || '3';
            this.elementRef.nativeElement.style.setProperty('--ig-size', size);
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        if (!info) {
            this.unsubscribe();
            this.subscribe();
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        const args = { cancel: false, owner: this, id: this._overlayId };
        this.opening.emit(args);
        if (args.cancel) {
            this.unsubscribe();
            this.overlayService.detach(this._overlayId);
            this._collapsed = true;
            delete this._overlayId;
            this.cdr.detectChanges();
            return;
        }
        this.overlayService.show(this._overlayId, overlaySettings);
    }
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    close(event) {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        const info = this.overlayService.getOverlayById(this._overlayId);
        const closeAnimationStarted = info?.closeAnimationPlayer?.hasStarted() || false;
        if (this._collapsed || closeAnimationStarted) {
            return;
        }
        this.overlayService.hide(this._overlayId, event);
    }
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    toggle(overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is running close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    }
    /** @hidden @internal */
    get isClosing() {
        const info = this.overlayService.getOverlayById(this._overlayId);
        return info ? info.closeAnimationPlayer?.hasStarted() : false;
    }
    /**
     * Returns the id of the overlay the content is rendered in.
     * ```typescript
     * this.myToggle.overlayId;
     * ```
     */
    get overlayId() {
        return this._overlayId;
    }
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    reposition() {
        this.overlayService.reposition(this._overlayId);
    }
    /**
     * Offsets the content along the corresponding axis by the provided amount with optional
     * offsetMode that determines whether to add (by default) or set the offset values with OffsetMode.Add and OffsetMode.Set
     */
    setOffset(deltaX, deltaY, offsetMode) {
        this.overlayService.setOffset(this._overlayId, deltaX, deltaY, offsetMode);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    }
    /**
     * @hidden
     */
    ngOnDestroy() {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (this._overlayId) {
            this.overlayService.detach(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    subscribe() {
        this._overlayContentAppendedSub = this.overlayService
            .contentAppended
            .pipe(first(), takeUntil(this.destroy$))
            .subscribe(() => {
            const args = { owner: this, id: this._overlayId };
            this.appended.emit(args);
        });
        this._overlayOpenedSub = this.overlayService
            .opened
            .pipe(...this._overlaySubFilter)
            .subscribe(() => {
            const args = { owner: this, id: this._overlayId };
            this.opened.emit(args);
        });
        this._overlayClosingSub = this.overlayService
            .closing
            .pipe(...this._overlaySubFilter)
            .subscribe((e) => {
            const args = { cancel: false, event: e.event, owner: this, id: this._overlayId };
            this.closing.emit(args);
            e.cancel = args.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  closed was fired we will end with calling closing more than once
            if (!e.cancel) {
                this.clearSubscription(this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = this.overlayService
            .closed
            .pipe(...this._overlaySubFilter)
            .subscribe(this.overlayClosed);
    }
    unsubscribe() {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
        this.clearSubscription(this._overlayContentAppendedSub);
    }
    clearSubscription(subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxToggleDirective, deps: [{ token: i0.ElementRef }, { token: i0.ChangeDetectorRef }, { token: IgxOverlayService }, { token: i1.IgxNavigationService, optional: true }, { token: i2.PlatformUtil, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: IgxToggleDirective, isStandalone: true, selector: "[igxToggle]", inputs: { id: "id" }, outputs: { opened: "opened", opening: "opening", closed: "closed", closing: "closing", appended: "appended" }, host: { properties: { "class.igx-toggle--hidden": "this.hiddenClass", "attr.aria-hidden": "this.hiddenClass", "class.igx-toggle--hidden-webkit": "this.hiddenWebkitClass", "class.igx-toggle": "this.defaultClass" } }, exportAs: ["toggle"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxToggleDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'toggle',
                    selector: '[igxToggle]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ChangeDetectorRef }, { type: i3.IgxOverlayService, decorators: [{
                    type: Inject,
                    args: [IgxOverlayService]
                }] }, { type: i1.IgxNavigationService, decorators: [{
                    type: Optional
                }] }, { type: i2.PlatformUtil, decorators: [{
                    type: Optional
                }] }], propDecorators: { opened: [{
                type: Output
            }], opening: [{
                type: Output
            }], closed: [{
                type: Output
            }], closing: [{
                type: Output
            }], appended: [{
                type: Output
            }], id: [{
                type: Input
            }], hiddenClass: [{
                type: HostBinding,
                args: ['class.igx-toggle--hidden']
            }, {
                type: HostBinding,
                args: ['attr.aria-hidden']
            }], hiddenWebkitClass: [{
                type: HostBinding,
                args: ['class.igx-toggle--hidden-webkit']
            }], defaultClass: [{
                type: HostBinding,
                args: ['class.igx-toggle']
            }] } });
export class IgxToggleActionDirective {
    /**
     * @hidden
     */
    set target(target) {
        if (target !== null && target !== '') {
            this._target = target;
        }
    }
    /**
     * @hidden
     */
    get target() {
        if (typeof this._target === 'string') {
            return this.navigationService.get(this._target);
        }
        return this._target;
    }
    constructor(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    /**
     * @hidden
     */
    onClick() {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        const clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    }
    /**
     * @hidden
     */
    ngOnInit() {
        const targetElement = this.element.nativeElement;
        this._overlayDefaults = {
            target: targetElement,
            positionStrategy: new ConnectedPositioningStrategy(),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludeFromOutsideClick: [targetElement]
        };
    }
    /**
     * Updates provided overlay settings
     *
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    updateOverlaySettings(settings) {
        if (settings && settings.positionStrategy) {
            const positionStrategyClone = settings.positionStrategy.clone();
            settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxToggleActionDirective, deps: [{ token: i0.ElementRef }, { token: i1.IgxNavigationService, optional: true }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: IgxToggleActionDirective, isStandalone: true, selector: "[igxToggleAction]", inputs: { overlaySettings: "overlaySettings", outlet: ["igxToggleOutlet", "outlet"], target: ["igxToggleAction", "target"] }, host: { listeners: { "click": "onClick()" } }, exportAs: ["toggle-action"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxToggleActionDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'toggle-action',
                    selector: '[igxToggleAction]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i1.IgxNavigationService, decorators: [{
                    type: Optional
                }] }], propDecorators: { overlaySettings: [{
                type: Input
            }], outlet: [{
                type: Input,
                args: ['igxToggleOutlet']
            }], target: [{
                type: Input,
                args: ['igxToggleAction']
            }], onClick: [{
                type: HostListener,
                args: ['click']
            }] } });
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
export class IgxOverlayOutletDirective {
    constructor(element) {
        this.element = element;
    }
    /** @hidden */
    get nativeElement() {
        return this.element.nativeElement;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxOverlayOutletDirective, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.1", type: IgxOverlayOutletDirective, isStandalone: true, selector: "[igxOverlayOutlet]", exportAs: ["overlay-outlet"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxOverlayOutletDirective, decorators: [{
            type: Directive,
            args: [{
                    exportAs: 'overlay-outlet',
                    selector: '[igxOverlayOutlet]',
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9kaXJlY3RpdmVzL3RvZ2dsZS90b2dnbGUuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFSCxTQUFTLEVBRVQsWUFBWSxFQUNaLFdBQVcsRUFDWCxZQUFZLEVBQ1osTUFBTSxFQUNOLEtBQUssRUFHTCxRQUFRLEVBQ1IsTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHdEQUF3RCxDQUFDO0FBRWhHLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGdFQUFnRSxDQUFDO0FBQzlHLE9BQU8sRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTFELE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBR25FLE9BQU8sRUFBZ0IsT0FBTyxFQUE0QixNQUFNLE1BQU0sQ0FBQzs7Ozs7QUFldkUsTUFBTSxPQUFPLGtCQUFrQjtJQWdHM0I7O09BRUc7SUFDSCxJQUFXLFNBQVM7UUFDaEIsT0FBTyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQzNCLENBQUM7SUFZRDs7T0FFRztJQUNILElBQVcsT0FBTztRQUNkLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7SUFDekMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFFVyxXQUFXO1FBQ2xCLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUMxQixDQUFDO0lBRUQsSUFDVyxpQkFBaUI7UUFDeEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQUM7UUFDekMsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxjQUFjLENBQUM7UUFF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THBDLFNBQVM7bUJBQUM7b0JBQ1AsUUFBUSxFQUFFLGVBQWU7b0JBQ3pCLFFBQVEsRUFBRSxtQkFBbUI7b0JBQzdCLFVBQVUsRUFBRSxJQUFJO2lCQUNuQjs7MEJBc0Q2QyxRQUFRO3lDQXJDM0MsZUFBZTtzQkFEckIsS0FBSztnQkFhQyxNQUFNO3NCQURaLEtBQUs7dUJBQUMsaUJBQWlCO2dCQU9iLE1BQU07c0JBRGhCLEtBQUs7dUJBQUMsaUJBQWlCO2dCQTBCakIsT0FBTztzQkFEYixZQUFZO3VCQUFDLE9BQU87O0FBMkN6Qjs7Ozs7O0dBTUc7QUFNSCxNQUFNLE9BQU8seUJBQXlCO0lBQ2xDLFlBQW1CLE9BQWdDO1FBQWhDLFlBQU8sR0FBUCxPQUFPLENBQXlCO0lBQUksQ0FBQztJQUV4RCxjQUFjO0lBQ2QsSUFBVyxhQUFhO1FBQ3BCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUM7SUFDdEMsQ0FBQzs4R0FOUSx5QkFBeUI7a0dBQXpCLHlCQUF5Qjs7MkZBQXpCLHlCQUF5QjtrQkFMckMsU0FBUzttQkFBQztvQkFDUCxRQUFRLEVBQUUsZ0JBQWdCO29CQUMxQixRQUFRLEVBQUUsb0JBQW9CO29CQUM5QixVQUFVLEVBQUUsSUFBSTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3B0aW9uYWwsXG4gICAgT3V0cHV0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWJzb2x1dGVTY3JvbGxTdHJhdGVneSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvc2Nyb2xsL2Fic29sdXRlLXNjcm9sbC1zdHJhdGVneSc7XG5pbXBvcnQgeyBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncywgSUJhc2VFdmVudEFyZ3MsIFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvcG9zaXRpb24vY29ubmVjdGVkLXBvc2l0aW9uaW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IGZpbHRlciwgZmlyc3QsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uLy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBJZ3hPdmVybGF5U2VydmljZSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvb3ZlcmxheSc7XG5pbXBvcnQgeyBJUG9zaXRpb25TdHJhdGVneSB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvcG9zaXRpb24vSVBvc2l0aW9uU3RyYXRlZ3knO1xuaW1wb3J0IHsgT2Zmc2V0TW9kZSwgT3ZlcmxheUNsb3NpbmdFdmVudEFyZ3MsIE92ZXJsYXlFdmVudEFyZ3MsIE92ZXJsYXlTZXR0aW5ncyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvdXRpbGl0aWVzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgU3ViamVjdCwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVG9nZ2xlVmlld0V2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogSWQgb2YgdGhlIHRvZ2dsZSB2aWV3ICovXG4gICAgaWQ6IHN0cmluZztcbiAgICBldmVudD86IEV2ZW50O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRvZ2dsZVZpZXdDYW5jZWxhYmxlRXZlbnRBcmdzIGV4dGVuZHMgVG9nZ2xlVmlld0V2ZW50QXJncywgQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgeyB9XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAndG9nZ2xlJyxcbiAgICBzZWxlY3RvcjogJ1tpZ3hUb2dnbGVdJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFRvZ2dsZURpcmVjdGl2ZSBpbXBsZW1lbnRzIElUb2dnbGVWaWV3LCBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmVkKGV2ZW50KSB7XG4gICAgICogICAgYWxlcnQoXCJUb2dnbGUgb3BlbmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob3BlbmVkKT0nb25Ub2dnbGVPcGVuZWQoJGV2ZW50KSc+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9wZW5lZCA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGJlZm9yZSB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVPcGVuaW5nKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIG9wZW5pbmchXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogICBpZ3hUb2dnbGVcbiAgICAgKiAgIChvcGVuaW5nKT0nb25Ub2dnbGVPcGVuaW5nKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvcGVuaW5nID0gbmV3IEV2ZW50RW1pdHRlcjxUb2dnbGVWaWV3Q2FuY2VsYWJsZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NlZChldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBjbG9zZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogICBpZ3hUb2dnbGVcbiAgICAgKiAgIChjbG9zZWQpPSdvblRvZ2dsZUNsb3NlZCgkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxUb2dnbGVWaWV3RXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYmVmb3JlIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NpbmcoZXZlbnQpIHtcbiAgICAgKiAgYWxlcnQoXCJUb2dnbGUgY2xvc2luZyFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXZcbiAgICAgKiAgaWd4VG9nZ2xlXG4gICAgICogIChjbG9zaW5nKT0nb25Ub2dnbGVDbG9zaW5nKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBjbG9zaW5nID0gbmV3IEV2ZW50RW1pdHRlcjxUb2dnbGVWaWV3Q2FuY2VsYWJsZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgZWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGUgb3ZlcmxheSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25BcHBlbmRlZCgpIHtcbiAgICAgKiAgYWxlcnQoXCJDb250ZW50IGFwcGVuZGVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAoYXBwZW5kZWQpPSdvblRvZ2dsZUFwcGVuZGVkKCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBhcHBlbmRlZCA9IG5ldyBFdmVudEVtaXR0ZXI8VG9nZ2xlVmlld0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbGxhcHNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVyIHdoaWNoIGlzIHJlZ2lzdGVyZWQgaW50byBgSWd4TmF2aWdhdGlvblNlcnZpY2VgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IG15VG9nZ2xlSWQgPSB0aGlzLnRvZ2dsZS5pZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdG9nZ2xlLS1oaWRkZW4nKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWhpZGRlbicpXG4gICAgcHVibGljIGdldCBoaWRkZW5DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkO1xuICAgIH1cblxuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRvZ2dsZS0taGlkZGVuLXdlYmtpdCcpXG4gICAgcHVibGljIGdldCBoaWRkZW5XZWJraXRDbGFzcygpIHtcbiAgICAgICAgY29uc3QgaXNTYWZhcmkgPSB0aGlzLnBsYXRmb3JtPy5pc1NhZmFyaTtcbiAgICAgICAgY29uc3QgYnJvd3NlclZlcnNpb24gPSB0aGlzLnBsYXRmb3JtPy5icm93c2VyVmVyc2lvbjtcblxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsYXBzZWQgJiYgaXNTYWZhcmkgJiYgISFicm93c2VyVmVyc2lvbiAmJiBicm93c2VyVmVyc2lvbiA8IDE3LjU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXRvZ2dsZScpXG4gICAgcHVibGljIGdldCBkZWZhdWx0Q2xhc3MoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF9vdmVybGF5SWQ6IHN0cmluZztcblxuICAgIHByaXZhdGUgX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgcHJvdGVjdGVkIGRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICBwcml2YXRlIF9vdmVybGF5U3ViRmlsdGVyOiBbTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uPE92ZXJsYXlFdmVudEFyZ3M+LCBNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248T3ZlcmxheUV2ZW50QXJncz5dID0gW1xuICAgICAgICBmaWx0ZXIoeCA9PiB4LmlkID09PSB0aGlzLl9vdmVybGF5SWQpLFxuICAgICAgICB0YWtlVW50aWwodGhpcy5kZXN0cm95JClcbiAgICBdO1xuICAgIHByaXZhdGUgX292ZXJsYXlPcGVuZWRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9vdmVybGF5Q2xvc2luZ1N1YjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX292ZXJsYXlDbG9zZWRTdWI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIF9vdmVybGF5Q29udGVudEFwcGVuZGVkU3ViOiBTdWJzY3JpcHRpb247XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgcHJpdmF0ZSBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBASW5qZWN0KElneE92ZXJsYXlTZXJ2aWNlKSBwcm90ZWN0ZWQgb3ZlcmxheVNlcnZpY2U6IElneE92ZXJsYXlTZXJ2aWNlLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIG5hdmlnYXRpb25TZXJ2aWNlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSxcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBwbGF0Zm9ybT86IFBsYXRmb3JtVXRpbFxuICAgICkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5vcGVuKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9wZW4ob3ZlcmxheVNldHRpbmdzPzogT3ZlcmxheVNldHRpbmdzKSB7XG4gICAgICAgIC8vICBpZiB0aGVyZSBpcyBvcGVuIGFuaW1hdGlvbiBkbyBub3RoaW5nXG4gICAgICAgIC8vICBpZiB0b2dnbGUgaXMgbm90IGNvbGxhcHNlZCBhbmQgdGhlcmUgaXMgbm8gY2xvc2UgYW5pbWF0aW9uIGRvIG5vdGhpbmdcbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMub3ZlcmxheVNlcnZpY2UuZ2V0T3ZlcmxheUJ5SWQodGhpcy5fb3ZlcmxheUlkKTtcbiAgICAgICAgY29uc3Qgb3BlbkFuaW1hdGlvblN0YXJ0ZWQgPSBpbmZvPy5vcGVuQW5pbWF0aW9uUGxheWVyPy5oYXNTdGFydGVkKCkgPz8gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNsb3NlQW5pbWF0aW9uU3RhcnRlZCA9IGluZm8/LmNsb3NlQW5pbWF0aW9uUGxheWVyPy5oYXNTdGFydGVkKCkgPz8gZmFsc2U7XG4gICAgICAgIGlmIChvcGVuQW5pbWF0aW9uU3RhcnRlZCB8fCAhKHRoaXMuX2NvbGxhcHNlZCB8fCBjbG9zZUFuaW1hdGlvblN0YXJ0ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSBvdmVybGF5U2V0dGluZ3MgJiYgb3ZlcmxheVNldHRpbmdzLnRhcmdldDtcblxuICAgICAgICAvLyBHZXQgdGhlIHNpemUgZnJvbSB0aGUgdGFyZ2V0IGVsZW1lbnRcbiAgICAgICAgaWYgKHRhcmdldCAmJiB0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgY29tcG9uZW50U2l6ZSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCctLWNvbXBvbmVudC1zaXplJyk7XG4gICAgICAgICAgICBjb25zdCBnbG9iYWxTaXplID0gc3R5bGVzLmdldFByb3BlcnR5VmFsdWUoJy0taWctc2l6ZScpO1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGNvbXBvbmVudFNpemUgfHwgZ2xvYmFsU2l6ZSB8fCAnMyc7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1pZy1zaXplJywgc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlJZCA9IHRoaXMub3ZlcmxheVNlcnZpY2UuYXR0YWNoKHRoaXMuZWxlbWVudFJlZiwgb3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGFyZ3M6IFRvZ2dsZVZpZXdDYW5jZWxhYmxlRXZlbnRBcmdzID0geyBjYW5jZWw6IGZhbHNlLCBvd25lcjogdGhpcywgaWQ6IHRoaXMuX292ZXJsYXlJZCB9O1xuICAgICAgICB0aGlzLm9wZW5pbmcuZW1pdChhcmdzKTtcbiAgICAgICAgaWYgKGFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLm92ZXJsYXlTZXJ2aWNlLmRldGFjaCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICAgICAgdGhpcy5fY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9vdmVybGF5SWQ7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5zaG93KHRoaXMuX292ZXJsYXlJZCwgb3ZlcmxheVNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRvZ2dsZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLmNsb3NlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGNsb3NlKGV2ZW50PzogRXZlbnQpIHtcbiAgICAgICAgLy8gIGlmIHRvZ2dsZSBpcyBjb2xsYXBzZWQgZG8gbm90aGluZ1xuICAgICAgICAvLyAgaWYgdGhlcmUgaXMgY2xvc2UgYW5pbWF0aW9uIGRvIG5vdGhpbmcsIHRvZ2dsZSB3aWxsIGNsb3NlIGFueXdheVxuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBjbG9zZUFuaW1hdGlvblN0YXJ0ZWQgPSBpbmZvPy5jbG9zZUFuaW1hdGlvblBsYXllcj8uaGFzU3RhcnRlZCgpIHx8IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fY29sbGFwc2VkIHx8IGNsb3NlQW5pbWF0aW9uU3RhcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5oaWRlKHRoaXMuX292ZXJsYXlJZCwgZXZlbnQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9nZ2xlLCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKG92ZXJsYXlTZXR0aW5ncz86IE92ZXJsYXlTZXR0aW5ncykge1xuICAgICAgICAvLyAgaWYgdG9nZ2xlIGlzIGNvbGxhcHNlZCBjYWxsIG9wZW5cbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIHJ1bm5pbmcgY2xvc2UgYW5pbWF0aW9uIGNhbGwgb3BlblxuICAgICAgICBpZiAodGhpcy5jb2xsYXBzZWQgfHwgdGhpcy5pc0Nsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoaXMub3BlbihvdmVybGF5U2V0dGluZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldCBpc0Nsb3NpbmcoKSB7XG4gICAgICAgIGNvbnN0IGluZm8gPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLmdldE92ZXJsYXlCeUlkKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgICAgIHJldHVybiBpbmZvID8gaW5mby5jbG9zZUFuaW1hdGlvblBsYXllcj8uaGFzU3RhcnRlZCgpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhlIG92ZXJsYXkgdGhlIGNvbnRlbnQgaXMgcmVuZGVyZWQgaW4uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubXlUb2dnbGUub3ZlcmxheUlkO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgb3ZlcmxheUlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheUlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcG9zaXRpb25zIHRoZSB0b2dnbGUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubXlUb2dnbGUucmVwb3NpdGlvbigpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyByZXBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLm92ZXJsYXlTZXJ2aWNlLnJlcG9zaXRpb24odGhpcy5fb3ZlcmxheUlkKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPZmZzZXRzIHRoZSBjb250ZW50IGFsb25nIHRoZSBjb3JyZXNwb25kaW5nIGF4aXMgYnkgdGhlIHByb3ZpZGVkIGFtb3VudCB3aXRoIG9wdGlvbmFsXG4gICAgICogb2Zmc2V0TW9kZSB0aGF0IGRldGVybWluZXMgd2hldGhlciB0byBhZGQgKGJ5IGRlZmF1bHQpIG9yIHNldCB0aGUgb2Zmc2V0IHZhbHVlcyB3aXRoIE9mZnNldE1vZGUuQWRkIGFuZCBPZmZzZXRNb2RlLlNldFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRPZmZzZXQoZGVsdGFYOiBudW1iZXIsIGRlbHRhWTogbnVtYmVyLCBvZmZzZXRNb2RlPzogT2Zmc2V0TW9kZSkge1xuICAgICAgICB0aGlzLm92ZXJsYXlTZXJ2aWNlLnNldE9mZnNldCh0aGlzLl9vdmVybGF5SWQsIGRlbHRhWCwgZGVsdGFZLCBvZmZzZXRNb2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZSAmJiB0aGlzLmlkKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmFkZCh0aGlzLmlkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb25TZXJ2aWNlICYmIHRoaXMuaWQpIHtcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvblNlcnZpY2UucmVtb3ZlKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9vdmVybGF5SWQpIHtcbiAgICAgICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuZGV0YWNoKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG92ZXJsYXlDbG9zZWQgPSAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5kZXRhY2godGhpcy5vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBhcmdzOiBUb2dnbGVWaWV3RXZlbnRBcmdzID0geyBvd25lcjogdGhpcywgaWQ6IHRoaXMuX292ZXJsYXlJZCwgZXZlbnQ6IGUuZXZlbnQgfTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX292ZXJsYXlJZDtcbiAgICAgICAgdGhpcy5jbG9zZWQuZW1pdChhcmdzKTtcbiAgICAgICAgdGhpcy5jZHIubWFya0ZvckNoZWNrKCk7XG4gICAgfTtcblxuICAgIHByaXZhdGUgc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5Q29udGVudEFwcGVuZGVkU3ViID0gdGhpcy5vdmVybGF5U2VydmljZVxuICAgICAgICAgICAgLmNvbnRlbnRBcHBlbmRlZFxuICAgICAgICAgICAgLnBpcGUoZmlyc3QoKSwgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnczogVG9nZ2xlVmlld0V2ZW50QXJncyA9IHsgb3duZXI6IHRoaXMsIGlkOiB0aGlzLl9vdmVybGF5SWQgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZGVkLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5T3BlbmVkU3ViID0gdGhpcy5vdmVybGF5U2VydmljZVxuICAgICAgICAgICAgLm9wZW5lZFxuICAgICAgICAgICAgLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlcilcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IFRvZ2dsZVZpZXdFdmVudEFyZ3MgPSB7IG93bmVyOiB0aGlzLCBpZDogdGhpcy5fb3ZlcmxheUlkIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuZWQuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViID0gdGhpcy5vdmVybGF5U2VydmljZVxuICAgICAgICAgICAgLmNsb3NpbmdcbiAgICAgICAgICAgIC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChlOiBPdmVybGF5Q2xvc2luZ0V2ZW50QXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3M6IFRvZ2dsZVZpZXdDYW5jZWxhYmxlRXZlbnRBcmdzID0geyBjYW5jZWw6IGZhbHNlLCBldmVudDogZS5ldmVudCwgb3duZXI6IHRoaXMsIGlkOiB0aGlzLl9vdmVybGF5SWQgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NpbmcuZW1pdChhcmdzKTtcbiAgICAgICAgICAgICAgICBlLmNhbmNlbCA9IGFyZ3MuY2FuY2VsO1xuXG4gICAgICAgICAgICAgICAgLy8gIGluIGNhc2UgZXZlbnQgaXMgbm90IGNhbmNlbGVkIHRoaXMgd2lsbCBjbG9zZSB0aGUgdG9nZ2xlIGFuZCB3ZSBuZWVkIHRvIHVuc3Vic2NyaWJlLlxuICAgICAgICAgICAgICAgIC8vICBPdGhlcndpc2UgaWYgZm9yIHNvbWUgcmVhc29uLCBlLmcuIGNsb3NlIG9uIG91dHNpZGUgY2xpY2ssIGNsb3NlKCkgZ2V0cyBjYWxsZWQgYmVmb3JlXG4gICAgICAgICAgICAgICAgLy8gIGNsb3NlZCB3YXMgZmlyZWQgd2Ugd2lsbCBlbmQgd2l0aCBjYWxsaW5nIGNsb3NpbmcgbW9yZSB0aGFuIG9uY2VcbiAgICAgICAgICAgICAgICBpZiAoIWUuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJTdWJzY3JpcHRpb24odGhpcy5fb3ZlcmxheUNsb3NpbmdTdWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX292ZXJsYXlDbG9zZWRTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlXG4gICAgICAgICAgICAuY2xvc2VkXG4gICAgICAgICAgICAucGlwZSguLi50aGlzLl9vdmVybGF5U3ViRmlsdGVyKVxuICAgICAgICAgICAgLnN1YnNjcmliZSh0aGlzLm92ZXJsYXlDbG9zZWQpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdW5zdWJzY3JpYmUoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJTdWJzY3JpcHRpb24odGhpcy5fb3ZlcmxheU9wZW5lZFN1Yik7XG4gICAgICAgIHRoaXMuY2xlYXJTdWJzY3JpcHRpb24odGhpcy5fb3ZlcmxheUNsb3NpbmdTdWIpO1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zZWRTdWIpO1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDb250ZW50QXBwZW5kZWRTdWIpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xlYXJTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uOiBTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiAmJiAhc3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAndG9nZ2xlLWFjdGlvbicsXG4gICAgc2VsZWN0b3I6ICdbaWd4VG9nZ2xlQWN0aW9uXScsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUb2dnbGVBY3Rpb25EaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgc2V0dGluZ3MgdGhhdCBjb250cm9sIHRoZSB0b2dnbGUgb3ZlcmxheSBwb3NpdGlvbmluZywgaW50ZXJhY3Rpb24gYW5kIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyA9IHtcbiAgICAgKiAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IGZhbHNlLFxuICAgICAqICAgICAgbW9kYWw6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBgYGBcbiAgICAgKiAtLS1cbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtvdmVybGF5U2V0dGluZ3NdPVwic2V0dGluZ3NcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBvdmVybGF5U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncztcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hlcmUgdGhlIHRvZ2dsZSBlbGVtZW50IG92ZXJsYXkgc2hvdWxkIGJlIGF0dGFjaGVkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbaWd4VG9nZ2xlT3V0bGV0XT1cIm91dGxldFwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIFdoZXJlIGBvdXRsZXRgIGluIGFuIGluc3RhbmNlIG9mIGBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlYCBvciBhbiBgRWxlbWVudFJlZmBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneFRvZ2dsZU91dGxldCcpXG4gICAgcHVibGljIG91dGxldDogSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSB8IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUb2dnbGVBY3Rpb24nKVxuICAgIHB1YmxpYyBzZXQgdGFyZ2V0KHRhcmdldDogYW55KSB7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IG51bGwgJiYgdGFyZ2V0ICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdGFyZ2V0KCk6IGFueSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmF2aWdhdGlvblNlcnZpY2UuZ2V0KHRoaXMuX3RhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgX292ZXJsYXlEZWZhdWx0czogT3ZlcmxheVNldHRpbmdzO1xuICAgIHByb3RlY3RlZCBfdGFyZ2V0OiBJVG9nZ2xlVmlldyB8IHN0cmluZztcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWxlbWVudDogRWxlbWVudFJlZiwgQE9wdGlvbmFsKCkgcHJpdmF0ZSBuYXZpZ2F0aW9uU2VydmljZTogSWd4TmF2aWdhdGlvblNlcnZpY2UpIHsgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2NsaWNrJylcbiAgICBwdWJsaWMgb25DbGljaygpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0bGV0KSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5RGVmYXVsdHMub3V0bGV0ID0gdGhpcy5vdXRsZXQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjbG9uZWRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX292ZXJsYXlEZWZhdWx0cywgdGhpcy5vdmVybGF5U2V0dGluZ3MpO1xuICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXlTZXR0aW5ncyhjbG9uZWRTZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudGFyZ2V0LnRvZ2dsZShjbG9uZWRTZXR0aW5ncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB0aGlzLl9vdmVybGF5RGVmYXVsdHMgPSB7XG4gICAgICAgICAgICB0YXJnZXQ6IHRhcmdldEVsZW1lbnQsXG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiBuZXcgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSgpLFxuICAgICAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IG5ldyBBYnNvbHV0ZVNjcm9sbFN0cmF0ZWd5KCksXG4gICAgICAgICAgICBjbG9zZU9uT3V0c2lkZUNsaWNrOiB0cnVlLFxuICAgICAgICAgICAgbW9kYWw6IGZhbHNlLFxuICAgICAgICAgICAgZXhjbHVkZUZyb21PdXRzaWRlQ2xpY2s6IFt0YXJnZXRFbGVtZW50IGFzIEhUTUxFbGVtZW50XVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgcHJvdmlkZWQgb3ZlcmxheSBzZXR0aW5nc1xuICAgICAqXG4gICAgICogQHBhcmFtIHNldHRpbmdzIHNldHRpbmdzIHRvIHVwZGF0ZVxuICAgICAqIEByZXR1cm5zIHJldHVybnMgdXBkYXRlZCBjb3B5IG9mIHByb3ZpZGVkIG92ZXJsYXkgc2V0dGluZ3NcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlT3ZlcmxheVNldHRpbmdzKHNldHRpbmdzOiBPdmVybGF5U2V0dGluZ3MpOiBPdmVybGF5U2V0dGluZ3Mge1xuICAgICAgICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25TdHJhdGVneUNsb25lOiBJUG9zaXRpb25TdHJhdGVneSA9IHNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kuY2xvbmUoKTtcbiAgICAgICAgICAgIHNldHRpbmdzLnRhcmdldCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneSA9IHBvc2l0aW9uU3RyYXRlZ3lDbG9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG59XG5cbi8qKlxuICogTWFyayBhbiBlbGVtZW50IGFzIGFuIGlneE92ZXJsYXkgb3V0bGV0IGNvbnRhaW5lci5cbiAqIERpcmVjdGl2ZSBpbnN0YW5jZSBpcyBleHBvcnRlZCBhcyBgb3ZlcmxheS1vdXRsZXRgIHRvIGJlIGFzc2lnbmVkIHRvIHRlbXBsYXRlcyB2YXJpYWJsZXM6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IGlneE92ZXJsYXlPdXRsZXQgI291dGxldD1cIm92ZXJsYXktb3V0bGV0XCI+PC9kaXY+XG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgZXhwb3J0QXM6ICdvdmVybGF5LW91dGxldCcsXG4gICAgc2VsZWN0b3I6ICdbaWd4T3ZlcmxheU91dGxldF0nLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnQ6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+KSB7IH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxufVxuIl19
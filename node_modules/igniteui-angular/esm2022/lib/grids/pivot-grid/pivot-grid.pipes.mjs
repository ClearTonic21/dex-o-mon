import { Inject, Pipe } from '@angular/core';
import { cloneArray, resolveNestedPath } from '../../core/utils';
import { DataUtil } from '../../data-operations/data-util';
import { FilteringExpressionsTree } from '../../data-operations/filtering-expressions-tree';
import { DefaultPivotGridRecordSortingStrategy } from '../../data-operations/pivot-sort-strategy';
import { FilterUtil } from '../../data-operations/filtering-strategy';
import { DimensionValuesFilteringStrategy, PivotColumnDimensionsStrategy, PivotRowDimensionsStrategy } from '../../data-operations/pivot-strategy';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { DEFAULT_PIVOT_KEYS } from './pivot-grid.interface';
import { PivotSortUtil } from './pivot-sort-util';
import { PivotUtil } from './pivot-util';
import * as i0 from "@angular/core";
import * as i1 from "../api.service";
/**
 * @hidden
 */
export class IgxPivotRowPipe {
    constructor() { }
    transform(collection, config, cloneStrategy, _, _pipeTrigger, __) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledRows = config.rows?.filter(x => x.enabled) || [];
        const enabledColumns = config.columns?.filter(x => x.enabled) || [];
        const enabledValues = config.values?.filter(x => x.enabled) || [];
        if (enabledRows.length === 0 && enabledColumns.length === 0 && enabledValues.length === 0) {
            // nothing to group and aggregate by ...
            return [];
        }
        const rowStrategy = config.rowStrategy || PivotRowDimensionsStrategy.instance();
        const data = cloneArray(collection, true);
        return rowStrategy.process(data, enabledRows, config.values, cloneStrategy, pivotKeys);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowPipe, isStandalone: true, name: "pivotGridRow" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridRow',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [] });
/**
 * @hidden
 * Transforms generic array data into IPivotGridRecord[]
 */
export class IgxPivotAutoTransform {
    transform(collection, config, _pipeTrigger, __) {
        let needsTransformation = false;
        if (collection.length > 0) {
            needsTransformation = !this.isPivotRecord(collection[0]);
        }
        if (!needsTransformation)
            return collection;
        const res = this.processCollectionToPivotRecord(config, collection);
        return res;
    }
    isPivotRecord(arg) {
        return !!arg.aggregationValues;
    }
    processCollectionToPivotRecord(config, collection) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledRows = config.rows.filter(x => x.enabled);
        const allFlat = PivotUtil.flatten(enabledRows);
        const result = [];
        for (const rec of collection) {
            const pivotRec = {
                dimensionValues: new Map(),
                aggregationValues: new Map(),
                children: new Map(),
                dimensions: []
            };
            const keys = Object.keys(rec);
            for (const key of keys) {
                const dim = allFlat.find(x => x.memberName === key);
                if (dim) {
                    //field has matching dimension
                    pivotRec.dimensions.push(dim);
                    pivotRec.dimensionValues.set(key, rec[key]);
                }
                else if (key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records) !== -1) {
                    // field that contains child collection
                    const dimKey = key.slice(0, key.indexOf(pivotKeys.rowDimensionSeparator + pivotKeys.records));
                    const childData = rec[key];
                    const childPivotData = this.processCollectionToPivotRecord(config, childData);
                    pivotRec.children.set(dimKey, childPivotData);
                }
                else {
                    // an aggregation
                    pivotRec.aggregationValues.set(key, rec[key]);
                }
            }
            const flattened = PivotUtil.flatten(config.rows);
            pivotRec.dimensions.sort((x, y) => flattened.indexOf(x) - flattened.indexOf(y));
            result.push(pivotRec);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotAutoTransform, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotAutoTransform, isStandalone: true, name: "pivotGridAutoTransform" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotAutoTransform, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridAutoTransform',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotRowExpansionPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, expansionStates, defaultExpand, _pipeTrigger, __) {
        const enabledRows = config.rows?.filter(x => x.enabled) || [];
        const data = collection ? cloneArray(collection, true) : [];
        for (const row of enabledRows) {
            PivotUtil.flattenGroups(data, row, expansionStates, defaultExpand);
        }
        const finalData = enabledRows.length > 0 ?
            data.filter(x => x.dimensions.length === enabledRows.length) : data;
        if (this.grid) {
            this.grid.setFilteredSortedData(finalData, false);
        }
        return finalData;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowExpansionPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowExpansionPipe, isStandalone: true, name: "pivotGridRowExpansion" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowExpansionPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridRowExpansion',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotCellMergingPipe {
    constructor(grid) {
        this.grid = grid;
    }
    transform(collection, config, dim, _pipeTrigger) {
        if (collection.length === 0 || config.rows.length === 0)
            return collection;
        const data = collection ? cloneArray(collection, true) : [];
        const res = [];
        const enabledRows = config.rows?.filter(x => x.enabled);
        let groupData = [];
        let prevId;
        const index = enabledRows.indexOf(dim);
        for (const rec of data) {
            const currentDim = rec.dimensions[index];
            const id = PivotUtil.getRecordKey(rec, currentDim);
            if (groupData.length > 0 && prevId !== id) {
                const h = groupData.length > 1 ? groupData.length * this.grid.renderedRowHeight : undefined;
                groupData[0].height = h;
                groupData[0].rowSpan = groupData.length;
                res.push(groupData[0]);
                groupData = [];
            }
            groupData.push(rec);
            prevId = id;
        }
        if (groupData.length > 0) {
            const h = groupData.length > 1 ? groupData.length * this.grid.rowHeight + (groupData.length - 1) + 1 : undefined;
            groupData[0].height = h;
            groupData[0].rowSpan = groupData.length;
            res.push(groupData[0]);
        }
        return res;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotCellMergingPipe, deps: [{ token: IGX_GRID_BASE }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotCellMergingPipe, isStandalone: true, name: "pivotGridCellMerging" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotCellMergingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridCellMerging',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }] });
/**
 * @hidden
 */
export class IgxPivotColumnPipe {
    transform(collection, config, cloneStrategy, _, _pipeTrigger, __) {
        const pivotKeys = config.pivotKeys || DEFAULT_PIVOT_KEYS;
        const enabledColumns = config.columns?.filter(x => x.enabled) || [];
        const enabledValues = config.values?.filter(x => x.enabled) || [];
        const colStrategy = config.columnStrategy || PivotColumnDimensionsStrategy.instance();
        const data = cloneArray(collection, true);
        return colStrategy.process(data, enabledColumns, enabledValues, cloneStrategy, pivotKeys);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotColumnPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotColumnPipe, isStandalone: true, name: "pivotGridColumn" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotColumnPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridColumn',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotGridFilterPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, config, filterStrategy, advancedExpressionsTree, _filterPipeTrigger, _pipeTrigger) {
        const expressionsTree = PivotUtil.buildExpressionTree(config);
        const state = {
            expressionsTree,
            strategy: filterStrategy || new DimensionValuesFilteringStrategy(),
            advancedExpressionsTree
        };
        if (FilteringExpressionsTree.empty(state.expressionsTree) && FilteringExpressionsTree.empty(state.advancedExpressionsTree)) {
            return collection;
        }
        const result = FilterUtil.filter(cloneArray(collection, true), state, this.gridAPI.grid);
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridFilterPipe, deps: [{ token: i1.GridBaseAPIService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridFilterPipe, isStandalone: true, name: "pivotGridFilter" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridFilterPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridFilter',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.GridBaseAPIService }] });
/**
 * @hidden
 */
export class IgxPivotGridColumnSortingPipe {
    transform(collection, expressions, sorting, _pipeTrigger) {
        let result;
        if (!expressions.length) {
            result = collection;
        }
        else {
            for (const expr of expressions) {
                expr.strategy = DefaultPivotGridRecordSortingStrategy.instance();
            }
            result = PivotUtil.sort(cloneArray(collection, true), expressions, sorting);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridColumnSortingPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridColumnSortingPipe, isStandalone: true, name: "pivotGridColumnSort" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridColumnSortingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridColumnSort',
                    pure: true,
                    standalone: true
                }]
        }] });
/**
 * @hidden
 */
export class IgxPivotGridSortingPipe {
    constructor(gridAPI) {
        this.gridAPI = gridAPI;
    }
    transform(collection, config, sorting, _pipeTrigger) {
        let result;
        const allDimensions = config.rows || [];
        const enabledDimensions = allDimensions.filter(x => x && x.enabled);
        const expressions = PivotSortUtil.generateDimensionSortingExpressions(enabledDimensions);
        if (!expressions.length) {
            result = collection;
        }
        else {
            result = DataUtil.sort(cloneArray(collection, true), expressions, sorting, this.gridAPI.grid);
        }
        return result;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridSortingPipe, deps: [{ token: i1.GridBaseAPIService }], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridSortingPipe, isStandalone: true, name: "pivotGridSort" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridSortingPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'pivotGridSort',
                    pure: true,
                    standalone: true
                }]
        }], ctorParameters: () => [{ type: i1.GridBaseAPIService }] });
/**
 * @hidden
 */
export class IgxFilterPivotItemsPipe {
    transform(collection, filterCriteria, _pipeTrigger) {
        if (!collection) {
            return collection;
        }
        let copy = collection.slice(0);
        if (filterCriteria && filterCriteria.length > 0) {
            const filterFunc = (c) => {
                const filterText = c.member || c.memberName;
                if (!filterText) {
                    return false;
                }
                return (filterText
                    .toLocaleLowerCase()
                    .indexOf(filterCriteria.toLocaleLowerCase()) >= 0 ||
                    (c.children?.some(filterFunc) ?? false));
            };
            copy = collection.filter(filterFunc);
        }
        return copy;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxFilterPivotItemsPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxFilterPivotItemsPipe, isStandalone: true, name: "filterPivotItems" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxFilterPivotItemsPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: "filterPivotItems",
                    standalone: true
                }]
        }] });
export class IgxPivotGridCellStyleClassesPipe {
    transform(cssClasses, _, rowData, columnData, index, __) {
        if (!cssClasses) {
            return '';
        }
        const result = [];
        for (const cssClass of Object.keys(cssClasses)) {
            const callbackOrValue = cssClasses[cssClass];
            const apply = typeof callbackOrValue === 'function' ?
                callbackOrValue(rowData, columnData, resolveNestedPath(rowData, columnData.field), index) : callbackOrValue;
            if (apply) {
                result.push(cssClass);
            }
        }
        return result.join(' ');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, isStandalone: true, name: "igxPivotCellStyleClasses" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotGridCellStyleClassesPipe, decorators: [{
            type: Pipe,
            args: [{
                    name: 'igxPivotCellStyleClasses',
                    standalone: true
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3QtZ3JpZC5waXBlcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9waXZvdC1ncmlkL3Bpdm90LWdyaWQucGlwZXMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQWlCLE1BQU0sZUFBZSxDQUFDO0FBQzVELE9BQU8sRUFBRSxVQUFVLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNqRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFDM0QsT0FBTyxFQUFFLHdCQUF3QixFQUE2QixNQUFNLGtEQUFrRCxDQUFDO0FBQ3ZILE9BQU8sRUFBRSxxQ0FBcUMsRUFBRSxNQUFNLDJDQUEyQyxDQUFDO0FBQ2xHLE9BQU8sRUFBRSxVQUFVLEVBQXNCLE1BQU0sMENBQTBDLENBQUM7QUFDMUYsT0FBTyxFQUNILGdDQUFnQyxFQUFFLDZCQUE2QixFQUMvRCwwQkFBMEIsRUFDN0IsTUFBTSxzQ0FBc0MsQ0FBQztBQUc5QyxPQUFPLEVBQVksYUFBYSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFHbkUsT0FBTyxFQUFFLGtCQUFrQixFQUE0SCxNQUFNLHdCQUF3QixDQUFDO0FBQ3RMLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNsRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7QUFHekM7O0dBRUc7QUFNSCxNQUFNLE9BQU8sZUFBZTtJQUV4QixnQkFBZ0IsQ0FBQztJQUVWLFNBQVMsQ0FDWixVQUFlLEVBQ2YsTUFBMkIsRUFDM0IsYUFBaUMsRUFDakMsQ0FBb0IsRUFDcEIsWUFBcUIsRUFDckIsRUFBRztRQUVILE1BQU0sU0FBUyxHQUFHLE1BQU0sQ0FBQyxTQUFTLElBQUksa0JBQWtCLENBQUM7UUFDekQs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QUFVLENBQUMsQ0FBQztnQkFDakQsZUFBZSxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsaUJBQWlCLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDO1lBQ2hILElBQUksS0FBSyxFQUFFLENBQUM7Z0JBQ1IsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUMxQixDQUFDO1FBQ0wsQ0FBQztRQUVELE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QixDQUFDOzhHQW5CUSxnQ0FBZ0M7NEdBQWhDLGdDQUFnQzs7MkZBQWhDLGdDQUFnQztrQkFKNUMsSUFBSTttQkFBQztvQkFDRixJQUFJLEVBQUUsMEJBQTBCO29CQUNoQyxVQUFVLEVBQUUsSUFBSTtpQkFDbkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3QsIFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGNsb25lQXJyYXksIHJlc29sdmVOZXN0ZWRQYXRoIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBEYXRhVXRpbCB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9kYXRhLXV0aWwnO1xuaW1wb3J0IHsgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlLCBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2ZpbHRlcmluZy1leHByZXNzaW9ucy10cmVlJztcbmltcG9ydCB7IERlZmF1bHRQaXZvdEdyaWRSZWNvcmRTb3J0aW5nU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvcGl2b3Qtc29ydC1zdHJhdGVneSc7XG5pbXBvcnQgeyBGaWx0ZXJVdGlsLCBJRmlsdGVyaW5nU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvZmlsdGVyaW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7XG4gICAgRGltZW5zaW9uVmFsdWVzRmlsdGVyaW5nU3RyYXRlZ3ksIFBpdm90Q29sdW1uRGltZW5zaW9uc1N0cmF0ZWd5LFxuICAgIFBpdm90Um93RGltZW5zaW9uc1N0cmF0ZWd5XG59IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9waXZvdC1zdHJhdGVneSc7XG5pbXBvcnQgeyBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuLi8uLi9kYXRhLW9wZXJhdGlvbnMvc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBHcmlkVHlwZSwgSUdYX0dSSURfQkFTRSB9IGZyb20gJy4uL2NvbW1vbi9ncmlkLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JpZFNvcnRpbmdTdHJhdGVneSB9IGZyb20gJy4uL2NvbW1vbi9zdHJhdGVneSc7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZURpcmVjdGl2ZSB9IGZyb20gJy4uL2dyaWQtYmFzZS5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgREVGQVVMVF9QSVZPVF9LRVlTLCBJUGl2b3RDb25maWd1cmF0aW9uLCBJUGl2b3REaW1lbnNpb24sIElQaXZvdEdyaWRDb2x1bW4sIElQaXZvdEdyaWRHcm91cFJlY29yZCwgSVBpdm90R3JpZFJlY29yZCwgSVBpdm90S2V5cywgSVBpdm90VmFsdWUgfSBmcm9tICcuL3Bpdm90LWdyaWQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFBpdm90U29ydFV0aWwgfSBmcm9tICcuL3Bpdm90LXNvcnQtdXRpbCc7XG5pbXBvcnQgeyBQaXZvdFV0aWwgfSBmcm9tICcuL3Bpdm90LXV0aWwnO1xuaW1wb3J0IHsgSURhdGFDbG9uZVN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2RhdGEtY2xvbmUtc3RyYXRlZ3knO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRSb3cnLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdFJvd1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAgIGNvbnN0cnVjdG9yKCkgeyB9XG5cbiAgICBwdWJsaWMgdHJhbnNmb3JtKFxuICAgICAgICBjb2xsZWN0aW9uOiBhbnksXG4gICAgICAgIGNvbmZpZzogSVBpdm90Q29uZmlndXJhdGlvbixcbiAgICAgICAgY2xvbmVTdHJhdGVneTogSURhdGFDbG9uZVN0cmF0ZWd5LFxuICAgICAgICBfOiBNYXA8YW55LCBib29sZWFuPixcbiAgICAgICAgX3BpcGVUcmlnZ2VyPzogbnVtYmVyLFxuICAgICAgICBfXz9cbiAgICApOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBjb25zdCBwaXZvdEtleXMgPSBjb25maWcucGl2b3RLZXlzIHx8IERFRkFVTFRfUElWT1RfS0VZUztcbiAgICAgICAgY29uc3QgZW5hYmxlZFJvd3MgPSBjb25maWcucm93cz8uZmlsdGVyKHggPT4geC5lbmFibGVkKSB8fCBbXTtcbiAgICAgICAgY29uc3QgZW5hYmxlZENvbHVtbnMgPSBjb25maWcuY29sdW1ucz8uZmlsdGVyKHggPT4geC5lbmFibGVkKSB8fCBbXTtcbiAgICAgICAgY29uc3QgZW5hYmxlZFZhbHVlcyA9IGNvbmZpZy52YWx1ZXM/LmZpbHRlcih4ID0+IHguZW5hYmxlZCkgfHwgW107XG4gICAgICAgIGlmIChlbmFibGVkUm93cy5sZW5ndGggPT09IDAgJiYgZW5hYmxlZENvbHVtbnMubGVuZ3RoID09PSAwICYmIGVuYWJsZWRWYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBub3RoaW5nIHRvIGdyb3VwIGFuZCBhZ2dyZWdhdGUgYnkgLi4uXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93U3RyYXRlZ3kgPSBjb25maWcucm93U3RyYXRlZ3kgfHwgUGl2b3RSb3dEaW1lbnNpb25zU3RyYXRlZ3kuaW5zdGFuY2UoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNsb25lQXJyYXkoY29sbGVjdGlvbiwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiByb3dTdHJhdGVneS5wcm9jZXNzKGRhdGEsIGVuYWJsZWRSb3dzLCBjb25maWcudmFsdWVzLCBjbG9uZVN0cmF0ZWd5LCBwaXZvdEtleXMpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKiBUcmFuc2Zvcm1zIGdlbmVyaWMgYXJyYXkgZGF0YSBpbnRvIElQaXZvdEdyaWRSZWNvcmRbXVxuICovXG5AUGlwZSh7XG4gICAgbmFtZTogJ3Bpdm90R3JpZEF1dG9UcmFuc2Zvcm0nLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEF1dG9UcmFuc2Zvcm0gaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwdWJsaWMgdHJhbnNmb3JtKFxuICAgICAgICBjb2xsZWN0aW9uOiBhbnlbXSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBfcGlwZVRyaWdnZXI/OiBudW1iZXIsXG4gICAgICAgIF9fPyxcbiAgICApOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBsZXQgbmVlZHNUcmFuc2Zvcm1hdGlvbiA9IGZhbHNlO1xuICAgICAgICBpZiAoY29sbGVjdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBuZWVkc1RyYW5zZm9ybWF0aW9uID0gIXRoaXMuaXNQaXZvdFJlY29yZChjb2xsZWN0aW9uWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghbmVlZHNUcmFuc2Zvcm1hdGlvbikgcmV0dXJuIGNvbGxlY3Rpb247XG5cbiAgICAgICAgY29uc3QgcmVzID0gdGhpcy5wcm9jZXNzQ29sbGVjdGlvblRvUGl2b3RSZWNvcmQoY29uZmlnLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNQaXZvdFJlY29yZChhcmc6IElQaXZvdEdyaWRSZWNvcmQpOiBhcmcgaXMgSVBpdm90R3JpZFJlY29yZCB7XG4gICAgICAgIHJldHVybiAhIShhcmcgYXMgSVBpdm90R3JpZFJlY29yZCkuYWdncmVnYXRpb25WYWx1ZXM7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHByb2Nlc3NDb2xsZWN0aW9uVG9QaXZvdFJlY29yZChjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sIGNvbGxlY3Rpb246IGFueVtdKTogSVBpdm90R3JpZFJlY29yZFtdIHtcbiAgICAgICAgY29uc3QgcGl2b3RLZXlzOiBJUGl2b3RLZXlzID0gY29uZmlnLnBpdm90S2V5cyB8fCBERUZBVUxUX1BJVk9UX0tFWVM7XG4gICAgICAgIGNvbnN0IGVuYWJsZWRSb3dzID0gY29uZmlnLnJvd3MuZmlsdGVyKHggPT4geC5lbmFibGVkKTtcbiAgICAgICAgY29uc3QgYWxsRmxhdDogSVBpdm90RGltZW5zaW9uW10gPSBQaXZvdFV0aWwuZmxhdHRlbihlbmFibGVkUm93cyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDogSVBpdm90R3JpZFJlY29yZFtdID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVjIG9mIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBpdm90UmVjOiBJUGl2b3RHcmlkUmVjb3JkID0ge1xuICAgICAgICAgICAgICAgIGRpbWVuc2lvblZhbHVlczogbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKSxcbiAgICAgICAgICAgICAgICBhZ2dyZWdhdGlvblZhbHVlczogbmV3IE1hcDxzdHJpbmcsIHN0cmluZz4oKSxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogbmV3IE1hcDxzdHJpbmcsIElQaXZvdEdyaWRSZWNvcmRbXT4oKSxcbiAgICAgICAgICAgICAgICBkaW1lbnNpb25zOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhyZWMpXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGltID0gYWxsRmxhdC5maW5kKHggPT4geC5tZW1iZXJOYW1lID09PSBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChkaW0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9maWVsZCBoYXMgbWF0Y2hpbmcgZGltZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgIHBpdm90UmVjLmRpbWVuc2lvbnMucHVzaChkaW0pO1xuICAgICAgICAgICAgICAgICAgICBwaXZvdFJlYy5kaW1lbnNpb25WYWx1ZXMuc2V0KGtleSwgcmVjW2tleV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5LmluZGV4T2YocGl2b3RLZXlzLnJvd0RpbWVuc2lvblNlcGFyYXRvciArIHBpdm90S2V5cy5yZWNvcmRzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGQgdGhhdCBjb250YWlucyBjaGlsZCBjb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbUtleSA9IGtleS5zbGljZSgwLCBrZXkuaW5kZXhPZihwaXZvdEtleXMucm93RGltZW5zaW9uU2VwYXJhdG9yICsgcGl2b3RLZXlzLnJlY29yZHMpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGREYXRhID0gcmVjW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkUGl2b3REYXRhID0gdGhpcy5wcm9jZXNzQ29sbGVjdGlvblRvUGl2b3RSZWNvcmQoY29uZmlnLCBjaGlsZERhdGEpO1xuICAgICAgICAgICAgICAgICAgICBwaXZvdFJlYy5jaGlsZHJlbi5zZXQoZGltS2V5LCBjaGlsZFBpdm90RGF0YSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYW4gYWdncmVnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgcGl2b3RSZWMuYWdncmVnYXRpb25WYWx1ZXMuc2V0KGtleSwgcmVjW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5lZCA9IFBpdm90VXRpbC5mbGF0dGVuKGNvbmZpZy5yb3dzKTtcbiAgICAgICAgICAgIHBpdm90UmVjLmRpbWVuc2lvbnMuc29ydCgoeCwgeSkgPT4gZmxhdHRlbmVkLmluZGV4T2YoeCkgLSBmbGF0dGVuZWQuaW5kZXhPZih5KSk7XG4gICAgICAgICAgICByZXN1bHQucHVzaChwaXZvdFJlYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAncGl2b3RHcmlkUm93RXhwYW5zaW9uJyxcbiAgICBwdXJlOiB0cnVlLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4UGl2b3RSb3dFeHBhbnNpb25QaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG5cbiAgICBjb25zdHJ1Y3RvcihASW5qZWN0KElHWF9HUklEX0JBU0UpIHByaXZhdGUgZ3JpZD86IEdyaWRUeXBlKSB7IH1cblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IElQaXZvdEdyaWRSZWNvcmRbXSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBleHBhbnNpb25TdGF0ZXM6IE1hcDxhbnksIGJvb2xlYW4+LFxuICAgICAgICBkZWZhdWx0RXhwYW5kOiBib29sZWFuLFxuICAgICAgICBfcGlwZVRyaWdnZXI/OiBudW1iZXIsXG4gICAgICAgIF9fPyxcbiAgICApOiBJUGl2b3RHcmlkUmVjb3JkW10ge1xuICAgICAgICBjb25zdCBlbmFibGVkUm93cyA9IGNvbmZpZy5yb3dzPy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpIHx8IFtdO1xuICAgICAgICBjb25zdCBkYXRhID0gY29sbGVjdGlvbiA/IGNsb25lQXJyYXkoY29sbGVjdGlvbiwgdHJ1ZSkgOiBbXTtcbiAgICAgICAgZm9yIChjb25zdCByb3cgb2YgZW5hYmxlZFJvd3MpIHtcbiAgICAgICAgICAgIFBpdm90VXRpbC5mbGF0dGVuR3JvdXBzKGRhdGEsIHJvdywgZXhwYW5zaW9uU3RhdGVzLCBkZWZhdWx0RXhwYW5kKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaW5hbERhdGEgPSBlbmFibGVkUm93cy5sZW5ndGggPiAwID9cbiAgICAgICAgICAgIGRhdGEuZmlsdGVyKHggPT4geC5kaW1lbnNpb25zLmxlbmd0aCA9PT0gZW5hYmxlZFJvd3MubGVuZ3RoKSA6IGRhdGE7XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZCkge1xuICAgICAgICAgICAgdGhpcy5ncmlkLnNldEZpbHRlcmVkU29ydGVkRGF0YShmaW5hbERhdGEsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxEYXRhO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAncGl2b3RHcmlkQ2VsbE1lcmdpbmcnLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdENlbGxNZXJnaW5nUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoSUdYX0dSSURfQkFTRSkgcHJpdmF0ZSBncmlkOiBHcmlkVHlwZSkgeyB9XG4gICAgcHVibGljIHRyYW5zZm9ybShcbiAgICAgICAgY29sbGVjdGlvbjogSVBpdm90R3JpZFJlY29yZFtdLFxuICAgICAgICBjb25maWc6IElQaXZvdENvbmZpZ3VyYXRpb24sXG4gICAgICAgIGRpbTogSVBpdm90RGltZW5zaW9uLFxuICAgICAgICBfcGlwZVRyaWdnZXI/OiBudW1iZXJcbiAgICApOiBJUGl2b3RHcmlkR3JvdXBSZWNvcmRbXSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uLmxlbmd0aCA9PT0gMCB8fCBjb25maWcucm93cy5sZW5ndGggPT09IDApIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICBjb25zdCBkYXRhOiBJUGl2b3RHcmlkR3JvdXBSZWNvcmRbXSA9IGNvbGxlY3Rpb24gPyBjbG9uZUFycmF5KGNvbGxlY3Rpb24sIHRydWUpIDogW107XG4gICAgICAgIGNvbnN0IHJlczogSVBpdm90R3JpZEdyb3VwUmVjb3JkW10gPSBbXTtcblxuICAgICAgICBjb25zdCBlbmFibGVkUm93cyA9IGNvbmZpZy5yb3dzPy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpO1xuICAgICAgICBsZXQgZ3JvdXBEYXRhOiBJUGl2b3RHcmlkR3JvdXBSZWNvcmRbXSA9IFtdO1xuICAgICAgICBsZXQgcHJldklkO1xuICAgICAgICBjb25zdCBpbmRleCA9IGVuYWJsZWRSb3dzLmluZGV4T2YoZGltKTtcbiAgICAgICAgZm9yIChjb25zdCByZWMgb2YgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERpbSA9IHJlYy5kaW1lbnNpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gUGl2b3RVdGlsLmdldFJlY29yZEtleShyZWMsIGN1cnJlbnREaW0pO1xuICAgICAgICAgICAgaWYgKGdyb3VwRGF0YS5sZW5ndGggPiAwICYmIHByZXZJZCAhPT0gaWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoID0gZ3JvdXBEYXRhLmxlbmd0aCA+IDEgPyBncm91cERhdGEubGVuZ3RoICogdGhpcy5ncmlkLnJlbmRlcmVkUm93SGVpZ2h0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGdyb3VwRGF0YVswXS5oZWlnaHQgPSBoO1xuICAgICAgICAgICAgICAgIGdyb3VwRGF0YVswXS5yb3dTcGFuID0gZ3JvdXBEYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXMucHVzaChncm91cERhdGFbMF0pO1xuICAgICAgICAgICAgICAgIGdyb3VwRGF0YSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3JvdXBEYXRhLnB1c2gocmVjKTtcbiAgICAgICAgICAgIHByZXZJZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncm91cERhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgaCA9IGdyb3VwRGF0YS5sZW5ndGggPiAxID8gZ3JvdXBEYXRhLmxlbmd0aCAqIHRoaXMuZ3JpZC5yb3dIZWlnaHQgKyAoZ3JvdXBEYXRhLmxlbmd0aCAtIDEpICsgMSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGdyb3VwRGF0YVswXS5oZWlnaHQgPSBoO1xuICAgICAgICAgICAgZ3JvdXBEYXRhWzBdLnJvd1NwYW4gPSBncm91cERhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcmVzLnB1c2goZ3JvdXBEYXRhWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRDb2x1bW4nLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdENvbHVtblBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcblxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oXG4gICAgICAgIGNvbGxlY3Rpb246IElQaXZvdEdyaWRSZWNvcmRbXSxcbiAgICAgICAgY29uZmlnOiBJUGl2b3RDb25maWd1cmF0aW9uLFxuICAgICAgICBjbG9uZVN0cmF0ZWd5OiBJRGF0YUNsb25lU3RyYXRlZ3ksXG4gICAgICAgIF86IE1hcDxhbnksIGJvb2xlYW4+LFxuICAgICAgICBfcGlwZVRyaWdnZXI/OiBudW1iZXIsXG4gICAgICAgIF9fP1xuICAgICk6IElQaXZvdEdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGNvbnN0IHBpdm90S2V5cyA9IGNvbmZpZy5waXZvdEtleXMgfHwgREVGQVVMVF9QSVZPVF9LRVlTO1xuICAgICAgICBjb25zdCBlbmFibGVkQ29sdW1ucyA9IGNvbmZpZy5jb2x1bW5zPy5maWx0ZXIoeCA9PiB4LmVuYWJsZWQpIHx8IFtdO1xuICAgICAgICBjb25zdCBlbmFibGVkVmFsdWVzID0gY29uZmlnLnZhbHVlcz8uZmlsdGVyKHggPT4geC5lbmFibGVkKSB8fCBbXTtcblxuICAgICAgICBjb25zdCBjb2xTdHJhdGVneSA9IGNvbmZpZy5jb2x1bW5TdHJhdGVneSB8fCBQaXZvdENvbHVtbkRpbWVuc2lvbnNTdHJhdGVneS5pbnN0YW5jZSgpO1xuICAgICAgICBjb25zdCBkYXRhID0gY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNvbFN0cmF0ZWd5LnByb2Nlc3MoZGF0YSwgZW5hYmxlZENvbHVtbnMsIGVuYWJsZWRWYWx1ZXMsIGNsb25lU3RyYXRlZ3ksIHBpdm90S2V5cyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRGaWx0ZXInLFxuICAgIHB1cmU6IHRydWUsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEdyaWRGaWx0ZXJQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VEaXJlY3RpdmUgJiBHcmlkVHlwZT4pIHsgfVxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogYW55W10sXG4gICAgICAgIGNvbmZpZzogSVBpdm90Q29uZmlndXJhdGlvbixcbiAgICAgICAgZmlsdGVyU3RyYXRlZ3k6IElGaWx0ZXJpbmdTdHJhdGVneSxcbiAgICAgICAgYWR2YW5jZWRFeHByZXNzaW9uc1RyZWU6IElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUsXG4gICAgICAgIF9maWx0ZXJQaXBlVHJpZ2dlcjogbnVtYmVyLFxuICAgICAgICBfcGlwZVRyaWdnZXI6IG51bWJlcik6IGFueVtdIHtcbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnNUcmVlID0gUGl2b3RVdGlsLmJ1aWxkRXhwcmVzc2lvblRyZWUoY29uZmlnKTtcblxuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIGV4cHJlc3Npb25zVHJlZSxcbiAgICAgICAgICAgIHN0cmF0ZWd5OiBmaWx0ZXJTdHJhdGVneSB8fCBuZXcgRGltZW5zaW9uVmFsdWVzRmlsdGVyaW5nU3RyYXRlZ3koKSxcbiAgICAgICAgICAgIGFkdmFuY2VkRXhwcmVzc2lvbnNUcmVlXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZS5lbXB0eShzdGF0ZS5leHByZXNzaW9uc1RyZWUpICYmIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZS5lbXB0eShzdGF0ZS5hZHZhbmNlZEV4cHJlc3Npb25zVHJlZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRmlsdGVyVXRpbC5maWx0ZXIoY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKSwgc3RhdGUsIHRoaXMuZ3JpZEFQSS5ncmlkKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6ICdwaXZvdEdyaWRDb2x1bW5Tb3J0JyxcbiAgICBwdXJlOiB0cnVlLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4UGl2b3RHcmlkQ29sdW1uU29ydGluZ1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwdWJsaWMgdHJhbnNmb3JtKFxuICAgICAgICBjb2xsZWN0aW9uOiBJUGl2b3RHcmlkUmVjb3JkW10sXG4gICAgICAgIGV4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSxcbiAgICAgICAgc29ydGluZzogSUdyaWRTb3J0aW5nU3RyYXRlZ3ksXG4gICAgICAgIF9waXBlVHJpZ2dlcjogbnVtYmVyXG4gICAgKTogSVBpdm90R3JpZFJlY29yZFtdIHtcbiAgICAgICAgbGV0IHJlc3VsdDogSVBpdm90R3JpZFJlY29yZFtdO1xuXG4gICAgICAgIGlmICghZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBleHByIG9mIGV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgZXhwci5zdHJhdGVneSA9IERlZmF1bHRQaXZvdEdyaWRSZWNvcmRTb3J0aW5nU3RyYXRlZ3kuaW5zdGFuY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IFBpdm90VXRpbC5zb3J0KGNsb25lQXJyYXkoY29sbGVjdGlvbiwgdHJ1ZSksIGV4cHJlc3Npb25zLCBzb3J0aW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBQaXBlKHtcbiAgICBuYW1lOiAncGl2b3RHcmlkU29ydCcsXG4gICAgcHVyZTogdHJ1ZSxcbiAgICBzdGFuZGFsb25lOiB0cnVlXG59KVxuZXhwb3J0IGNsYXNzIElneFBpdm90R3JpZFNvcnRpbmdQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBncmlkQVBJOiBHcmlkQmFzZUFQSVNlcnZpY2U8SWd4R3JpZEJhc2VEaXJlY3RpdmUgJiBHcmlkVHlwZT4pIHsgfVxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29sbGVjdGlvbjogYW55W10sIGNvbmZpZzogSVBpdm90Q29uZmlndXJhdGlvbiwgc29ydGluZzogSUdyaWRTb3J0aW5nU3RyYXRlZ3ksIF9waXBlVHJpZ2dlcjogbnVtYmVyKTogYW55W10ge1xuICAgICAgICBsZXQgcmVzdWx0OiBhbnlbXTtcbiAgICAgICAgY29uc3QgYWxsRGltZW5zaW9ucyA9IGNvbmZpZy5yb3dzIHx8IFtdO1xuICAgICAgICBjb25zdCBlbmFibGVkRGltZW5zaW9ucyA9IGFsbERpbWVuc2lvbnMuZmlsdGVyKHggPT4geCAmJiB4LmVuYWJsZWQpO1xuICAgICAgICBjb25zdCBleHByZXNzaW9ucyA9IFBpdm90U29ydFV0aWwuZ2VuZXJhdGVEaW1lbnNpb25Tb3J0aW5nRXhwcmVzc2lvbnMoZW5hYmxlZERpbWVuc2lvbnMpO1xuICAgICAgICBpZiAoIWV4cHJlc3Npb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IERhdGFVdGlsLnNvcnQoY2xvbmVBcnJheShjb2xsZWN0aW9uLCB0cnVlKSwgZXhwcmVzc2lvbnMsIHNvcnRpbmcsIHRoaXMuZ3JpZEFQSS5ncmlkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQFBpcGUoe1xuICAgIG5hbWU6IFwiZmlsdGVyUGl2b3RJdGVtc1wiLFxuICAgIHN0YW5kYWxvbmU6IHRydWVcbn0pXG5leHBvcnQgY2xhc3MgSWd4RmlsdGVyUGl2b3RJdGVtc1BpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwdWJsaWMgdHJhbnNmb3JtKFxuICAgICAgICBjb2xsZWN0aW9uOiAoSVBpdm90RGltZW5zaW9uIHwgSVBpdm90VmFsdWUpW10sXG4gICAgICAgIGZpbHRlckNyaXRlcmlhOiBzdHJpbmcsXG4gICAgICAgIF9waXBlVHJpZ2dlcjogbnVtYmVyXG4gICAgKTogYW55W10ge1xuICAgICAgICBpZiAoIWNvbGxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb3B5ID0gY29sbGVjdGlvbi5zbGljZSgwKTtcbiAgICAgICAgaWYgKGZpbHRlckNyaXRlcmlhICYmIGZpbHRlckNyaXRlcmlhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlckZ1bmMgPSAoYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlclRleHQgPSBjLm1lbWJlciB8fCBjLm1lbWJlck5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXJUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyVGV4dFxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvTG9jYWxlTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5pbmRleE9mKGZpbHRlckNyaXRlcmlhLnRvTG9jYWxlTG93ZXJDYXNlKCkpID49IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgKGMuY2hpbGRyZW4/LnNvbWUoZmlsdGVyRnVuYykgPz8gZmFsc2UpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb3B5ID0gY29sbGVjdGlvbi5maWx0ZXIoZmlsdGVyRnVuYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEdyaWRTdHlsZUNTU1Byb3BlcnR5IHtcbiAgICBbcHJvcDogc3RyaW5nXTogYW55O1xufVxuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2lneFBpdm90Q2VsbFN0eWxlQ2xhc3NlcycsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdEdyaWRDZWxsU3R5bGVDbGFzc2VzUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXG4gICAgcHVibGljIHRyYW5zZm9ybShjc3NDbGFzc2VzOiBHcmlkU3R5bGVDU1NQcm9wZXJ0eSwgXzogYW55LCByb3dEYXRhOiBJUGl2b3RHcmlkUmVjb3JkLCBjb2x1bW5EYXRhOiBJUGl2b3RHcmlkQ29sdW1uLCBpbmRleDogbnVtYmVyLCBfXzogbnVtYmVyKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKCFjc3NDbGFzc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGNzc0NsYXNzIG9mIE9iamVjdC5rZXlzKGNzc0NsYXNzZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja09yVmFsdWUgPSBjc3NDbGFzc2VzW2Nzc0NsYXNzXTtcbiAgICAgICAgICAgIGNvbnN0IGFwcGx5ID0gdHlwZW9mIGNhbGxiYWNrT3JWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tPclZhbHVlKHJvd0RhdGEsIGNvbHVtbkRhdGEsIHJlc29sdmVOZXN0ZWRQYXRoKHJvd0RhdGEsIGNvbHVtbkRhdGEuZmllbGQpLCBpbmRleCkgOiBjYWxsYmFja09yVmFsdWU7XG4gICAgICAgICAgICBpZiAoYXBwbHkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjc3NDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJyAnKTtcbiAgICB9XG59XG4iXX0=
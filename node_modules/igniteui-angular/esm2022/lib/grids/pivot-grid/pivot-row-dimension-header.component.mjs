import { ChangeDetectionStrategy, Component, HostListener, Inject } from '@angular/core';
import { IGX_GRID_BASE } from '../common/grid.interface';
import { IgxGridHeaderComponent } from '../headers/grid-header.component';
import { SortingIndexPipe } from '../headers/pipes';
import { NgTemplateOutlet, NgIf, NgClass } from '@angular/common';
import { IgxIconComponent } from '../../icon/icon.component';
import { SortingDirection } from '../../data-operations/sorting-strategy';
import { takeUntil } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "../resizing/pivot-grid/pivot-resizing.service";
/**
 * @hidden
 */
export class IgxPivotRowDimensionHeaderComponent extends IgxGridHeaderComponent {
    constructor(grid, colResizingService, cdr, refInstance) {
        super(grid, colResizingService, cdr, refInstance);
        this.colResizingService = colResizingService;
        this.refInstance = refInstance;
        this.pivotGrid = this.grid;
        this.pivotGrid.dimensionsSortingExpressionsChange
            .pipe(takeUntil(this._destroy$))
            .subscribe((_) => this.setSortIndex());
    }
    onClick(event) {
        event.preventDefault();
    }
    /**
     * @hidden @internal
     */
    get selectable() {
        return false;
    }
    /**
     * @hidden @internal
     */
    onSortingIconClick(event) {
        event.stopPropagation();
        const dimIndex = this.pivotGrid.rowDimensions.findIndex((target) => target.memberName === this.column.field);
        const dim = this.pivotGrid.rowDimensions[dimIndex];
        const startDirection = dim.sortDirection || SortingDirection.None;
        const direction = startDirection + 1 > SortingDirection.Desc ?
            SortingDirection.None : startDirection + 1;
        this.pivotGrid.sortDimension(dim, direction);
    }
    getSortDirection() {
        const dim = this.pivotGrid.rowDimensions.find((x) => x.memberName === this.column.field);
        this.sortDirection = dim?.sortDirection || SortingDirection.None;
    }
    setSortIndex() {
        if (this.column.sortable && this.sortIconContainer) {
            const dimIndex = this.pivotGrid.rowDimensions.findIndex((target) => target.memberName === this.column.field);
            const dim = this.pivotGrid.rowDimensions[dimIndex];
            let newSortIndex = -1;
            if (dim.sortDirection) {
                let priorSortedDims = 0;
                for (let i = 0; i < dimIndex; i++) {
                    if (this.pivotGrid.rowDimensions[i].sortDirection) {
                        priorSortedDims++;
                    }
                }
                // Sort index starts from 1.
                newSortIndex = priorSortedDims + 1;
            }
            this.sortIconContainer.nativeElement.setAttribute("data-sortIndex", newSortIndex >= 0 ? newSortIndex : "");
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowDimensionHeaderComponent, deps: [{ token: IGX_GRID_BASE }, { token: i1.IgxPivotColumnResizingService }, { token: i0.ChangeDetectorRef }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.0.1", type: IgxPivotRowDimensionHeaderComponent, isStandalone: true, selector: "igx-pivot-row-dimension-header", host: { listeners: { "click": "onClick($event)" } }, usesInheritance: true, ngImport: i0, template: "<ng-template #defaultColumn>\n    <span [title]=\"title\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<ng-template #defaultESFHeaderIconTemplate>\n    <igx-icon>more_vert</igx-icon>\n</ng-template>\n\n<ng-template #defaultSortHeaderIconTemplate>\n    <igx-icon>{{ sortDirection < 2 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n</ng-template>\n\n<span class=\"igx-grid-th__title\">\n    <ng-container\n        *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<ng-container *ngIf=\"!column.columnGroup\">\n    <div class=\"igx-grid-th__icons\">\n        <ng-container *ngIf=\"column.sortable && !disabled\">\n            <div #sortIconContainer class=\"sort-icon\"\n                [attr.data-sortIndex]=\"(grid.sortingOptions.mode === 'single' && grid.sortingExpressions.length <=1) ? null : column.field | sortingIndex:grid.sortingExpressions\"\n                (pointerdown)=\"onPointerDownIndicator($event)\" (click)=\"onSortingIconClick($event)\">\n                <ng-container *ngTemplateOutlet=\"sortIconTemplate; context: { $implicit:  this }\"></ng-container>\n            </div>\n        </ng-container>\n        <ng-container *ngIf=\"grid.allowFiltering && column.filterable && grid.filterMode === 'excelStyleFilter'\">\n            <div [ngClass]=\"filterIconClassName\" (pointerdown)=\"onPointerDownIndicator($event)\" (click)=\"onFilteringIconClick($event)\" >\n                <ng-container *ngTemplateOutlet=\"esfIconTemplate; context: { $implicit:  this }\"></ng-container>\n            </div>\n        </ng-container>\n    </div>\n</ng-container>\n", dependencies: [{ kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: NgClass, selector: "[ngClass]", inputs: ["class", "ngClass"] }, { kind: "pipe", type: SortingIndexPipe, name: "sortingIndex" }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxPivotRowDimensionHeaderComponent, decorators: [{
            type: Component,
            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, selector: 'igx-pivot-row-dimension-header', standalone: true, imports: [IgxIconComponent, NgTemplateOutlet, NgIf, NgClass, SortingIndexPipe], template: "<ng-template #defaultColumn>\n    <span [title]=\"title\">{{ column.header || column.field }}</span>\n</ng-template>\n\n<ng-template #defaultESFHeaderIconTemplate>\n    <igx-icon>more_vert</igx-icon>\n</ng-template>\n\n<ng-template #defaultSortHeaderIconTemplate>\n    <igx-icon>{{ sortDirection < 2 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\n</ng-template>\n\n<span class=\"igx-grid-th__title\">\n    <ng-container\n        *ngTemplateOutlet=\"column.headerTemplate ? column.headerTemplate : defaultColumn; context: { $implicit: column, column: column}\">\n    </ng-container>\n</span>\n<ng-container *ngIf=\"!column.columnGroup\">\n    <div class=\"igx-grid-th__icons\">\n        <ng-container *ngIf=\"column.sortable && !disabled\">\n            <div #sortIconContainer class=\"sort-icon\"\n                [attr.data-sortIndex]=\"(grid.sortingOptions.mode === 'single' && grid.sortingExpressions.length <=1) ? null : column.field | sortingIndex:grid.sortingExpressions\"\n                (pointerdown)=\"onPointerDownIndicator($event)\" (click)=\"onSortingIconClick($event)\">\n                <ng-container *ngTemplateOutlet=\"sortIconTemplate; context: { $implicit:  this }\"></ng-container>\n            </div>\n        </ng-container>\n        <ng-container *ngIf=\"grid.allowFiltering && column.filterable && grid.filterMode === 'excelStyleFilter'\">\n            <div [ngClass]=\"filterIconClassName\" (pointerdown)=\"onPointerDownIndicator($event)\" (click)=\"onFilteringIconClick($event)\" >\n                <ng-container *ngTemplateOutlet=\"esfIconTemplate; context: { $implicit:  this }\"></ng-container>\n            </div>\n        </ng-container>\n    </div>\n</ng-container>\n" }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [IGX_GRID_BASE]
                }] }, { type: i1.IgxPivotColumnResizingService }, { type: i0.ChangeDetectorRef }, { type: i0.ElementRef }], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGl2b3Qtcm93LWRpbWVuc2lvbi1oZWFkZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL3Bpdm90LWdyaWQvcGl2b3Qtcm93LWRpbWVuc2lvbi1oZWFkZXIuY29tcG9uZW50LnRzIiwiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2hlYWRlcnMvZ3JpZC1oZWFkZXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLHVCQUF1QixFQUFxQixTQUFTLEVBQWMsWUFBWSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUV4SCxPQUFPLEVBQVksYUFBYSxFQUFpQixNQUFNLDBCQUEwQixDQUFDO0FBRWxGLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRTFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbEUsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDN0QsT0FBTyxFQUFzQixnQkFBZ0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzlGLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxNQUFNLENBQUM7OztBQUVqQzs7R0FFRztBQVFILE1BQU0sT0FBTyxtQ0FBb0MsU0FBUSxzQkFBc0I7SUFHM0UsWUFDMkIsSUFBYyxFQUNyQixrQkFBaUQsRUFDakUsR0FBc0IsRUFDZixXQUFvQztRQUUzQyxLQUFLLENBQUMsSUFBSSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUpsQyx1QkFBa0Is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SSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxZQUFZLENBQUMsZ0JBQWdCLEVBQUUsWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMvRyxDQUFDO0lBQ0wsQ0FBQzs4R0FsRVEsbUNBQW1DLGtCQUloQyxhQUFhO2tHQUpoQixtQ0FBbUMsc0tDdEJoRCx5cURBaUNBLDRDRGJjLGdCQUFnQiwyRkFBRSxnQkFBZ0Isb0pBQUUsSUFBSSw2RkFBRSxPQUFPLCtFQUFFLGdCQUFnQjs7MkZBRXBFLG1DQUFtQztrQkFQL0MsU0FBUztzQ0FDVyx1QkFBdUIsQ0FBQyxNQUFNLFlBQ3JDLGdDQUFnQyxjQUU5QixJQUFJLFdBQ1AsQ0FBQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLGdCQUFnQixDQUFDOzswQkFNekUsTUFBTTsyQkFBQyxhQUFhOzhJQWNULE9BQU87c0JBRHRCLFlBQVk7dUJBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENoYW5nZURldGVjdG9yUmVmLCBDb21wb25lbnQsIEVsZW1lbnRSZWYsIEhvc3RMaXN0ZW5lciwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEdyaWRUeXBlLCBJR1hfR1JJRF9CQVNFLCBQaXZvdEdyaWRUeXBlIH0gZnJvbSAnLi4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgSWd4R3JpZEhlYWRlckNvbXBvbmVudCB9IGZyb20gJy4uL2hlYWRlcnMvZ3JpZC1oZWFkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IElneFBpdm90Q29sdW1uUmVzaXppbmdTZXJ2aWNlIH0gZnJvbSAnLi4vcmVzaXppbmcvcGl2b3QtZ3JpZC9waXZvdC1yZXNpemluZy5zZXJ2aWNlJztcbmltcG9ydCB7IFNvcnRpbmdJbmRleFBpcGUgfSBmcm9tICcuLi9oZWFkZXJzL3BpcGVzJztcbmltcG9ydCB7IE5nVGVtcGxhdGVPdXRsZXQsIE5nSWYsIE5nQ2xhc3MgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgSWd4SWNvbkNvbXBvbmVudCB9IGZyb20gJy4uLy4uL2ljb24vaWNvbi5jb21wb25lbnQnO1xuaW1wb3J0IHsgSVNvcnRpbmdFeHByZXNzaW9uLCBTb3J0aW5nRGlyZWN0aW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL3NvcnRpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcyc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzZWxlY3RvcjogJ2lneC1waXZvdC1yb3ctZGltZW5zaW9uLWhlYWRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuLi9oZWFkZXJzL2dyaWQtaGVhZGVyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtJZ3hJY29uQ29tcG9uZW50LCBOZ1RlbXBsYXRlT3V0bGV0LCBOZ0lmLCBOZ0NsYXNzLCBTb3J0aW5nSW5kZXhQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQaXZvdFJvd0RpbWVuc2lvbkhlYWRlckNvbXBvbmVudCBleHRlbmRzIElneEdyaWRIZWFkZXJDb21wb25lbnQge1xuICAgIHByaXZhdGUgcGl2b3RHcmlkOiBQaXZvdEdyaWRUeXBlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoSUdYX0dSSURfQkFTRSkgZ3JpZDogR3JpZFR5cGUsXG4gICAgICAgIHB1YmxpYyBvdmVycmlkZSBjb2xSZXNpemluZ1NlcnZpY2U6IElneFBpdm90Q29sdW1uUmVzaXppbmdTZXJ2aWNlLFxuICAgICAgICBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwdWJsaWMgcmVmSW5zdGFuY2U6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+XG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGdyaWQsIGNvbFJlc2l6aW5nU2VydmljZSwgY2RyLCByZWZJbnN0YW5jZSk7XG5cbiAgICAgICAgdGhpcy5waXZvdEdyaWQgPSB0aGlzLmdyaWQgYXMgUGl2b3RHcmlkVHlwZTtcbiAgICAgICAgdGhpcy5waXZvdEdyaWQuZGltZW5zaW9uc1NvcnRpbmdFeHByZXNzaW9uc0NoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKF86IElTb3J0aW5nRXhwcmVzc2lvbltdKSA9PiB0aGlzLnNldFNvcnRJbmRleCgpKTtcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG92ZXJyaWRlIG9uQ2xpY2soZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBvdmVycmlkZSBnZXQgc2VsZWN0YWJsZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG92ZXJyaWRlIG9uU29ydGluZ0ljb25DbGljayhldmVudCkge1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgZGltSW5kZXggPSB0aGlzLnBpdm90R3JpZC5yb3dEaW1lbnNpb25zLmZpbmRJbmRleCgodGFyZ2V0KSA9PiB0YXJnZXQubWVtYmVyTmFtZSA9PT0gdGhpcy5jb2x1bW4uZmllbGQpO1xuICAgICAgICBjb25zdCBkaW0gPSB0aGlzLnBpdm90R3JpZC5yb3dEaW1lbnNpb25zW2RpbUluZGV4XTtcbiAgICAgICAgY29uc3Qgc3RhcnREaXJlY3Rpb24gPSBkaW0uc29ydERpcmVjdGlvbiB8fCBTb3J0aW5nRGlyZWN0aW9uLk5vbmU7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHN0YXJ0RGlyZWN0aW9uICsgMSA+IFNvcnRpbmdEaXJlY3Rpb24uRGVzYyA/XG4gICAgICAgICAgICBTb3J0aW5nRGlyZWN0aW9uLk5vbmUgOiBzdGFydERpcmVjdGlvbiArIDE7XG4gICAgICAgIHRoaXMucGl2b3RHcmlkLnNvcnREaW1lbnNpb24oZGltLCBkaXJlY3Rpb24pO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBnZXRTb3J0RGlyZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBkaW0gPSB0aGlzLnBpdm90R3JpZC5yb3dEaW1lbnNpb25zLmZpbmQoKHgpID0+IHgubWVtYmVyTmFtZSA9PT0gdGhpcy5jb2x1bW4uZmllbGQpO1xuICAgICAgICB0aGlzLnNvcnREaXJlY3Rpb24gPSBkaW0/LnNvcnREaXJlY3Rpb24gfHwgU29ydGluZ0RpcmVjdGlvbi5Ob25lO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXRTb3J0SW5kZXgoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbi5zb3J0YWJsZSAmJiB0aGlzLnNvcnRJY29uQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBkaW1JbmRleCA9IHRoaXMucGl2b3RHcmlkLnJvd0RpbWVuc2lvbnMuZmluZEluZGV4KCh0YXJnZXQpID0+IHRhcmdldC5tZW1iZXJOYW1lID09PSB0aGlzLmNvbHVtbi5maWVsZCk7XG4gICAgICAgICAgICBjb25zdCBkaW0gPSB0aGlzLnBpdm90R3JpZC5yb3dEaW1lbnNpb25zW2RpbUluZGV4XTtcbiAgICAgICAgICAgIGxldCBuZXdTb3J0SW5kZXggPSAtMTtcbiAgICAgICAgICAgIGlmIChkaW0uc29ydERpcmVjdGlvbikge1xuICAgICAgICAgICAgICAgIGxldCBwcmlvclNvcnRlZERpbXMgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGltSW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5waXZvdEdyaWQucm93RGltZW5zaW9uc1tpXS5zb3J0RGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmlvclNvcnRlZERpbXMrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFNvcnQgaW5kZXggc3RhcnRzIGZyb20gMS5cbiAgICAgICAgICAgICAgICBuZXdTb3J0SW5kZXggPSBwcmlvclNvcnRlZERpbXMgKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnNvcnRJY29uQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1zb3J0SW5kZXhcIiwgbmV3U29ydEluZGV4ID49IDAgPyBuZXdTb3J0SW5kZXggOiBcIlwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIjxuZy10ZW1wbGF0ZSAjZGVmYXVsdENvbHVtbj5cbiAgICA8c3BhbiBbdGl0bGVdPVwidGl0bGVcIj57eyBjb2x1bW4uaGVhZGVyIHx8IGNvbHVtbi5maWVsZCB9fTwvc3Bhbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdEVTRkhlYWRlckljb25UZW1wbGF0ZT5cbiAgICA8aWd4LWljb24+bW9yZV92ZXJ0PC9pZ3gtaWNvbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdFNvcnRIZWFkZXJJY29uVGVtcGxhdGU+XG4gICAgPGlneC1pY29uPnt7IHNvcnREaXJlY3Rpb24gPCAyID8gJ2Fycm93X3Vwd2FyZCcgOiAnYXJyb3dfZG93bndhcmQnIH19PC9pZ3gtaWNvbj5cbjwvbmctdGVtcGxhdGU+XG5cbjxzcGFuIGNsYXNzPVwiaWd4LWdyaWQtdGhfX3RpdGxlXCI+XG4gICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cImNvbHVtbi5oZWFkZXJUZW1wbGF0ZSA/IGNvbHVtbi5oZWFkZXJUZW1wbGF0ZSA6IGRlZmF1bHRDb2x1bW47IGNvbnRleHQ6IHsgJGltcGxpY2l0OiBjb2x1bW4sIGNvbHVtbjogY29sdW1ufVwiPlxuICAgIDwvbmctY29udGFpbmVyPlxuPC9zcGFuPlxuPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFjb2x1bW4uY29sdW1uR3JvdXBcIj5cbiAgICA8ZGl2IGNsYXNzPVwiaWd4LWdyaWQtdGhfX2ljb25zXCI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJjb2x1bW4uc29ydGFibGUgJiYgIWRpc2FibGVkXCI+XG4gICAgICAgICAgICA8ZGl2ICNzb3J0SWNvbkNvbnRhaW5lciBjbGFzcz1cInNvcnQtaWNvblwiXG4gICAgICAgICAgICAgICAgW2F0dHIuZGF0YS1zb3J0SW5kZXhdPVwiKGdyaWQuc29ydGluZ09wdGlvbnMubW9kZSA9PT0gJ3NpbmdsZScgJiYgZ3JpZC5zb3J0aW5nRXhwcmVzc2lvbnMubGVuZ3RoIDw9MSkgPyBudWxsIDogY29sdW1uLmZpZWxkIHwgc29ydGluZ0luZGV4OmdyaWQuc29ydGluZ0V4cHJlc3Npb25zXCJcbiAgICAgICAgICAgICAgICAocG9pbnRlcmRvd24pPVwib25Qb2ludGVyRG93bkluZGljYXRvcigkZXZlbnQpXCIgKGNsaWNrKT1cIm9uU29ydGluZ0ljb25DbGljaygkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInNvcnRJY29uVGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiAgdGhpcyB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJncmlkLmFsbG93RmlsdGVyaW5nICYmIGNvbHVtbi5maWx0ZXJhYmxlICYmIGdyaWQuZmlsdGVyTW9kZSA9PT0gJ2V4Y2VsU3R5bGVGaWx0ZXInXCI+XG4gICAgICAgICAgICA8ZGl2IFtuZ0NsYXNzXT1cImZpbHRlckljb25DbGFzc05hbWVcIiAocG9pbnRlcmRvd24pPVwib25Qb2ludGVyRG93bkluZGljYXRvcigkZXZlbnQpXCIgKGNsaWNrKT1cIm9uRmlsdGVyaW5nSWNvbkNsaWNrKCRldmVudClcIiA+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImVzZkljb25UZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6ICB0aGlzIH1cIj48L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L2Rpdj5cbjwvbmctY29udGFpbmVyPlxuIl19
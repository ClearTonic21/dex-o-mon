import { Injectable } from '@angular/core';
import { first } from 'rxjs/operators';
import { NAVIGATION_KEYS, SUPPORTED_KEYS } from '../../core/utils';
import { IgxGridNavigationService } from '../grid-navigation.service';
import * as i0 from "@angular/core";
export class IgxHierarchicalGridNavigationService extends IgxGridNavigationService {
    constructor() {
        super(...arguments);
        this._pendingNavigation = false;
    }
    dispatchEvent(event) {
        const key = event.key.toLowerCase();
        if (!this.activeNode || !(SUPPORTED_KEYS.has(key) || (key === 'tab' && this.grid.crudService.cell)) &&
            !this.grid.crudService.rowEditingBlocked && !this.grid.crudService.rowInEditMode) {
            return;
        }
        const targetGrid = this.getClosestElemByTag(event.target, 'igx-hierarchical-grid');
        if (targetGrid !== this.grid.nativeElement) {
            return;
        }
        if (this._pendingNavigation && NAVIGATION_KEYS.has(key)) {
            // In case focus needs to be moved from one grid to another, however there is a pending scroll operation
            // which is an async operation, any additional navigation keys should be ignored
            // untill operation complete.
            event.preventDefault();
            return;
        }
        super.dispatchEvent(event);
    }
    navigateInBody(rowIndex, visibleColIndex, cb = null) {
        const rec = this.grid.dataView[rowIndex];
        if (rec && this.grid.isChildGridRecord(rec)) {
            // target is child grid
            const virtState = this.grid.verticalScrollContainer.state;
            const inView = rowIndex >= virtState.startIndex && rowIndex <= virtState.startIndex + virtState.chunkSize;
            const isNext = this.activeNode.row < rowIndex;
            const targetLayoutIndex = isNext ? null : this.grid.childLayoutKeys.length - 1;
            if (inView) {
                this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            }
            else {
                let scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(rowIndex, !isNext);
                scrollAmount += isNext ? 1 : -1;
                this.grid.verticalScrollContainer.getScroll().scrollTop = scrollAmount;
                this._pendingNavigation = true;
                this.grid.verticalScrollContainer.chunkLoad.pipe(first()).subscribe(() => {
                    this._moveToChild(rowIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
                    this._pendingNavigation = false;
                });
            }
            return;
        }
        const isLast = rowIndex === this.grid.dataView.length;
        if ((rowIndex === -1 || isLast) &&
            this.grid.parent !== null) {
            // reached end of child grid
            const nextSiblingIndex = this.nextSiblingIndex(isLast);
            if (nextSiblingIndex !== null) {
                this.grid.parent.navigation._moveToChild(this.grid.childRow.index, visibleColIndex, isLast, nextSiblingIndex, cb);
            }
            else {
                this._moveToParent(isLast, visibleColIndex, cb);
            }
            return;
        }
        if (this.grid.parent) {
            const isNext = this.activeNode && typeof this.activeNode.row === 'number' ? rowIndex > this.activeNode.row : false;
            const cbHandler = (args) => {
                this._handleScrollInChild(rowIndex, isNext);
                cb(args);
            };
            if (!this.activeNode) {
                this.activeNode = { row: null, column: null };
            }
            super.navigateInBody(rowIndex, visibleColIndex, cbHandler);
            return;
        }
        if (!this.activeNode) {
            this.activeNode = { row: null, column: null };
        }
        super.navigateInBody(rowIndex, visibleColIndex, cb);
    }
    shouldPerformVerticalScroll(index, visibleColumnIndex = -1, isNext) {
        const targetRec = this.grid.dataView[index];
        if (this.grid.isChildGridRecord(targetRec)) {
            const scrollAmount = this.grid.verticalScrollContainer.getScrollForIndex(index, !isNext);
            const currScroll = this.grid.verticalScrollContainer.getScroll().scrollTop;
            const shouldScroll = !isNext ? scrollAmount > currScroll : currScroll < scrollAmount;
            return shouldScroll;
        }
        else {
            return super.shouldPerformVerticalScroll(index, visibleColumnIndex);
        }
    }
    focusTbody(event) {
        if (!this.activeNode || this.activeNode.row === null) {
            this.activeNode = {
                row: 0,
                column: 0
            };
            this.grid.navigateTo(0, 0, (obj) => {
                this.grid.clearCellSelection();
                obj.target.activate(event);
            });
        }
        else {
            super.focusTbody(event);
        }
    }
    nextSiblingIndex(isNext) {
        const layoutKey = this.grid.childRow.layout.key;
        const layoutIndex = this.grid.parent.childLayoutKeys.indexOf(layoutKey);
        const nextIndex = isNext ? layoutIndex + 1 : layoutIndex - 1;
        if (nextIndex <= this.grid.parent.childLayoutKeys.length - 1 && nextIndex > -1) {
            return nextIndex;
        }
        else {
            return null;
        }
    }
    /**
     * Handles scrolling in child grid and ensures target child row is in main grid view port.
     *
     * @param rowIndex The row index which should be in view.
     * @param isNext  Optional. Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    _handleScrollInChild(rowIndex, isNext, cb) {
        const shouldScroll = this.shouldPerformVerticalScroll(rowIndex, -1, isNext);
        if (shouldScroll) {
            this.grid.navigation.performVerticalScrollToCell(rowIndex, -1, () => {
                this.positionInParent(rowIndex, isNext, cb);
            });
        }
        else {
            this.positionInParent(rowIndex, isNext, cb);
        }
    }
    /**
     *
     * @param rowIndex Row index that should come in view.
     * @param isNext  Whether we are navigating to next. Used to determine scroll direction.
     * @param cb  Optional.Callback function called when operation is complete.
     */
    positionInParent(rowIndex, isNext, cb) {
        const row = this.grid.gridAPI.get_row_by_index(rowIndex);
        if (!row) {
            if (cb) {
                cb();
            }
            return;
        }
        const positionInfo = this.getPositionInfo(row, isNext);
        if (!positionInfo.inView) {
            // stop event from triggering multiple times before scrolling is complete.
            this._pendingNavigation = true;
            const scrollableGrid = isNext ? this.getNextScrollableDown(this.grid) : this.getNextScrollableUp(this.grid);
            scrollableGrid.grid.verticalScrollContainer.recalcUpdateSizes();
            scrollableGrid.grid.verticalScrollContainer.addScrollTop(positionInfo.offset);
            scrollableGrid.grid.verticalScrollContainer.chunkLoad.pipe(first()).subscribe(() => {
                this._pendingNavigation = false;
                if (cb) {
                    cb();
                }
            });
        }
        else {
            if (cb) {
                cb();
            }
        }
    }
    /**
     * Moves navigation to child grid.
     *
     * @param parentRowIndex The parent row index, at which the child grid is rendered.
     * @param childLayoutIndex Optional. The index of the child row island to which the child grid belongs to. Uses first if not set.
     */
    _moveToChild(parentRowIndex, visibleColIndex, isNext, childLayoutIndex, cb) {
        const ri = typeof childLayoutIndex !== 'number' ?
            this.grid.childLayoutList.first : this.grid.childLayoutList.toArray()[childLayoutIndex];
        const rowId = this.grid.dataView[parentRowIndex].rowID;
        const pathSegment = {
            rowID: rowId,
            rowKey: rowId,
            rowIslandKey: ri.key
        };
        const childGrid = this.grid.gridAPI.getChildGrid([pathSegment]);
        const targetIndex = isNext ? 0 : childGrid.dataView.length - 1;
        const targetRec = childGrid.dataView[targetIndex];
        if (!targetRec) {
            // if no target rec, then move on in next sibling or parent
            childGrid.navigation.navigateInBody(targetIndex, visibleColIndex, cb);
            return;
        }
        if (childGrid.isChildGridRecord(targetRec)) {
            // if target is a child grid record should move into it.
            this.grid.navigation.activeNode.row = null;
            childGrid.navigation.activeNode = { row: targetIndex, column: this.activeNode.column };
            childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
                const targetLayoutIndex = isNext ? 0 : childGrid.childLayoutList.toArray().length - 1;
                childGrid.navigation._moveToChild(targetIndex, visibleColIndex, isNext, targetLayoutIndex, cb);
            });
            return;
        }
        const childGridNav = childGrid.navigation;
        this.clearActivation();
        const lastVisibleIndex = childGridNav.lastColumnIndex;
        const columnIndex = visibleColIndex <= lastVisibleIndex ? visibleColIndex : lastVisibleIndex;
        childGridNav.activeNode = { row: targetIndex, column: columnIndex };
        childGrid.tbody.nativeElement.focus({ preventScroll: true });
        this._pendingNavigation = false;
        childGrid.navigation._handleScrollInChild(targetIndex, isNext, () => {
            childGrid.navigateTo(targetIndex, columnIndex, cb);
        });
    }
    /**
     * Moves navigation back to parent grid.
     *
     * @param rowIndex
     */
    _moveToParent(isNext, columnIndex, cb) {
        const indexInParent = this.grid.childRow.index;
        const hasNextTarget = this.hasNextTarget(this.grid.parent, indexInParent, isNext);
        if (!hasNextTarget) {
            return;
        }
        this.clearActivation();
        const targetRowIndex = isNext ? indexInParent + 1 : indexInParent - 1;
        const lastVisibleIndex = this.grid.parent.navigation.lastColumnIndex;
        const nextColumnIndex = columnIndex <= lastVisibleIndex ? columnIndex : lastVisibleIndex;
        this._pendingNavigation = true;
        const cbFunc = (args) => {
            this._pendingNavigation = false;
            cb(args);
            args.target.grid.tbody.nativeElement.focus();
        };
        this.grid.parent.navigation.navigateInBody(targetRowIndex, nextColumnIndex, cbFunc);
    }
    /**
     * Gets information on the row position relative to the root grid view port.
     * Returns whether the row is in view and its offset.
     *
     * @param rowObj
     * @param isNext
     */
    getPositionInfo(row, isNext) {
        // XXX: Fix type
        let rowElem = row.nativeElement;
        if (row.layout) {
            const childLayoutKeys = this.grid.childLayoutKeys;
            const riKey = isNext ? childLayoutKeys[0] : childLayoutKeys[childLayoutKeys.length - 1];
            const pathSegment = {
                rowID: row.data.rowID, rowKey: row.data.rowID,
                rowIslandKey: riKey
            };
            const childGrid = this.grid.gridAPI.getChildGrid([pathSegment]);
            rowElem = childGrid.tfoot.nativeElement;
        }
        const gridBottom = this._getMinBottom(this.grid);
        const diffBottom = rowElem.getBoundingClientRect().bottom - gridBottom;
        const gridTop = this._getMaxTop(this.grid);
        const diffTop = rowElem.getBoundingClientRect().bottom -
            rowElem.offsetHeight - gridTop;
        // Adding Math.Round because Chrome has some inconsistencies when the page is zoomed
        const isInView = isNext ? Math.round(diffBottom) <= 0 : Math.round(diffTop) >= 0;
        const calcOffset = isNext ? diffBottom : diffTop;
        return { inView: isInView, offset: calcOffset };
    }
    /**
     * Gets closest element by its tag name.
     *
     * @param sourceElem The element from which to start the search.
     * @param targetTag The target element tag name, for which to search.
     */
    getClosestElemByTag(sourceElem, targetTag) {
        let result = sourceElem;
        while (result !== null && result.nodeType === 1) {
            if (result.tagName.toLowerCase() === targetTag.toLowerCase()) {
                return result;
            }
            result = result.parentNode;
        }
        return null;
    }
    clearActivation() {
        // clear if previous activation exists.
        if (this.activeNode && Object.keys(this.activeNode).length) {
            this.activeNode = Object.assign({});
        }
    }
    hasNextTarget(grid, index, isNext) {
        const targetRowIndex = isNext ? index + 1 : index - 1;
        const hasTargetRecord = !!grid.dataView[targetRowIndex];
        if (hasTargetRecord) {
            return true;
        }
        else {
            let hasTargetRecordInParent = false;
            if (grid.parent) {
                const indexInParent = grid.childRow.index;
                hasTargetRecordInParent = this.hasNextTarget(grid.parent, indexInParent, isNext);
            }
            return hasTargetRecordInParent;
        }
    }
    /**
     * Gets the max top view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMaxTop(grid) {
        let currGrid = grid;
        let top = currGrid.tbody.nativeElement.getBoundingClientRect().top;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            top = Math.max(top, currGrid.tbody.nativeElement.getBoundingClientRect().top + pinnedRowsHeight);
        }
        return top;
    }
    /**
     * Gets the min bottom view in the current grid hierarchy.
     *
     * @param grid
     */
    _getMinBottom(grid) {
        let currGrid = grid;
        let bottom = currGrid.tbody.nativeElement.getBoundingClientRect().bottom;
        while (currGrid.parent) {
            currGrid = currGrid.parent;
            const pinnedRowsHeight = currGrid.hasPinnedRecords && !currGrid.isRowPinningToTop ? currGrid.pinnedRowHeight : 0;
            bottom = Math.min(bottom, currGrid.tbody.nativeElement.getBoundingClientRect().bottom - pinnedRowsHeight);
        }
        return bottom;
    }
    /**
     * Finds the next grid that allows scrolling down.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableDown(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let scrollTop = currGrid.verticalScrollContainer.scrollPosition;
        let scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
        let nonScrollable = scrollHeight === 0 ||
            Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            scrollTop = currGrid.verticalScrollContainer.scrollPosition;
            scrollHeight = currGrid.verticalScrollContainer.getScroll().scrollHeight;
            nonScrollable = scrollHeight === 0 ||
                Math.round(scrollTop + currGrid.verticalScrollContainer.igxForContainerSize) === scrollHeight;
        }
        return { grid: currGrid, prev };
    }
    /**
     * Finds the next grid that allows scrolling up.
     *
     * @param grid The grid from which to begin the search.
     */
    getNextScrollableUp(grid) {
        let currGrid = grid.parent;
        if (!currGrid) {
            return { grid, prev: null };
        }
        let nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        let prev = grid;
        while (nonScrollable && currGrid.parent !== null) {
            prev = currGrid;
            currGrid = currGrid.parent;
            nonScrollable = currGrid.verticalScrollContainer.scrollPosition === 0;
        }
        return { grid: currGrid, prev };
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxHierarchicalGridNavigationService, deps: null, target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxHierarchicalGridNavigationService }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxHierarchicalGridNavigationService, decorators: [{
            type: Injectable
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGllcmFyY2hpY2FsLWdyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2hpZXJhcmNoaWNhbC1ncmlkL2hpZXJhcmNoaWNhbC1ncmlkLW5hdmlnYXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN2QyxPQUFPLEVBQUUsZUFBZSxFQUFFLGNBQWMsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRW5FLE9BQU8sRUFBZSx3QkFBd0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDOztBQUduRixNQUFNLE9BQU8sb0NBQXFDLFNBQVEsd0JBQXdCO0lBRGxGOztRQUVjLHVCQUFrQixHQUFHLEtBQUssQ0FBQztLQXdZeEM7SUFyWW1CLGFBQWEsQ0FBQyxLQUFvQjtRQUM5QyxNQUFNLEdBQUcsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ3BDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxJQUFJLENBQUMsQ0FBQyxjQUFjLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUMvRixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGlCQUFpQixJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLENBQUM7WUFDbkYsT0FBTztRQUNYLENBQUM7UUFFRCxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLE1BQU0s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LENBQUM7SUFFRDs7OztPQUlHO0lBQ0ssbUJBQW1CLENBQUMsSUFBSTtRQUM1QixJQUFJLFFBQVEsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNaLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDO1FBQ2hDLENBQUM7UUFDRCxJQUFJLGFBQWEsR0FBRyxRQUFRLENBQUMsdUJBQXVCLENBQUMsY0FBYyxLQUFLLENBQUMsQ0FBQztRQUMxRSxJQUFJLElBQUksR0FBRyxJQUFJLENBQUM7UUFDaEIsT0FBTyxhQUFhLElBQUksUUFBUSxDQUFDLE1BQU0sS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUMvQyxJQUFJLEdBQUcsUUFBUSxDQUFDO1lBQ2hCLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDO1lBQzNCLGFBQWEsR0FBRyxRQUFRLENBQUMsdUJBQXVCLENBQUMsY0FBYyxLQUFLLENBQUMsQ0FBQztRQUMxRSxDQUFDO1FBQ0QsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsSUFBSSxFQUFFLENBQUM7SUFDcEMsQ0FBQzs4R0F4WVEsb0NBQW9DO2tIQUFwQyxvQ0FBb0M7OzJGQUFwQyxvQ0FBb0M7a0JBRGhELFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmaXJzdCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE5BVklHQVRJT05fS0VZUywgU1VQUE9SVEVEX0tFWVMgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcbmltcG9ydCB7IEdyaWRUeXBlLCBJUGF0aFNlZ21lbnQsIFJvd1R5cGUgfSBmcm9tICcuLi9jb21tb24vZ3JpZC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSUFjdGl2ZU5vZGUsIElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB9IGZyb20gJy4uL2dyaWQtbmF2aWdhdGlvbi5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIElneEhpZXJhcmNoaWNhbEdyaWROYXZpZ2F0aW9uU2VydmljZSBleHRlbmRzIElneEdyaWROYXZpZ2F0aW9uU2VydmljZSB7XG4gICAgcHJvdGVjdGVkIF9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuXG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgZGlzcGF0Y2hFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZU5vZGUgfHwgIShTVVBQT1JURURfS0VZUy5oYXMoa2V5KSB8fCAoa2V5ID09PSAndGFiJyAmJiB0aGlzLmdyaWQuY3J1ZFNlcnZpY2UuY2VsbCkpICYmXG4gICAgICAgICAgICAhdGhpcy5ncmlkLmNydWRTZXJ2aWNlLnJvd0VkaXRpbmdCbG9ja2VkICYmICF0aGlzLmdyaWQuY3J1ZFNlcnZpY2Uucm93SW5FZGl0TW9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdGFyZ2V0R3JpZCA9IHRoaXMuZ2V0Q2xvc2VzdEVsZW1CeVRhZyhldmVudC50YXJnZXQsICdpZ3gtaGllcmFyY2hpY2FsLWdyaWQnKTtcbiAgICAgICAgaWYgKHRhcmdldEdyaWQgIT09IHRoaXMuZ3JpZC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcGVuZGluZ05hdmlnYXRpb24gJiYgTkFWSUdBVElPTl9LRVlTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBJbiBjYXNlIGZvY3VzIG5lZWRzIHRvIGJlIG1vdmVkIGZyb20gb25lIGdyaWQgdG8gYW5vdGhlciwgaG93ZXZlciB0aGVyZSBpcyBhIHBlbmRpbmcgc2Nyb2xsIG9wZXJhdGlvblxuICAgICAgICAgICAgLy8gd2hpY2ggaXMgYW4gYXN5bmMgb3BlcmF0aW9uLCBhbnkgYWRkaXRpb25hbCBuYXZpZ2F0aW9uIGtleXMgc2hvdWxkIGJlIGlnbm9yZWRcbiAgICAgICAgICAgIC8vIHVudGlsbCBvcGVyYXRpb24gY29tcGxldGUuXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvdmVycmlkZSBuYXZpZ2F0ZUluQm9keShyb3dJbmRleCwgdmlzaWJsZUNvbEluZGV4LCBjYjogKGFyZzogYW55KSA9PiB2b2lkID0gbnVsbCk6IHZvaWQge1xuICAgICAgICBjb25zdCByZWMgPSB0aGlzLmdyaWQuZGF0YVZpZXdbcm93SW5kZXhdO1xuICAgICAgICBpZiAocmVjICYmIHRoaXMuZ3JpZC5pc0NoaWxkR3JpZFJlY29yZChyZWMpKSB7XG4gICAgICAgICAgICAgLy8gdGFyZ2V0IGlzIGNoaWxkIGdyaWRcbiAgICAgICAgICAgIGNvbnN0IHZpcnRTdGF0ZSA9IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zdGF0ZTtcbiAgICAgICAgICAgICBjb25zdCBpblZpZXcgPSByb3dJbmRleCA+PSB2aXJ0U3RhdGUuc3RhcnRJbmRleCAmJiByb3dJbmRleCA8PSB2aXJ0U3RhdGUuc3RhcnRJbmRleCArIHZpcnRTdGF0ZS5jaHVua1NpemU7XG4gICAgICAgICAgICAgY29uc3QgaXNOZXh0ID0gIHRoaXMuYWN0aXZlTm9kZS5yb3cgPCByb3dJbmRleDtcbiAgICAgICAgICAgICBjb25zdCB0YXJnZXRMYXlvdXRJbmRleCA9IGlzTmV4dCA/IG51bGwgOiB0aGlzLmdyaWQuY2hpbGRMYXlvdXRLZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgaWYgKGluVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVUb0NoaWxkKHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGlzTmV4dCwgdGFyZ2V0TGF5b3V0SW5kZXgsIGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHNjcm9sbEFtb3VudCA9IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxGb3JJbmRleChyb3dJbmRleCwgIWlzTmV4dCk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsQW1vdW50ICs9IGlzTmV4dCA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsVG9wID0gc2Nyb2xsQW1vdW50O1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuY2h1bmtMb2FkLnBpcGUoZmlyc3QoKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZVRvQ2hpbGQocm93SW5kZXgsIHZpc2libGVDb2xJbmRleCwgaXNOZXh0LCB0YXJnZXRMYXlvdXRJbmRleCwgY2IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNMYXN0ID0gcm93SW5kZXggPT09IHRoaXMuZ3JpZC5kYXRhVmlldy5sZW5ndGg7XG4gICAgICAgIGlmICgocm93SW5kZXggPT09IC0xIHx8IGlzTGFzdCkgJiZcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgZW5kIG9mIGNoaWxkIGdyaWRcbiAgICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nSW5kZXggPSB0aGlzLm5leHRTaWJsaW5nSW5kZXgoaXNMYXN0KTtcbiAgICAgICAgICAgIGlmIChuZXh0U2libGluZ0luZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ncmlkLnBhcmVudC5uYXZpZ2F0aW9uLl9tb3ZlVG9DaGlsZCh0aGlzLmdyaWQuY2hpbGRSb3cuaW5kZXgsIHZpc2libGVDb2xJbmRleCwgaXNMYXN0LCBuZXh0U2libGluZ0luZGV4LCBjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdmVUb1BhcmVudChpc0xhc3QsIHZpc2libGVDb2xJbmRleCwgY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzTmV4dCA9IHRoaXMuYWN0aXZlTm9kZSAmJiB0eXBlb2YgdGhpcy5hY3RpdmVOb2RlLnJvdyA9PT0gJ251bWJlcicgPyByb3dJbmRleCA+IHRoaXMuYWN0aXZlTm9kZS5yb3cgOiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNiSGFuZGxlciA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlU2Nyb2xsSW5DaGlsZChyb3dJbmRleCwgaXNOZXh0KTtcbiAgICAgICAgICAgICAgICBjYihhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlTm9kZSA9IHsgcm93OiBudWxsLCBjb2x1bW46IG51bGwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyLm5hdmlnYXRlSW5Cb2R5KHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiSGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYWN0aXZlTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0geyByb3c6IG51bGwsIGNvbHVtbjogbnVsbCB9O1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm5hdmlnYXRlSW5Cb2R5KHJvd0luZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgb3ZlcnJpZGUgc2hvdWxkUGVyZm9ybVZlcnRpY2FsU2Nyb2xsKGluZGV4LCB2aXNpYmxlQ29sdW1uSW5kZXggPSAtMSwgaXNOZXh0Pykge1xuICAgICAgICBjb25zdCB0YXJnZXRSZWMgPSB0aGlzLmdyaWQuZGF0YVZpZXdbaW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5ncmlkLmlzQ2hpbGRHcmlkUmVjb3JkKHRhcmdldFJlYykpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEFtb3VudCA9IHRoaXMuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGxGb3JJbmRleChpbmRleCwgIWlzTmV4dCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyU2Nyb2xsID0gdGhpcy5ncmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmdldFNjcm9sbCgpLnNjcm9sbFRvcDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNjcm9sbCA9ICFpc05leHQgPyBzY3JvbGxBbW91bnQgPiBjdXJyU2Nyb2xsIDogY3VyclNjcm9sbCA8IHNjcm9sbEFtb3VudDtcbiAgICAgICAgICAgIHJldHVybiBzaG91bGRTY3JvbGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuc2hvdWxkUGVyZm9ybVZlcnRpY2FsU2Nyb2xsKGluZGV4LCB2aXNpYmxlQ29sdW1uSW5kZXgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG92ZXJyaWRlIGZvY3VzVGJvZHkoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2ZU5vZGUgfHwgdGhpcy5hY3RpdmVOb2RlLnJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0ge1xuICAgICAgICAgICAgICAgIHJvdzogMCxcbiAgICAgICAgICAgICAgICBjb2x1bW46IDBcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0ZVRvKDAsIDAsIChvYmopID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyaWQuY2xlYXJDZWxsU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgb2JqLnRhcmdldC5hY3RpdmF0ZShldmVudCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIuZm9jdXNUYm9keShldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgbmV4dFNpYmxpbmdJbmRleChpc05leHQpIHtcbiAgICAgICAgY29uc3QgbGF5b3V0S2V5ID0gdGhpcy5ncmlkLmNoaWxkUm93LmxheW91dC5rZXk7XG4gICAgICAgIGNvbnN0IGxheW91dEluZGV4ID0gdGhpcy5ncmlkLnBhcmVudC5jaGlsZExheW91dEtleXMuaW5kZXhPZihsYXlvdXRLZXkpO1xuICAgICAgICBjb25zdCBuZXh0SW5kZXggPSBpc05leHQgPyBsYXlvdXRJbmRleCArIDEgOiBsYXlvdXRJbmRleCAtIDE7XG4gICAgICAgIGlmIChuZXh0SW5kZXggPD0gdGhpcy5ncmlkLnBhcmVudC5jaGlsZExheW91dEtleXMubGVuZ3RoIC0gMSAmJiBuZXh0SW5kZXggPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzY3JvbGxpbmcgaW4gY2hpbGQgZ3JpZCBhbmQgZW5zdXJlcyB0YXJnZXQgY2hpbGQgcm93IGlzIGluIG1haW4gZ3JpZCB2aWV3IHBvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93SW5kZXggVGhlIHJvdyBpbmRleCB3aGljaCBzaG91bGQgYmUgaW4gdmlldy5cbiAgICAgKiBAcGFyYW0gaXNOZXh0ICBPcHRpb25hbC4gV2hldGhlciB3ZSBhcmUgbmF2aWdhdGluZyB0byBuZXh0LiBVc2VkIHRvIGRldGVybWluZSBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjYiAgT3B0aW9uYWwuQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdoZW4gb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfaGFuZGxlU2Nyb2xsSW5DaGlsZChyb3dJbmRleDogbnVtYmVyLCBpc05leHQ/OiBib29sZWFuLCBjYj86ICgpID0+IHZvaWQpIHtcbiAgICAgICAgY29uc3Qgc2hvdWxkU2Nyb2xsID0gdGhpcy5zaG91bGRQZXJmb3JtVmVydGljYWxTY3JvbGwocm93SW5kZXgsIC0xLCBpc05leHQpO1xuICAgICAgICBpZiAoc2hvdWxkU2Nyb2xsKSB7XG4gICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGlvbi5wZXJmb3JtVmVydGljYWxTY3JvbGxUb0NlbGwocm93SW5kZXgsIC0xLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkluUGFyZW50KHJvd0luZGV4LCBpc05leHQsIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkluUGFyZW50KHJvd0luZGV4LCBpc05leHQsIGNiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvd0luZGV4IFJvdyBpbmRleCB0aGF0IHNob3VsZCBjb21lIGluIHZpZXcuXG4gICAgICogQHBhcmFtIGlzTmV4dCAgV2hldGhlciB3ZSBhcmUgbmF2aWdhdGluZyB0byBuZXh0LiBVc2VkIHRvIGRldGVybWluZSBzY3JvbGwgZGlyZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjYiAgT3B0aW9uYWwuQ2FsbGJhY2sgZnVuY3Rpb24gY2FsbGVkIHdoZW4gb3BlcmF0aW9uIGlzIGNvbXBsZXRlLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBwb3NpdGlvbkluUGFyZW50KHJvd0luZGV4LCBpc05leHQsIGNiPzogKCkgPT4gdm9pZCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLmdyaWQuZ3JpZEFQSS5nZXRfcm93X2J5X2luZGV4KHJvd0luZGV4KTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIGlmIChjYikge1xuICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb25JbmZvID0gdGhpcy5nZXRQb3NpdGlvbkluZm8ocm93LCBpc05leHQpO1xuICAgICAgICBpZiAoIXBvc2l0aW9uSW5mby5pblZpZXcpIHtcbiAgICAgICAgICAgIC8vIHN0b3AgZXZlbnQgZnJvbSB0cmlnZ2VyaW5nIG11bHRpcGxlIHRpbWVzIGJlZm9yZSBzY3JvbGxpbmcgaXMgY29tcGxldGUuXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBzY3JvbGxhYmxlR3JpZCA9IGlzTmV4dCA/IHRoaXMuZ2V0TmV4dFNjcm9sbGFibGVEb3duKHRoaXMuZ3JpZCkgOiB0aGlzLmdldE5leHRTY3JvbGxhYmxlVXAodGhpcy5ncmlkKTtcbiAgICAgICAgICAgIHNjcm9sbGFibGVHcmlkLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIucmVjYWxjVXBkYXRlU2l6ZXMoKTtcbiAgICAgICAgICAgIHNjcm9sbGFibGVHcmlkLmdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuYWRkU2Nyb2xsVG9wKHBvc2l0aW9uSW5mby5vZmZzZXQpO1xuICAgICAgICAgICAgc2Nyb2xsYWJsZUdyaWQuZ3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5jaHVua0xvYWQucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdOYXZpZ2F0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgbmF2aWdhdGlvbiB0byBjaGlsZCBncmlkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmVudFJvd0luZGV4IFRoZSBwYXJlbnQgcm93IGluZGV4LCBhdCB3aGljaCB0aGUgY2hpbGQgZ3JpZCBpcyByZW5kZXJlZC5cbiAgICAgKiBAcGFyYW0gY2hpbGRMYXlvdXRJbmRleCBPcHRpb25hbC4gVGhlIGluZGV4IG9mIHRoZSBjaGlsZCByb3cgaXNsYW5kIHRvIHdoaWNoIHRoZSBjaGlsZCBncmlkIGJlbG9uZ3MgdG8uIFVzZXMgZmlyc3QgaWYgbm90IHNldC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX21vdmVUb0NoaWxkKHBhcmVudFJvd0luZGV4OiBudW1iZXIsIHZpc2libGVDb2xJbmRleDogbnVtYmVyLCBpc05leHQ6IGJvb2xlYW4sIGNoaWxkTGF5b3V0SW5kZXg/OiBudW1iZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2I/OiAoYXJnOiBhbnkpID0+IHZvaWQpIHtcbiAgICAgICAgY29uc3QgcmkgPSB0eXBlb2YgY2hpbGRMYXlvdXRJbmRleCAhPT0gJ251bWJlcicgP1xuICAgICAgICAgdGhpcy5ncmlkLmNoaWxkTGF5b3V0TGlzdC5maXJzdCA6IHRoaXMuZ3JpZC5jaGlsZExheW91dExpc3QudG9BcnJheSgpW2NoaWxkTGF5b3V0SW5kZXhdO1xuICAgICAgICBjb25zdCByb3dJZCA9IHRoaXMuZ3JpZC5kYXRhVmlld1twYXJlbnRSb3dJbmRleF0ucm93SUQ7XG4gICAgICAgIGNvbnN0IHBhdGhTZWdtZW50OiBJUGF0aFNlZ21lbnQgPSB7XG4gICAgICAgICAgICByb3dJRDogcm93SWQsXG4gICAgICAgICAgICByb3dLZXk6IHJvd0lkLFxuICAgICAgICAgICAgcm93SXNsYW5kS2V5OiByaS5rZXlcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hpbGRHcmlkID0gIHRoaXMuZ3JpZC5ncmlkQVBJLmdldENoaWxkR3JpZChbcGF0aFNlZ21lbnRdKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0SW5kZXggPSBpc05leHQgPyAwIDogY2hpbGRHcmlkLmRhdGFWaWV3Lmxlbmd0aCAtIDE7XG4gICAgICAgIGNvbnN0IHRhcmdldFJlYyA9ICBjaGlsZEdyaWQuZGF0YVZpZXdbdGFyZ2V0SW5kZXhdO1xuICAgICAgICBpZiAoIXRhcmdldFJlYykge1xuICAgICAgICAgICAgLy8gaWYgbm8gdGFyZ2V0IHJlYywgdGhlbiBtb3ZlIG9uIGluIG5leHQgc2libGluZyBvciBwYXJlbnRcbiAgICAgICAgICAgIGNoaWxkR3JpZC5uYXZpZ2F0aW9uLm5hdmlnYXRlSW5Cb2R5KHRhcmdldEluZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGNiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRHcmlkLmlzQ2hpbGRHcmlkUmVjb3JkKHRhcmdldFJlYykpIHtcbiAgICAgICAgICAgIC8vIGlmIHRhcmdldCBpcyBhIGNoaWxkIGdyaWQgcmVjb3JkIHNob3VsZCBtb3ZlIGludG8gaXQuXG4gICAgICAgICAgICB0aGlzLmdyaWQubmF2aWdhdGlvbi5hY3RpdmVOb2RlLnJvdyA9IG51bGw7XG4gICAgICAgICAgICBjaGlsZEdyaWQubmF2aWdhdGlvbi5hY3RpdmVOb2RlID0geyByb3c6IHRhcmdldEluZGV4LCBjb2x1bW46IHRoaXMuYWN0aXZlTm9kZS5jb2x1bW59O1xuICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24uX2hhbmRsZVNjcm9sbEluQ2hpbGQodGFyZ2V0SW5kZXgsIGlzTmV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldExheW91dEluZGV4ID0gaXNOZXh0ID8gMCA6IGNoaWxkR3JpZC5jaGlsZExheW91dExpc3QudG9BcnJheSgpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24uX21vdmVUb0NoaWxkKHRhcmdldEluZGV4LCB2aXNpYmxlQ29sSW5kZXgsIGlzTmV4dCwgdGFyZ2V0TGF5b3V0SW5kZXgsIGNiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY2hpbGRHcmlkTmF2ID0gIGNoaWxkR3JpZC5uYXZpZ2F0aW9uO1xuICAgICAgICB0aGlzLmNsZWFyQWN0aXZhdGlvbigpO1xuICAgICAgICBjb25zdCBsYXN0VmlzaWJsZUluZGV4ID0gY2hpbGRHcmlkTmF2Lmxhc3RDb2x1bW5JbmRleDtcbiAgICAgICAgY29uc3QgY29sdW1uSW5kZXggPSB2aXNpYmxlQ29sSW5kZXggPD0gbGFzdFZpc2libGVJbmRleCA/IHZpc2libGVDb2xJbmRleCA6IGxhc3RWaXNpYmxlSW5kZXg7XG4gICAgICAgIGNoaWxkR3JpZE5hdi5hY3RpdmVOb2RlID0geyByb3c6IHRhcmdldEluZGV4LCBjb2x1bW46IGNvbHVtbkluZGV4fTtcbiAgICAgICAgY2hpbGRHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ05hdmlnYXRpb24gPSBmYWxzZTtcbiAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRpb24uX2hhbmRsZVNjcm9sbEluQ2hpbGQodGFyZ2V0SW5kZXgsIGlzTmV4dCwgKCkgPT4ge1xuICAgICAgICAgICAgY2hpbGRHcmlkLm5hdmlnYXRlVG8odGFyZ2V0SW5kZXgsIGNvbHVtbkluZGV4LCBjYik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIG5hdmlnYXRpb24gYmFjayB0byBwYXJlbnQgZ3JpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb3dJbmRleFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBfbW92ZVRvUGFyZW50KGlzTmV4dDogYm9vbGVhbiwgY29sdW1uSW5kZXgsIGNiPykge1xuICAgICAgICBjb25zdCBpbmRleEluUGFyZW50ID0gdGhpcy5ncmlkLmNoaWxkUm93LmluZGV4O1xuICAgICAgICBjb25zdCBoYXNOZXh0VGFyZ2V0ID0gdGhpcy5oYXNOZXh0VGFyZ2V0KHRoaXMuZ3JpZC5wYXJlbnQsIGluZGV4SW5QYXJlbnQsIGlzTmV4dCk7XG4gICAgICAgIGlmICghaGFzTmV4dFRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmF0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRhcmdldFJvd0luZGV4ID0gIGlzTmV4dCA/IGluZGV4SW5QYXJlbnQgKyAxIDogaW5kZXhJblBhcmVudCAtIDE7XG4gICAgICAgIGNvbnN0IGxhc3RWaXNpYmxlSW5kZXggPSB0aGlzLmdyaWQucGFyZW50Lm5hdmlnYXRpb24ubGFzdENvbHVtbkluZGV4O1xuICAgICAgICBjb25zdCBuZXh0Q29sdW1uSW5kZXggPSBjb2x1bW5JbmRleCA8PSBsYXN0VmlzaWJsZUluZGV4ID8gY29sdW1uSW5kZXggOiBsYXN0VmlzaWJsZUluZGV4O1xuICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IGNiRnVuYyA9IChhcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nTmF2aWdhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgY2IoYXJncyk7XG4gICAgICAgICAgICBhcmdzLnRhcmdldC5ncmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ncmlkLnBhcmVudC5uYXZpZ2F0aW9uLm5hdmlnYXRlSW5Cb2R5KHRhcmdldFJvd0luZGV4LCBuZXh0Q29sdW1uSW5kZXgsIGNiRnVuYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBvbiB0aGUgcm93IHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSByb290IGdyaWQgdmlldyBwb3J0LlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgcm93IGlzIGluIHZpZXcgYW5kIGl0cyBvZmZzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm93T2JqXG4gICAgICogQHBhcmFtIGlzTmV4dFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRQb3NpdGlvbkluZm8ocm93OiBSb3dUeXBlLCBpc05leHQ6IGJvb2xlYW4pIHtcbiAgICAgICAgLy8gWFhYOiBGaXggdHlwZVxuICAgICAgICBsZXQgcm93RWxlbSA9IHJvdy5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAoKHJvdyBhcyBhbnkpLmxheW91dCkge1xuICAgICAgICAgICAgY29uc3QgY2hpbGRMYXlvdXRLZXlzID0gdGhpcy5ncmlkLmNoaWxkTGF5b3V0S2V5cztcbiAgICAgICAgICAgIGNvbnN0IHJpS2V5ID0gaXNOZXh0ID8gY2hpbGRMYXlvdXRLZXlzWzBdIDogY2hpbGRMYXlvdXRLZXlzW2NoaWxkTGF5b3V0S2V5cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhTZWdtZW50OiBJUGF0aFNlZ21lbnQgPSB7XG4gICAgICAgICAgICAgICAgcm93SUQ6IHJvdy5kYXRhLnJvd0lELCByb3dLZXk6IHJvdy5kYXRhLnJvd0lELFxuICAgICAgICAgICAgICAgIHJvd0lzbGFuZEtleTogcmlLZXlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjaGlsZEdyaWQgPSAgdGhpcy5ncmlkLmdyaWRBUEkuZ2V0Q2hpbGRHcmlkKFtwYXRoU2VnbWVudF0pO1xuICAgICAgICAgICAgcm93RWxlbSA9IGNoaWxkR3JpZC50Zm9vdC5uYXRpdmVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyaWRCb3R0b20gPSB0aGlzLl9nZXRNaW5Cb3R0b20odGhpcy5ncmlkKTtcbiAgICAgICAgY29uc3QgZGlmZkJvdHRvbSA9XG4gICAgICAgIHJvd0VsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gZ3JpZEJvdHRvbTtcbiAgICAgICAgY29uc3QgZ3JpZFRvcCA9IHRoaXMuX2dldE1heFRvcCh0aGlzLmdyaWQpO1xuICAgICAgICBjb25zdCBkaWZmVG9wID0gcm93RWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLVxuICAgICAgICByb3dFbGVtLm9mZnNldEhlaWdodCAtIGdyaWRUb3A7XG4gICAgICAgIC8vIEFkZGluZyBNYXRoLlJvdW5kIGJlY2F1c2UgQ2hyb21lIGhhcyBzb21lIGluY29uc2lzdGVuY2llcyB3aGVuIHRoZSBwYWdlIGlzIHpvb21lZFxuICAgICAgICBjb25zdCBpc0luVmlldyA9IGlzTmV4dCA/IE1hdGgucm91bmQoZGlmZkJvdHRvbSkgPD0gMCA6IE1hdGgucm91bmQoZGlmZlRvcCkgPj0gMDtcbiAgICAgICAgY29uc3QgY2FsY09mZnNldCA9ICBpc05leHQgPyBkaWZmQm90dG9tIDogZGlmZlRvcDtcblxuICAgICAgICByZXR1cm4geyBpblZpZXc6IGlzSW5WaWV3LCBvZmZzZXQ6IGNhbGNPZmZzZXQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNsb3Nlc3QgZWxlbWVudCBieSBpdHMgdGFnIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlRWxlbSBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gICAgICogQHBhcmFtIHRhcmdldFRhZyBUaGUgdGFyZ2V0IGVsZW1lbnQgdGFnIG5hbWUsIGZvciB3aGljaCB0byBzZWFyY2guXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldENsb3Nlc3RFbGVtQnlUYWcoc291cmNlRWxlbSwgdGFyZ2V0VGFnKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzb3VyY2VFbGVtO1xuICAgICAgICB3aGlsZSAocmVzdWx0ICE9PSBudWxsICYmIHJlc3VsdC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHRhcmdldFRhZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xlYXJBY3RpdmF0aW9uKCkge1xuICAgICAgICAvLyBjbGVhciBpZiBwcmV2aW91cyBhY3RpdmF0aW9uIGV4aXN0cy5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlTm9kZSAmJiBPYmplY3Qua2V5cyh0aGlzLmFjdGl2ZU5vZGUpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVOb2RlID0gT2JqZWN0LmFzc2lnbih7fSBhcyBJQWN0aXZlTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGhhc05leHRUYXJnZXQoZ3JpZDogR3JpZFR5cGUsIGluZGV4OiBudW1iZXIsIGlzTmV4dDogYm9vbGVhbikge1xuICAgICAgICBjb25zdCB0YXJnZXRSb3dJbmRleCA9ICBpc05leHQgPyBpbmRleCArIDEgOiBpbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGhhc1RhcmdldFJlY29yZCA9ICEhZ3JpZC5kYXRhVmlld1t0YXJnZXRSb3dJbmRleF07XG4gICAgICAgIGlmIChoYXNUYXJnZXRSZWNvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGhhc1RhcmdldFJlY29yZEluUGFyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZ3JpZC5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleEluUGFyZW50ID0gZ3JpZC5jaGlsZFJvdy5pbmRleDtcbiAgICAgICAgICAgICAgICBoYXNUYXJnZXRSZWNvcmRJblBhcmVudCA9IHRoaXMuaGFzTmV4dFRhcmdldChncmlkLnBhcmVudCwgaW5kZXhJblBhcmVudCwgaXNOZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYXNUYXJnZXRSZWNvcmRJblBhcmVudDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1heCB0b3AgdmlldyBpbiB0aGUgY3VycmVudCBncmlkIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0TWF4VG9wKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZDtcbiAgICAgICAgbGV0IHRvcCA9IGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgICAgICB3aGlsZSAoY3VyckdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFJvd3NIZWlnaHQgPSBjdXJyR3JpZC5oYXNQaW5uZWRSZWNvcmRzICYmIGN1cnJHcmlkLmlzUm93UGlubmluZ1RvVG9wID8gY3VyckdyaWQucGlubmVkUm93SGVpZ2h0IDogMDtcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgY3VyckdyaWQudGJvZHkubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyBwaW5uZWRSb3dzSGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1pbiBib3R0b20gdmlldyBpbiB0aGUgY3VycmVudCBncmlkIGhpZXJhcmNoeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBncmlkXG4gICAgICovXG4gICAgcHJpdmF0ZSBfZ2V0TWluQm90dG9tKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZDtcbiAgICAgICAgbGV0IGJvdHRvbSA9IGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tO1xuICAgICAgICB3aGlsZSAoY3VyckdyaWQucGFyZW50KSB7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIGNvbnN0IHBpbm5lZFJvd3NIZWlnaHQgPSBjdXJyR3JpZC5oYXNQaW5uZWRSZWNvcmRzICYmICFjdXJyR3JpZC5pc1Jvd1Bpbm5pbmdUb1RvcCA/IGN1cnJHcmlkLnBpbm5lZFJvd0hlaWdodCA6IDA7XG4gICAgICAgICAgICBib3R0b20gPSBNYXRoLm1pbihib3R0b20sIGN1cnJHcmlkLnRib2R5Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tIC0gcGlubmVkUm93c0hlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJvdHRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBncmlkIHRoYXQgYWxsb3dzIHNjcm9sbGluZyBkb3duLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgVGhlIGdyaWQgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0TmV4dFNjcm9sbGFibGVEb3duKGdyaWQpIHtcbiAgICAgICAgbGV0IGN1cnJHcmlkID0gZ3JpZC5wYXJlbnQ7XG4gICAgICAgIGlmICghY3VyckdyaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGdyaWQsIHByZXY6IG51bGwgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuc2Nyb2xsUG9zaXRpb247XG4gICAgICAgIGxldCBzY3JvbGxIZWlnaHQgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5nZXRTY3JvbGwoKS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIGxldCBub25TY3JvbGxhYmxlID0gc2Nyb2xsSGVpZ2h0ID09PSAwIHx8XG4gICAgICAgICAgICBNYXRoLnJvdW5kKHNjcm9sbFRvcCArIGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLmlneEZvckNvbnRhaW5lclNpemUpID09PSBzY3JvbGxIZWlnaHQ7XG4gICAgICAgIGxldCBwcmV2ID0gZ3JpZDtcbiAgICAgICAgd2hpbGUgKG5vblNjcm9sbGFibGUgJiYgY3VyckdyaWQucGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwcmV2ID0gY3VyckdyaWQ7XG4gICAgICAgICAgICBjdXJyR3JpZCA9IGN1cnJHcmlkLnBhcmVudDtcbiAgICAgICAgICAgIHNjcm9sbFRvcCA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uO1xuICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0ID0gY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZ2V0U2Nyb2xsKCkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgbm9uU2Nyb2xsYWJsZSA9IHNjcm9sbEhlaWdodCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQoc2Nyb2xsVG9wICsgY3VyckdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuaWd4Rm9yQ29udGFpbmVyU2l6ZSkgPT09IHNjcm9sbEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBncmlkOiBjdXJyR3JpZCwgcHJldiB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIHRoZSBuZXh0IGdyaWQgdGhhdCBhbGxvd3Mgc2Nyb2xsaW5nIHVwLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgVGhlIGdyaWQgZnJvbSB3aGljaCB0byBiZWdpbiB0aGUgc2VhcmNoLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0TmV4dFNjcm9sbGFibGVVcChncmlkKSB7XG4gICAgICAgIGxldCBjdXJyR3JpZCA9IGdyaWQucGFyZW50O1xuICAgICAgICBpZiAoIWN1cnJHcmlkKSB7XG4gICAgICAgICAgICByZXR1cm4geyBncmlkLCBwcmV2OiBudWxsIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5vblNjcm9sbGFibGUgPSBjdXJyR3JpZC52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lci5zY3JvbGxQb3NpdGlvbiA9PT0gMDtcbiAgICAgICAgbGV0IHByZXYgPSBncmlkO1xuICAgICAgICB3aGlsZSAobm9uU2Nyb2xsYWJsZSAmJiBjdXJyR3JpZC5wYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByZXYgPSBjdXJyR3JpZDtcbiAgICAgICAgICAgIGN1cnJHcmlkID0gY3VyckdyaWQucGFyZW50O1xuICAgICAgICAgICAgbm9uU2Nyb2xsYWJsZSA9IGN1cnJHcmlkLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLnNjcm9sbFBvc2l0aW9uID09PSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGdyaWQ6IGN1cnJHcmlkLCBwcmV2IH07XG4gICAgfVxufVxuIl19
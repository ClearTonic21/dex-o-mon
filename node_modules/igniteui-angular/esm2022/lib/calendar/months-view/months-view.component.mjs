import { Component, Input, HostBinding, booleanAttribute, Inject, } from "@angular/core";
import { IgxCalendarMonthDirective } from "../calendar.directives";
import { NgFor, TitleCasePipe, DatePipe } from "@angular/common";
import { IgxCalendarViewDirective, DAY_INTERVAL_TOKEN, } from "../common/calendar-view.directive";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { CalendarDay } from "../common/model";
import { calendarRange } from "../common/helpers";
import * as i0 from "@angular/core";
let NEXT_ID = 0;
export class IgxMonthsViewComponent extends IgxCalendarViewDirective {
    #standalone;
    /**
     * @hidden @internal
     */
    get standalone() {
        return this.#standalone;
    }
    set standalone(value) {
        this.#standalone = value;
    }
    /**
     * Gets the month format option of the months view.
     * ```typescript
     * let monthFormat = this.monthsView.monthFormat.
     * ```
     */
    get monthFormat() {
        return this._monthFormat;
    }
    /**
     * Sets the month format option of the months view.
     * ```html
     * <igx-months-view> [monthFormat]="short'"</igx-months-view>
     * ```
     *
     * @memberof IgxMonthsViewComponent
     */
    set monthFormat(value) {
        this._monthFormat = value;
        this.initFormatter();
    }
    /**
     * Returns an array of date objects which are then used to
     * properly render the month names.
     *
     * Used in the template of the component
     *
     * @hidden @internal
     */
    get range() {
        const start = CalendarDay.from(this.date).set({ date: 1, month: 0 });
        const end = start.add(this.dayInterval, 12);
        return Array.from(calendarRange({ start, end, unit: this.dayInterval })).map((m) => m.native);
    }
    constructor(el, dayInterval) {
        super(dayInterval);
        this.el = el;
        this.#standalone = true;
        /**
         * Sets/gets the `id` of the months view.
         * If not set, the `id` will have value `"igx-months-view-0"`.
         * ```html
         * <igx-months-view id="my-months-view"></igx-months-view>
         * ```
         * ```typescript
         * let monthsViewId =  this.monthsView.id;
         * ```
         *
         * @memberof IgxMonthsViewComponent
         */
        this.id = `igx-months-view-${NEXT_ID++}`;
        /**
         * The default css class applied to the component.
         *
         * @hidden
         */
        this.viewClass = true;
        /**
         * Gets/sets whether the view should be rendered
         * according to the locale and format, if any.
         */
        this.formatView = true;
        /**
         * @hidden
         */
        this._monthFormat = "short";
    }
    /**
     * Returns the locale representation of the month in the months view.
     *
     * @hidden
     */
    formattedMonth(value) {
        const rawFormatter = new Intl.DateTimeFormat(this.locale, {
            month: "long",
            year: "numeric",
        });
        if (this.formatView) {
            return {
                long: rawFormatter.format(value),
                formatted: this._formatter.format(value),
            };
        }
        return {
            long: rawFormatter.format(value),
            formatted: `${value.getMonth()}`,
        };
    }
    /**
     * @hidden
     */
    monthTracker(_, item) {
        return `${item.getMonth()}}`;
    }
    /**
     * @hidden
     */
    initFormatter() {
        this._formatter = new Intl.DateTimeFormat(this._locale, {
            month: this.monthFormat,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxMonthsViewComponent, deps: [{ token: i0.ElementRef }, { token: DAY_INTERVAL_TOKEN }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "16.1.0", version: "18.0.1", type: IgxMonthsViewComponent, isStandalone: true, selector: "igx-months-view", inputs: { id: "id", standalone: "standalone", monthFormat: "monthFormat", formatView: ["formatView", "formatView", booleanAttribute] }, host: { properties: { "attr.id": "this.id", "class.igx-months-view": "this.viewClass", "class.igx-months-view--standalone": "this.standalone" } }, providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: IgxMonthsViewComponent,
                multi: true,
            },
            {
                provide: DAY_INTERVAL_TOKEN,
                useValue: "month",
            },
        ], usesInheritance: true, ngImport: i0, template: "<div class=\"igx-months-view__grid\" role=\"row\">\n    <span\n        igxCalendarMonth\n        #item=\"igxCalendarMonth\"\n        *ngFor=\"let month of range; trackBy: monthTracker\"\n        class=\"igx-months-view__month\"\n        role=\"gridcell\"\n        [attr.id]=\"month.getTime()\"\n        [attr.aria-label]=\"formattedMonth(month).long\"\n        [attr.aria-selected]=\"item.isSelected\"\n        [value]=\"month\"\n        [date]=\"date\"\n        [showActive]=\"showActive\"\n        (itemSelection)=\"selectDate($event)\"\n    >\n        <span class=\"igx-months-view__month-inner\" aria-hidden=\"true\">\n            {{ formattedMonth(month).formatted | titlecase }}\n        </span>\n    </span>\n</div>\n", dependencies: [{ kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: IgxCalendarMonthDirective, selector: "[igxCalendarMonth]", exportAs: ["igxCalendarMonth"] }, { kind: "pipe", type: TitleCasePipe, name: "titlecase" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: IgxMonthsViewComponent, decorators: [{
            type: Component,
            args: [{ providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: IgxMonthsViewComponent,
                            multi: true,
                        },
                        {
                            provide: DAY_INTERVAL_TOKEN,
                            useValue: "month",
                        },
                    ], selector: "igx-months-view", standalone: true, imports: [NgFor, IgxCalendarMonthDirective, TitleCasePipe, DatePipe], template: "<div class=\"igx-months-view__grid\" role=\"row\">\n    <span\n        igxCalendarMonth\n        #item=\"igxCalendarMonth\"\n        *ngFor=\"let month of range; trackBy: monthTracker\"\n        class=\"igx-months-view__month\"\n        role=\"gridcell\"\n        [attr.id]=\"month.getTime()\"\n        [attr.aria-label]=\"formattedMonth(month).long\"\n        [attr.aria-selected]=\"item.isSelected\"\n        [value]=\"month\"\n        [date]=\"date\"\n        [showActive]=\"showActive\"\n        (itemSelection)=\"selectDate($event)\"\n    >\n        <span class=\"igx-months-view__month-inner\" aria-hidden=\"true\">\n            {{ formattedMonth(month).formatted | titlecase }}\n        </span>\n    </span>\n</div>\n" }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [DAY_INTERVAL_TOKEN]
                }] }], propDecorators: { id: [{
                type: HostBinding,
                args: ["attr.id"]
            }, {
                type: Input
            }], viewClass: [{
                type: HostBinding,
                args: ["class.igx-months-view"]
            }], standalone: [{
                type: Input
            }, {
                type: HostBinding,
                args: ["class.igx-months-view--standalone"]
            }], monthFormat: [{
                type: Input
            }], formatView: [{
                type: Input,
                args: [{ transform: booleanAttribute }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGhzLXZpZXcuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2NhbGVuZGFyL21vbnRocy12aWV3L21vbnRocy12aWV3LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9jYWxlbmRhci9tb250aHMtdmlldy9tb250aHMtdmlldy5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0gsU0FBUyxFQUNULEtBQUssRUFDTCxXQUFXLEVBRVgsZ0JBQWdCLEVBQ2hCLE1BQU0sR0FDVCxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUseUJBQXlCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRSxPQUFPLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRSxPQUFPLEVBQ0gsd0JBQXdCLEVBQ3hCLGtCQUFrQixHQUNyQixNQUFNLG1DQUFtQyxDQUFDO0FBQzNDLE9BQU8sRUFBd0IsaUJBQWlCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUN6RSxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFFOUMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLG1CQUFtQixDQUFDOztBQUVsRCxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUM7QUFtQmhCLE1BQU0sT0FBTyxzQkFBdUIsU0FBUSx3QkFBd0I7SUFDaEUsV0FBVyxDQUFRO0lBMEJuQjs7T0FFRztJQUNILElBRVcsVUFBVTtRQUNqQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDNUIsQ0FBQztJQUVELElBQVcsVUFBVSxDQUFDLEtBQWM7UUFDaEMsSUFBSSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUM7SUFD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QUFFLE9BQU87YUFDcEI7U0FDSixpRENoQ0wsc3RCQW9CQSw0Q0RnQmMsS0FBSyxtSEFBRSx5QkFBeUIsMEZBQUUsYUFBYTs7MkZBRWhELHNCQUFzQjtrQkFqQmxDLFNBQVM7Z0NBQ0s7d0JBQ1A7NEJBQ0ksT0FBTyxFQUFFLGlCQUFpQjs0QkFDMUIsV0FBVyx3QkFBd0I7NEJBQ25DLEtBQUssRUFBRSxJQUFJO3lCQUNkO3dCQUNEOzRCQUNJLE9BQU8sRUFBRSxrQkFBa0I7NEJBQzNCLFFBQVEsRUFBRSxPQUFPO3lCQUNwQjtxQkFDSixZQUNTLGlCQUFpQixjQUVmLElBQUksV0FDUCxDQUFDLEtBQUssRUFBRSx5QkFBeUIsRUFBRSxhQUFhLEVBQUUsUUFBUSxDQUFDOzswQkFpRy9ELE1BQU07MkJBQUMsa0JBQWtCO3lDQTlFdkIsRUFBRTtzQkFGUixXQUFXO3VCQUFDLFNBQVM7O3NCQUNyQixLQUFLO2dCQVNVLFNBQVM7c0JBRHhCLFdBQVc7dUJBQUMsdUJBQXVCO2dCQVF6QixVQUFVO3NCQUZwQixLQUFLOztzQkFDTCxXQUFXO3VCQUFDLG1DQUFtQztnQkFnQnJDLFdBQVc7c0JBRHJCLEtBQUs7Z0JBdUJVLFVBQVU7c0JBRHpCLEtBQUs7dUJBQUMsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENvbXBvbmVudCxcbiAgICBJbnB1dCxcbiAgICBIb3N0QmluZGluZyxcbiAgICBFbGVtZW50UmVmLFxuICAgIGJvb2xlYW5BdHRyaWJ1dGUsXG4gICAgSW5qZWN0LFxufSBmcm9tIFwiQGFuZ3VsYXIvY29yZVwiO1xuaW1wb3J0IHsgSWd4Q2FsZW5kYXJNb250aERpcmVjdGl2ZSB9IGZyb20gXCIuLi9jYWxlbmRhci5kaXJlY3RpdmVzXCI7XG5pbXBvcnQgeyBOZ0ZvciwgVGl0bGVDYXNlUGlwZSwgRGF0ZVBpcGUgfSBmcm9tIFwiQGFuZ3VsYXIvY29tbW9uXCI7XG5pbXBvcnQge1xuICAgIElneENhbGVuZGFyVmlld0RpcmVjdGl2ZSxcbiAgICBEQVlfSU5URVJWQUxfVE9LRU4sXG59IGZyb20gXCIuLi9jb21tb24vY2FsZW5kYXItdmlldy5kaXJlY3RpdmVcIjtcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gXCJAYW5ndWxhci9mb3Jtc1wiO1xuaW1wb3J0IHsgQ2FsZW5kYXJEYXkgfSBmcm9tIFwiLi4vY29tbW9uL21vZGVsXCI7XG5pbXBvcnQgdHlwZSB7IERheUludGVydmFsIH0gZnJvbSBcIi4uL2NvbW1vbi9tb2RlbFwiO1xuaW1wb3J0IHsgY2FsZW5kYXJSYW5nZSB9IGZyb20gXCIuLi9jb21tb24vaGVscGVyc1wiO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUixcbiAgICAgICAgICAgIHVzZUV4aXN0aW5nOiBJZ3hNb250aHNWaWV3Q29tcG9uZW50LFxuICAgICAgICAgICAgbXVsdGk6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb3ZpZGU6IERBWV9JTlRFUlZBTF9UT0tFTixcbiAgICAgICAgICAgIHVzZVZhbHVlOiBcIm1vbnRoXCIsXG4gICAgICAgIH0sXG4gICAgXSxcbiAgICBzZWxlY3RvcjogXCJpZ3gtbW9udGhzLXZpZXdcIixcbiAgICB0ZW1wbGF0ZVVybDogXCJtb250aHMtdmlldy5jb21wb25lbnQuaHRtbFwiLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW05nRm9yLCBJZ3hDYWxlbmRhck1vbnRoRGlyZWN0aXZlLCBUaXRsZUNhc2VQaXBlLCBEYXRlUGlwZV0sXG59KVxuZXhwb3J0IGNsYXNzIElneE1vbnRoc1ZpZXdDb21wb25lbnQgZXh0ZW5kcyBJZ3hDYWxlbmRhclZpZXdEaXJlY3RpdmUgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgI3N0YW5kYWxvbmUgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgaWRgIG9mIHRoZSBtb250aHMgdmlldy5cbiAgICAgKiBJZiBub3Qgc2V0LCB0aGUgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LW1vbnRocy12aWV3LTBcImAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbW9udGhzLXZpZXcgaWQ9XCJteS1tb250aHMtdmlld1wiPjwvaWd4LW1vbnRocy12aWV3PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgbW9udGhzVmlld0lkID0gIHRoaXMubW9udGhzVmlldy5pZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hNb250aHNWaWV3Q29tcG9uZW50XG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKFwiYXR0ci5pZFwiKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1tb250aHMtdmlldy0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY3NzIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoXCJjbGFzcy5pZ3gtbW9udGhzLXZpZXdcIilcbiAgICBwdWJsaWMgcmVhZG9ubHkgdmlld0NsYXNzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBASG9zdEJpbmRpbmcoXCJjbGFzcy5pZ3gtbW9udGhzLXZpZXctLXN0YW5kYWxvbmVcIilcbiAgICBwdWJsaWMgZ2V0IHN0YW5kYWxvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzdGFuZGFsb25lO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgc3RhbmRhbG9uZSh2YWx1ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLiNzdGFuZGFsb25lID0gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbW9udGggZm9ybWF0IG9wdGlvbiBvZiB0aGUgbW9udGhzIHZpZXcuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBtb250aEZvcm1hdCA9IHRoaXMubW9udGhzVmlldy5tb250aEZvcm1hdC5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgbW9udGhGb3JtYXQoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoRm9ybWF0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1vbnRoIGZvcm1hdCBvcHRpb24gb2YgdGhlIG1vbnRocyB2aWV3LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW1vbnRocy12aWV3PiBbbW9udGhGb3JtYXRdPVwic2hvcnQnXCI8L2lneC1tb250aHMtdmlldz5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBJZ3hNb250aHNWaWV3Q29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBtb250aEZvcm1hdCh2YWx1ZTogYW55KSB7XG4gICAgICAgIHRoaXMuX21vbnRoRm9ybWF0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuaW5pdEZvcm1hdHRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMvc2V0cyB3aGV0aGVyIHRoZSB2aWV3IHNob3VsZCBiZSByZW5kZXJlZFxuICAgICAqIGFjY29yZGluZyB0byB0aGUgbG9jYWxlIGFuZCBmb3JtYXQsIGlmIGFueS5cbiAgICAgKi9cbiAgICBASW5wdXQoeyB0cmFuc2Zvcm06IGJvb2xlYW5BdHRyaWJ1dGUgfSlcbiAgICBwdWJsaWMgb3ZlcnJpZGUgZm9ybWF0VmlldyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGRhdGUgb2JqZWN0cyB3aGljaCBhcmUgdGhlbiB1c2VkIHRvXG4gICAgICogcHJvcGVybHkgcmVuZGVyIHRoZSBtb250aCBuYW1lcy5cbiAgICAgKlxuICAgICAqIFVzZWQgaW4gdGhlIHRlbXBsYXRlIG9mIHRoZSBjb21wb25lbnRcbiAgICAgKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCByYW5nZSgpOiBEYXRlW10ge1xuICAgICAgICBjb25zdCBzdGFydCA9IENhbGVuZGFyRGF5LmZyb20odGhpcy5kYXRlKS5zZXQoeyBkYXRlOiAxLCBtb250aDogMCB9KTtcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQuYWRkKHRoaXMuZGF5SW50ZXJ2YWwsIDEyKTtcblxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShcbiAgICAgICAgICAgIGNhbGVuZGFyUmFuZ2UoeyBzdGFydCwgZW5kLCB1bml0OiB0aGlzLmRheUludGVydmFsIH0pLFxuICAgICAgICApLm1hcCgobSkgPT4gbS5uYXRpdmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcml2YXRlIF9tb250aEZvcm1hdCA9IFwic2hvcnRcIjtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZWw6IEVsZW1lbnRSZWYsXG4gICAgICAgIEBJbmplY3QoREFZX0lOVEVSVkFMX1RPS0VOKSBkYXlJbnRlcnZhbDogRGF5SW50ZXJ2YWwsXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGRheUludGVydmFsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1vbnRoIGluIHRoZSBtb250aHMgdmlldy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZm9ybWF0dGVkTW9udGgodmFsdWU6IERhdGUpOiB7IGxvbmc6IHN0cmluZzsgZm9ybWF0dGVkOiBzdHJpbmcgfSB7XG4gICAgICAgIGNvbnN0IHJhd0Zvcm1hdHRlciA9IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KHRoaXMubG9jYWxlLCB7XG4gICAgICAgICAgICBtb250aDogXCJsb25nXCIsXG4gICAgICAgICAgICB5ZWFyOiBcIm51bWVyaWNcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Vmlldykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsb25nOiByYXdGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSxcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWQ6IHRoaXMuX2Zvcm1hdHRlci5mb3JtYXQodmFsdWUpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb25nOiByYXdGb3JtYXR0ZXIuZm9ybWF0KHZhbHVlKSxcbiAgICAgICAgICAgIGZvcm1hdHRlZDogYCR7dmFsdWUuZ2V0TW9udGgoKX1gLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbW9udGhUcmFja2VyKF86IG51bWJlciwgaXRlbTogRGF0ZSk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiBgJHtpdGVtLmdldE1vbnRoKCl9fWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBpbml0Rm9ybWF0dGVyKCkge1xuICAgICAgICB0aGlzLl9mb3JtYXR0ZXIgPSBuZXcgSW50bC5EYXRlVGltZUZvcm1hdCh0aGlzLl9sb2NhbGUsIHtcbiAgICAgICAgICAgIG1vbnRoOiB0aGlzLm1vbnRoRm9ybWF0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCI8ZGl2IGNsYXNzPVwiaWd4LW1vbnRocy12aWV3X19ncmlkXCIgcm9sZT1cInJvd1wiPlxuICAgIDxzcGFuXG4gICAgICAgIGlneENhbGVuZGFyTW9udGhcbiAgICAgICAgI2l0ZW09XCJpZ3hDYWxlbmRhck1vbnRoXCJcbiAgICAgICAgKm5nRm9yPVwibGV0IG1vbnRoIG9mIHJhbmdlOyB0cmFja0J5OiBtb250aFRyYWNrZXJcIlxuICAgICAgICBjbGFzcz1cImlneC1tb250aHMtdmlld19fbW9udGhcIlxuICAgICAgICByb2xlPVwiZ3JpZGNlbGxcIlxuICAgICAgICBbYXR0ci5pZF09XCJtb250aC5nZXRUaW1lKClcIlxuICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImZvcm1hdHRlZE1vbnRoKG1vbnRoKS5sb25nXCJcbiAgICAgICAgW2F0dHIuYXJpYS1zZWxlY3RlZF09XCJpdGVtLmlzU2VsZWN0ZWRcIlxuICAgICAgICBbdmFsdWVdPVwibW9udGhcIlxuICAgICAgICBbZGF0ZV09XCJkYXRlXCJcbiAgICAgICAgW3Nob3dBY3RpdmVdPVwic2hvd0FjdGl2ZVwiXG4gICAgICAgIChpdGVtU2VsZWN0aW9uKT1cInNlbGVjdERhdGUoJGV2ZW50KVwiXG4gICAgPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1tb250aHMtdmlld19fbW9udGgtaW5uZXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIj5cbiAgICAgICAgICAgIHt7IGZvcm1hdHRlZE1vbnRoKG1vbnRoKS5mb3JtYXR0ZWQgfCB0aXRsZWNhc2UgfX1cbiAgICAgICAgPC9zcGFuPlxuICAgIDwvc3Bhbj5cbjwvZGl2PlxuIl19
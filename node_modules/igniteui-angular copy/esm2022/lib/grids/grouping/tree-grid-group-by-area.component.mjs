import { Component, Input, } from '@angular/core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { IgxGroupByAreaDirective, IgxGroupByMetaPipe } from './group-by-area.directive';
import { IgxDropDirective } from '../../directives/drag-drop/drag-drop.directive';
import { IgxGroupAreaDropDirective } from '../grid/grid.directives';
import { IgxSuffixDirective } from '../../directives/suffix/suffix.directive';
import { IgxIconComponent } from '../../icon/icon.component';
import { IgxChipComponent } from '../../chips/chip.component';
import { NgFor, NgTemplateOutlet } from '@angular/common';
import { IgxChipsAreaComponent } from '../../chips/chips-area.component';
import * as i0 from "@angular/core";
import * as i1 from "../../core/utils";
/**
 * An internal component representing the group-by drop area for the igx-grid component.
 *
 * @hidden @internal
 */
export class IgxTreeGridGroupByAreaComponent extends IgxGroupByAreaDirective {
    get hideGroupedColumns() {
        return this._hideGroupedColumns;
    }
    set hideGroupedColumns(value) {
        if (this.grid.columns && this.expressions) {
            this.setColumnsVisibility(value);
        }
        this._hideGroupedColumns = value;
    }
    constructor(differs, ref, platform) {
        super(ref, platform);
        this.differs = differs;
        this._hideGroupedColumns = false;
        this.destroy$ = new Subject();
    }
    ngAfterContentInit() {
        if (this.grid.columns && this.expressions) {
            this.groupingDiffer = this.differs.find(this.expressions).create();
            this.updateColumnsVisibility();
        }
        this.grid.sortingExpressionsChange.pipe(takeUntil(this.destroy$)).subscribe((sortingExpressions) => {
            if (!this.expressions || !this.expressions.length) {
                return;
            }
            let changed = false;
            sortingExpressions.forEach((sortExpr) => {
                const fieldName = sortExpr.fieldName;
                const groupingExpr = this.expressions.find(ex => ex.fieldName === fieldName);
                if (groupingExpr && groupingExpr.dir !== sortExpr.dir) {
                    groupingExpr.dir = sortExpr.dir;
                    changed = true;
                }
            });
            if (changed) {
                this.expressions = [...this.expressions];
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    handleReorder(event) {
        const { chipsArray, originalEvent } = event;
        const newExpressions = this.getReorderedExpressions(chipsArray);
        this.chipExpressions = newExpressions;
        // When reordered using keyboard navigation, we don't have `onMoveEnd` event.
        if (originalEvent instanceof KeyboardEvent) {
            this.expressions = newExpressions;
        }
    }
    handleMoveEnd() {
        this.expressions = this.chipExpressions;
    }
    groupBy(expression) {
        this.expressions.push(expression);
        this.expressions = [...this.expressions];
    }
    clearGrouping(name) {
        this.expressions = this.expressions.filter(item => item.fieldName !== name);
        this.grid.sortingExpressions = this.grid.sortingExpressions.filter(item => item.fieldName !== name);
        this.grid.notifyChanges(true);
    }
    expressionsChanged() {
        this.updateColumnsVisibility();
    }
    updateColumnsVisibility() {
        if (this.groupingDiffer && this.grid.columns && !this.grid.hasColumnLayouts) {
            const changes = this.groupingDiffer.diff(this.expressions);
            if (changes && this.grid.columns.length > 0) {
                changes.forEachAddedItem((rec) => {
                    const col = this.grid.getColumnByName(rec.item.fieldName);
                    col.hidden = this.hideGroupedColumns;
                });
                changes.forEachRemovedItem((rec) => {
                    const col = this.grid.getColumnByName(rec.item.fieldName);
                    col.hidden = false;
                });
            }
        }
    }
    setColumnsVisibility(value) {
        if (this.grid.columns.length > 0 && !this.grid.hasColumnLayouts) {
            this.expressions.forEach((expr) => {
                const col = this.grid.getColumnByName(expr.fieldName);
                col.hidden = value;
            });
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeGridGroupByAreaComponent, deps: [{ token: i0.IterableDiffers }, { token: i0.ElementRef }, { token: i1.PlatformUtil }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxTreeGridGroupByAreaComponent, isStandalone: true, selector: "igx-tree-grid-group-by-area", inputs: { hideGroupedColumns: "hideGroupedColumns" }, providers: [{ provide: IgxGroupByAreaDirective, useExisting: IgxTreeGridGroupByAreaComponent }], usesInheritance: true, ngImport: i0, template: "<igx-chips-area (reorder)=\"handleReorder($event)\" (moveEnd)=\"handleMoveEnd()\">\r\n    <ng-container *ngFor=\"let expression of chipExpressions; let last = last;\">\r\n        <igx-chip\r\n            [id]=\"expression.fieldName\"\r\n            [title]=\"(expression.fieldName | igxGroupByMeta:grid).title\"\r\n            [displayDensity]=\"grid.displayDensity\"\r\n            [removable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\r\n            [draggable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\r\n            [disabled]=\"!(expression.fieldName | igxGroupByMeta:grid).groupable\"\r\n            (keyDown)=\"handleKeyDown($event.owner.id, $event.originalEvent)\"\r\n            (remove)=\"clearGrouping($event.owner.id)\"\r\n            (chipClick)=\"handleClick(expression.fieldName)\"\r\n        >\r\n            <span>{{ (expression.fieldName | igxGroupByMeta:grid).title }}</span>\r\n            <igx-icon igxSuffix>{{ expression.dir === 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\r\n        </igx-chip>\r\n\r\n        <span class=\"igx-grid-grouparea__connector\">\r\n            <igx-icon [hidden]=\"(last && !dropAreaVisible)\">arrow_forward</igx-icon>\r\n        </span>\r\n    </ng-container>\r\n    <div igxGroupAreaDrop class=\"igx-drop-area{{ density !== 'comfortable' ? '--' + density : ''}}\"\r\n        [attr.gridId]=\"grid.id\"\r\n        [hidden]=\"!dropAreaVisible\"\r\n        (igxDrop)=\"onDragDrop($event)\"\r\n    >\r\n        <ng-container *ngTemplateOutlet=\"dropAreaTemplate || default\"></ng-container>\r\n    </div>\r\n</igx-chips-area>\r\n\r\n<ng-template #default>\r\n    <igx-icon class=\"igx-drop-area__icon\">group_work</igx-icon>\r\n    <span class=\"igx-drop-area__text\">{{ dropAreaMessage }}</span>\r\n</ng-template>\r\n", dependencies: [{ kind: "component", type: IgxChipsAreaComponent, selector: "igx-chips-area", inputs: ["width", "height"], outputs: ["reorder", "selectionChange", "moveStart", "moveEnd"] }, { kind: "directive", type: NgFor, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "component", type: IgxChipComponent, selector: "igx-chip", inputs: ["variant", "id", "tabIndex", "data", "draggable", "animateOnRelease", "hideBaseOnDrag", "removable", "removeIcon", "selectable", "selectIcon", "class", "disabled", "selected", "color", "resourceStrings"], outputs: ["selectedChange", "moveStart", "moveEnd", "remove", "chipClick", "selectedChanging", "selectedChanged", "keyDown", "dragEnter", "dragLeave", "dragOver", "dragDrop"] }, { kind: "component", type: IgxIconComponent, selector: "igx-icon", inputs: ["family", "active", "name"] }, { kind: "directive", type: IgxSuffixDirective, selector: "igx-suffix,[igxSuffix],[igxEnd]" }, { kind: "directive", type: IgxGroupAreaDropDirective, selector: "[igxGroupAreaDrop]" }, { kind: "directive", type: IgxDropDirective, selector: "[igxDrop]", inputs: ["igxDrop", "dropChannel", "dropStrategy"], outputs: ["enter", "over", "leave", "dropped"], exportAs: ["drop"] }, { kind: "directive", type: NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "pipe", type: IgxGroupByMetaPipe, name: "igxGroupByMeta" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxTreeGridGroupByAreaComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-tree-grid-group-by-area', providers: [{ provide: IgxGroupByAreaDirective, useExisting: IgxTreeGridGroupByAreaComponent }], standalone: true, imports: [IgxChipsAreaComponent, NgFor, IgxChipComponent, IgxIconComponent, IgxSuffixDirective, IgxGroupAreaDropDirective, IgxDropDirective, NgTemplateOutlet, IgxGroupByMetaPipe], template: "<igx-chips-area (reorder)=\"handleReorder($event)\" (moveEnd)=\"handleMoveEnd()\">\r\n    <ng-container *ngFor=\"let expression of chipExpressions; let last = last;\">\r\n        <igx-chip\r\n            [id]=\"expression.fieldName\"\r\n            [title]=\"(expression.fieldName | igxGroupByMeta:grid).title\"\r\n            [displayDensity]=\"grid.displayDensity\"\r\n            [removable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\r\n            [draggable]=\"(expression.fieldName | igxGroupByMeta:grid).groupable\"\r\n            [disabled]=\"!(expression.fieldName | igxGroupByMeta:grid).groupable\"\r\n            (keyDown)=\"handleKeyDown($event.owner.id, $event.originalEvent)\"\r\n            (remove)=\"clearGrouping($event.owner.id)\"\r\n            (chipClick)=\"handleClick(expression.fieldName)\"\r\n        >\r\n            <span>{{ (expression.fieldName | igxGroupByMeta:grid).title }}</span>\r\n            <igx-icon igxSuffix>{{ expression.dir === 1 ? 'arrow_upward' : 'arrow_downward' }}</igx-icon>\r\n        </igx-chip>\r\n\r\n        <span class=\"igx-grid-grouparea__connector\">\r\n            <igx-icon [hidden]=\"(last && !dropAreaVisible)\">arrow_forward</igx-icon>\r\n        </span>\r\n    </ng-container>\r\n    <div igxGroupAreaDrop class=\"igx-drop-area{{ density !== 'comfortable' ? '--' + density : ''}}\"\r\n        [attr.gridId]=\"grid.id\"\r\n        [hidden]=\"!dropAreaVisible\"\r\n        (igxDrop)=\"onDragDrop($event)\"\r\n    >\r\n        <ng-container *ngTemplateOutlet=\"dropAreaTemplate || default\"></ng-container>\r\n    </div>\r\n</igx-chips-area>\r\n\r\n<ng-template #default>\r\n    <igx-icon class=\"igx-drop-area__icon\">group_work</igx-icon>\r\n    <span class=\"igx-drop-area__text\">{{ dropAreaMessage }}</span>\r\n</ng-template>\r\n" }]
        }], ctorParameters: function () { return [{ type: i0.IterableDiffers }, { type: i0.ElementRef }, { type: i1.PlatformUtil }]; }, propDecorators: { hideGroupedColumns: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLWdyb3VwLWJ5LWFyZWEuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL2dyaWRzL2dyb3VwaW5nL3RyZWUtZ3JpZC1ncm91cC1ieS1hcmVhLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9ncmlkcy9ncm91cGluZy9ncm91cC1ieS1hcmVhLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFSCxTQUFTLEVBRVQsS0FBSyxHQUlSLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBSzNDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3hGLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGdEQUFnRCxDQUFDO0FBQ2xGLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDBDQUEwQyxDQUFDO0FBQzlFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzdELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBQzlELE9BQU8sRUFBRSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMxRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxrQ0FBa0MsQ0FBQzs7O0FBRXpFOzs7O0dBSUc7QUFRSCxNQUFNLE9BQU8sK0JBQWdDLFNBQVEsdUJBQXVCO0lBQ3hFLElBQ1csa0JBQWtCO1FB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dUIsRUFBRSxXQUFXLGlDQUFpQyxFQUFFLENBQUMsY0FDbkYsSUFBSSxXQUNQLENBQUMscUJBQXFCLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixFQUFFLHlCQUF5QixFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLGtCQUFrQixDQUFDOzBKQUl2SyxrQkFBa0I7c0JBRDVCLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSW5wdXQsXG4gICAgSXRlcmFibGVEaWZmZXIsXG4gICAgSXRlcmFibGVEaWZmZXJzLFxuICAgIE9uRGVzdHJveSxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJQ2hpcHNBcmVhUmVvcmRlckV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NoaXBzL3B1YmxpY19hcGknO1xuaW1wb3J0IHsgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJR3JvdXBpbmdFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vZGF0YS1vcGVyYXRpb25zL2dyb3VwaW5nLWV4cHJlc3Npb24uaW50ZXJmYWNlJztcbmltcG9ydCB7IElTb3J0aW5nRXhwcmVzc2lvbiB9IGZyb20gJy4uLy4uL2RhdGEtb3BlcmF0aW9ucy9zb3J0aW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IElneEdyb3VwQnlBcmVhRGlyZWN0aXZlLCBJZ3hHcm91cEJ5TWV0YVBpcGUgfSBmcm9tICcuL2dyb3VwLWJ5LWFyZWEuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneERyb3BEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL2RyYWctZHJvcC9kcmFnLWRyb3AuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEdyb3VwQXJlYURyb3BEaXJlY3RpdmUgfSBmcm9tICcuLi9ncmlkL2dyaWQuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBJZ3hTdWZmaXhEaXJlY3RpdmUgfSBmcm9tICcuLi8uLi9kaXJlY3RpdmVzL3N1ZmZpeC9zdWZmaXguZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEljb25Db21wb25lbnQgfSBmcm9tICcuLi8uLi9pY29uL2ljb24uY29tcG9uZW50JztcbmltcG9ydCB7IElneENoaXBDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jaGlwcy9jaGlwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBOZ0ZvciwgTmdUZW1wbGF0ZU91dGxldCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hDaGlwc0FyZWFDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jaGlwcy9jaGlwcy1hcmVhLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQW4gaW50ZXJuYWwgY29tcG9uZW50IHJlcHJlc2VudGluZyB0aGUgZ3JvdXAtYnkgZHJvcCBhcmVhIGZvciB0aGUgaWd4LWdyaWQgY29tcG9uZW50LlxuICpcbiAqIEBoaWRkZW4gQGludGVybmFsXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRyZWUtZ3JpZC1ncm91cC1ieS1hcmVhJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2dyb3VwLWJ5LWFyZWEuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogSWd4R3JvdXBCeUFyZWFEaXJlY3RpdmUsIHVzZUV4aXN0aW5nOiBJZ3hUcmVlR3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IH1dLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW0lneENoaXBzQXJlYUNvbXBvbmVudCwgTmdGb3IsIElneENoaXBDb21wb25lbnQsIElneEljb25Db21wb25lbnQsIElneFN1ZmZpeERpcmVjdGl2ZSwgSWd4R3JvdXBBcmVhRHJvcERpcmVjdGl2ZSwgSWd4RHJvcERpcmVjdGl2ZSwgTmdUZW1wbGF0ZU91dGxldCwgSWd4R3JvdXBCeU1ldGFQaXBlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hUcmVlR3JpZEdyb3VwQnlBcmVhQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JvdXBCeUFyZWFEaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBPbkRlc3Ryb3kge1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBoaWRlR3JvdXBlZENvbHVtbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oaWRlR3JvdXBlZENvbHVtbnM7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBoaWRlR3JvdXBlZENvbHVtbnModmFsdWU6IGJvb2xlYW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZC5jb2x1bW5zICYmIHRoaXMuZXhwcmVzc2lvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29sdW1uc1Zpc2liaWxpdHkodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faGlkZUdyb3VwZWRDb2x1bW5zID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfaGlkZUdyb3VwZWRDb2x1bW5zID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBncm91cGluZ0RpZmZlcjogSXRlcmFibGVEaWZmZXI8SUdyb3VwaW5nRXhwcmVzc2lvbj47XG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGFueT4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGlmZmVyczogSXRlcmFibGVEaWZmZXJzLCByZWY6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+LCBwbGF0Zm9ybTogUGxhdGZvcm1VdGlsKSB7XG4gICAgICAgIHN1cGVyKHJlZiwgcGxhdGZvcm0pO1xuICAgIH1cblxuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuY29sdW1ucyAmJiB0aGlzLmV4cHJlc3Npb25zKSB7XG4gICAgICAgICAgICB0aGlzLmdyb3VwaW5nRGlmZmVyID0gdGhpcy5kaWZmZXJzLmZpbmQodGhpcy5leHByZXNzaW9ucykuY3JlYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbHVtbnNWaXNpYmlsaXR5KCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmdyaWQuc29ydGluZ0V4cHJlc3Npb25zQ2hhbmdlLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKS5zdWJzY3JpYmUoKHNvcnRpbmdFeHByZXNzaW9uczogSVNvcnRpbmdFeHByZXNzaW9uW10pID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5leHByZXNzaW9ucyB8fCAhdGhpcy5leHByZXNzaW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHNvcnRpbmdFeHByZXNzaW9ucy5mb3JFYWNoKChzb3J0RXhwcjogSVNvcnRpbmdFeHByZXNzaW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gc29ydEV4cHIuZmllbGROYW1lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwaW5nRXhwciA9IHRoaXMuZXhwcmVzc2lvbnMuZmluZChleCA9PiBleC5maWVsZE5hbWUgPT09IGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwaW5nRXhwciAmJiBncm91cGluZ0V4cHIuZGlyICE9PSBzb3J0RXhwci5kaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBpbmdFeHByLmRpciA9IHNvcnRFeHByLmRpcjtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IFsuLi50aGlzLmV4cHJlc3Npb25zXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgaGFuZGxlUmVvcmRlcihldmVudDogSUNoaXBzQXJlYVJlb3JkZXJFdmVudEFyZ3MpIHtcbiAgICAgICAgY29uc3QgeyBjaGlwc0FycmF5LCBvcmlnaW5hbEV2ZW50IH0gPSBldmVudDtcbiAgICAgICAgY29uc3QgbmV3RXhwcmVzc2lvbnMgPSB0aGlzLmdldFJlb3JkZXJlZEV4cHJlc3Npb25zKGNoaXBzQXJyYXkpO1xuXG4gICAgICAgIHRoaXMuY2hpcEV4cHJlc3Npb25zID0gbmV3RXhwcmVzc2lvbnM7XG5cbiAgICAgICAgLy8gV2hlbiByZW9yZGVyZWQgdXNpbmcga2V5Ym9hcmQgbmF2aWdhdGlvbiwgd2UgZG9uJ3QgaGF2ZSBgb25Nb3ZlRW5kYCBldmVudC5cbiAgICAgICAgaWYgKG9yaWdpbmFsRXZlbnQgaW5zdGFuY2VvZiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gbmV3RXhwcmVzc2lvbnM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgaGFuZGxlTW92ZUVuZCgpIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucyA9IHRoaXMuY2hpcEV4cHJlc3Npb25zO1xuICAgIH1cblxuICAgIHB1YmxpYyBncm91cEJ5KGV4cHJlc3Npb246IElHcm91cGluZ0V4cHJlc3Npb24pIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9ucy5wdXNoKGV4cHJlc3Npb24pO1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gWy4uLnRoaXMuZXhwcmVzc2lvbnNdO1xuICAgIH1cblxuICAgIHB1YmxpYyBjbGVhckdyb3VwaW5nKG5hbWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLmV4cHJlc3Npb25zID0gdGhpcy5leHByZXNzaW9ucy5maWx0ZXIoaXRlbSA9PiBpdGVtLmZpZWxkTmFtZSAhPT0gbmFtZSk7XG4gICAgICAgIHRoaXMuZ3JpZC5zb3J0aW5nRXhwcmVzc2lvbnMgPSB0aGlzLmdyaWQuc29ydGluZ0V4cHJlc3Npb25zLmZpbHRlcihpdGVtID0+IGl0ZW0uZmllbGROYW1lICE9PSBuYW1lKTtcbiAgICAgICAgdGhpcy5ncmlkLm5vdGlmeUNoYW5nZXModHJ1ZSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIG92ZXJyaWRlIGV4cHJlc3Npb25zQ2hhbmdlZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb2x1bW5zVmlzaWJpbGl0eSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlQ29sdW1uc1Zpc2liaWxpdHkoKSB7XG4gICAgICAgIGlmICh0aGlzLmdyb3VwaW5nRGlmZmVyICYmIHRoaXMuZ3JpZC5jb2x1bW5zICYmICF0aGlzLmdyaWQuaGFzQ29sdW1uTGF5b3V0cykge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMuZ3JvdXBpbmdEaWZmZXIuZGlmZih0aGlzLmV4cHJlc3Npb25zKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzICYmIHRoaXMuZ3JpZC5jb2x1bW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hBZGRlZEl0ZW0oKHJlYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2wgPSB0aGlzLmdyaWQuZ2V0Q29sdW1uQnlOYW1lKHJlYy5pdGVtLmZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbC5oaWRkZW4gPSB0aGlzLmhpZGVHcm91cGVkQ29sdW1ucztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLmZvckVhY2hSZW1vdmVkSXRlbSgocmVjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5nZXRDb2x1bW5CeU5hbWUocmVjLml0ZW0uZmllbGROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29sLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXRDb2x1bW5zVmlzaWJpbGl0eSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5ncmlkLmNvbHVtbnMubGVuZ3RoID4gMCAmJiAhdGhpcy5ncmlkLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIHRoaXMuZXhwcmVzc2lvbnMuZm9yRWFjaCgoZXhwcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbCA9IHRoaXMuZ3JpZC5nZXRDb2x1bW5CeU5hbWUoZXhwci5maWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbC5oaWRkZW4gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4iLCI8aWd4LWNoaXBzLWFyZWEgKHJlb3JkZXIpPVwiaGFuZGxlUmVvcmRlcigkZXZlbnQpXCIgKG1vdmVFbmQpPVwiaGFuZGxlTW92ZUVuZCgpXCI+XHJcbiAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBleHByZXNzaW9uIG9mIGNoaXBFeHByZXNzaW9uczsgbGV0IGxhc3QgPSBsYXN0O1wiPlxyXG4gICAgICAgIDxpZ3gtY2hpcFxyXG4gICAgICAgICAgICBbaWRdPVwiZXhwcmVzc2lvbi5maWVsZE5hbWVcIlxyXG4gICAgICAgICAgICBbdGl0bGVdPVwiKGV4cHJlc3Npb24uZmllbGROYW1lIHwgaWd4R3JvdXBCeU1ldGE6Z3JpZCkudGl0bGVcIlxyXG4gICAgICAgICAgICBbZGlzcGxheURlbnNpdHldPVwiZ3JpZC5kaXNwbGF5RGVuc2l0eVwiXHJcbiAgICAgICAgICAgIFtyZW1vdmFibGVdPVwiKGV4cHJlc3Npb24uZmllbGROYW1lIHwgaWd4R3JvdXBCeU1ldGE6Z3JpZCkuZ3JvdXBhYmxlXCJcclxuICAgICAgICAgICAgW2RyYWdnYWJsZV09XCIoZXhwcmVzc2lvbi5maWVsZE5hbWUgfCBpZ3hHcm91cEJ5TWV0YTpncmlkKS5ncm91cGFibGVcIlxyXG4gICAgICAgICAgICBbZGlzYWJsZWRdPVwiIShleHByZXNzaW9uLmZpZWxkTmFtZSB8IGlneEdyb3VwQnlNZXRhOmdyaWQpLmdyb3VwYWJsZVwiXHJcbiAgICAgICAgICAgIChrZXlEb3duKT1cImhhbmRsZUtleURvd24oJGV2ZW50Lm93bmVyLmlkLCAkZXZlbnQub3JpZ2luYWxFdmVudClcIlxyXG4gICAgICAgICAgICAocmVtb3ZlKT1cImNsZWFyR3JvdXBpbmcoJGV2ZW50Lm93bmVyLmlkKVwiXHJcbiAgICAgICAgICAgIChjaGlwQ2xpY2spPVwiaGFuZGxlQ2xpY2soZXhwcmVzc2lvbi5maWVsZE5hbWUpXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICAgIDxzcGFuPnt7IChleHByZXNzaW9uLmZpZWxkTmFtZSB8IGlneEdyb3VwQnlNZXRhOmdyaWQpLnRpdGxlIH19PC9zcGFuPlxyXG4gICAgICAgICAgICA8aWd4LWljb24gaWd4U3VmZml4Pnt7IGV4cHJlc3Npb24uZGlyID09PSAxID8gJ2Fycm93X3Vwd2FyZCcgOiAnYXJyb3dfZG93bndhcmQnIH19PC9pZ3gtaWNvbj5cclxuICAgICAgICA8L2lneC1jaGlwPlxyXG5cclxuICAgICAgICA8c3BhbiBjbGFzcz1cImlneC1ncmlkLWdyb3VwYXJlYV9fY29ubmVjdG9yXCI+XHJcbiAgICAgICAgICAgIDxpZ3gtaWNvbiBbaGlkZGVuXT1cIihsYXN0ICYmICFkcm9wQXJlYVZpc2libGUpXCI+YXJyb3dfZm9yd2FyZDwvaWd4LWljb24+XHJcbiAgICAgICAgPC9zcGFuPlxyXG4gICAgPC9uZy1jb250YWluZXI+XHJcbiAgICA8ZGl2IGlneEdyb3VwQXJlYURyb3AgY2xhc3M9XCJpZ3gtZHJvcC1hcmVhe3sgZGVuc2l0eSAhPT0gJ2NvbWZvcnRhYmxlJyA/ICctLScgKyBkZW5zaXR5IDogJyd9fVwiXHJcbiAgICAgICAgW2F0dHIuZ3JpZElkXT1cImdyaWQuaWRcIlxyXG4gICAgICAgIFtoaWRkZW5dPVwiIWRyb3BBcmVhVmlzaWJsZVwiXHJcbiAgICAgICAgKGlneERyb3ApPVwib25EcmFnRHJvcCgkZXZlbnQpXCJcclxuICAgID5cclxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZHJvcEFyZWFUZW1wbGF0ZSB8fCBkZWZhdWx0XCI+PC9uZy1jb250YWluZXI+XHJcbiAgICA8L2Rpdj5cclxuPC9pZ3gtY2hpcHMtYXJlYT5cclxuXHJcbjxuZy10ZW1wbGF0ZSAjZGVmYXVsdD5cclxuICAgIDxpZ3gtaWNvbiBjbGFzcz1cImlneC1kcm9wLWFyZWFfX2ljb25cIj5ncm91cF93b3JrPC9pZ3gtaWNvbj5cclxuICAgIDxzcGFuIGNsYXNzPVwiaWd4LWRyb3AtYXJlYV9fdGV4dFwiPnt7IGRyb3BBcmVhTWVzc2FnZSB9fTwvc3Bhbj5cclxuPC9uZy10ZW1wbGF0ZT5cclxuIl19
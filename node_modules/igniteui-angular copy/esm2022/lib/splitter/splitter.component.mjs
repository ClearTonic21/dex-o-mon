import { DOCUMENT, NgFor, NgIf } from '@angular/common';
import { Component, ContentChildren, EventEmitter, HostBinding, HostListener, Inject, Input, Output, forwardRef } from '@angular/core';
import { DragDirection, IgxDragDirective, IgxDragIgnoreDirective } from '../directives/drag-drop/drag-drop.directive';
import { IgxSplitterPaneComponent } from './splitter-pane/splitter-pane.component';
import * as i0 from "@angular/core";
/**
 * An enumeration that defines the `SplitterComponent` panes orientation.
 */
export var SplitterType;
(function (SplitterType) {
    SplitterType[SplitterType["Horizontal"] = 0] = "Horizontal";
    SplitterType[SplitterType["Vertical"] = 1] = "Vertical";
})(SplitterType || (SplitterType = {}));
/**
 * Provides a framework for a simple layout, splitting the view horizontally or vertically
 * into multiple smaller resizable and collapsible areas.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent Layouts
 *
 * @igxTheme igx-splitter-theme
 *
 * @igxKeywords splitter panes layout
 *
 * @igxGroup presentation
 *
 * @example
 * ```html
 * <igx-splitter>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 *  <igx-splitter-pane>
 *      ...
 *  </igx-splitter-pane>
 * </igx-splitter>
 * ```
 */
export class IgxSplitterComponent {
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    constructor(document, elementRef) {
        this.document = document;
        this.elementRef = elementRef;
        /**
        * @hidden
        * @internal
        */
        this.cssClass = 'igx-splitter';
        /**
         * @hidden @internal
         * Gets/Sets the `overflow` property of the current splitter.
         */
        this.overflow = 'hidden';
        /**
         * @hidden @internal
         * Sets/Gets the `display` property of the current splitter.
         */
        this.display = 'flex';
        /**
         * Event fired when resizing of panes starts.
         *
         * @example
         * ```html
         * <igx-splitter (resizeStart)='resizeStart($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeStart = new EventEmitter();
        /**
         * Event fired when resizing of panes is in progress.
         *
         * @example
         * ```html
         * <igx-splitter (resizing)='resizing($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizing = new EventEmitter();
        /**
         * Event fired when resizing of panes ends.
         *
         * @example
         * ```html
         * <igx-splitter (resizeEnd)='resizeEnd($event)'>
         *  <igx-splitter-pane>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.resizeEnd = new EventEmitter();
        this._type = SplitterType.Horizontal;
    }
    /**
     * Gets/Sets the splitter orientation.
     *
     * @example
     * ```html
     * <igx-splitter [type]="type">...</igx-splitter>
     * ```
     */
    get type() {
        return this._type;
    }
    set type(value) {
        this._type = value;
        this.resetPaneSizes();
        this.panes?.notifyOnChanges();
    }
    /**
     * @hidden @internal
     * Gets the `flex-direction` property of the current `SplitterComponent`.
     */
    get direction() {
        return this.type === SplitterType.Horizontal ? 'row' : 'column';
    }
    /** @hidden @internal */
    ngAfterContentInit() {
        this.initPanes();
        this.panes.changes.subscribe(() => {
            this.initPanes();
        });
    }
    /**
     * @hidden @internal
     * This method performs  initialization logic when the user starts dragging the splitter bar between each pair of panes.
     * @param pane - the main pane associated with the currently dragged bar.
     */
    onMoveStart(pane) {
        const panes = this.panes.toArray();
        this.pane = pane;
        this.sibling = panes[panes.indexOf(this.pane) + 1];
        const paneRect = this.pane.element.getBoundingClientRect();
        this.initialPaneSize = this.type === SplitterType.Horizontal ? paneRect.width : paneRect.height;
        const siblingRect = this.sibling.element.getBoundingClientRect();
        this.initialSiblingSize = this.type === SplitterType.Horizontal ? siblingRect.width : siblingRect.height;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeStart.emit(args);
    }
    /**
     * @hidden @internal
     * This method performs calculations concerning the sizes of each pair of panes when the bar between them is dragged.
     * @param delta - The difference along the X (or Y) axis between the initial and the current point when dragging the bar.
     */
    onMoving(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        this.pane.dragSize = paneSize + 'px';
        this.sibling.dragSize = siblingSize + 'px';
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizing.emit(args);
    }
    onMoveEnd(delta) {
        const min = parseInt(this.pane.minSize, 10) || 0;
        const max = parseInt(this.pane.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const minSibling = parseInt(this.sibling.minSize, 10) || 0;
        const maxSibling = parseInt(this.sibling.maxSize, 10) || this.initialPaneSize + this.initialSiblingSize;
        const paneSize = this.initialPaneSize - delta;
        const siblingSize = this.initialSiblingSize + delta;
        if (paneSize < min || paneSize > max || siblingSize < minSibling || siblingSize > maxSibling) {
            return;
        }
        if (this.pane.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentPaneSize = (paneSize / totalSize) * 100;
            this.pane.size = percentPaneSize + '%';
        }
        else {
            // px resize
            this.pane.size = paneSize + 'px';
        }
        if (this.sibling.isPercentageSize) {
            // handle % resizes
            const totalSize = this.getTotalSize();
            const percentSiblingPaneSize = (siblingSize / totalSize) * 100;
            this.sibling.size = percentSiblingPaneSize + '%';
        }
        else {
            // px resize
            this.sibling.size = siblingSize + 'px';
        }
        this.pane.dragSize = null;
        this.sibling.dragSize = null;
        const args = { pane: this.pane, sibling: this.sibling };
        this.resizeEnd.emit(args);
    }
    /** @hidden @internal */
    getPaneSiblingsByOrder(order, barIndex) {
        const panes = this.panes.toArray();
        const prevPane = panes[order - barIndex - 1];
        const nextPane = panes[order - barIndex];
        const siblings = [prevPane, nextPane];
        return siblings;
    }
    getTotalSize() {
        const computed = this.document.defaultView.getComputedStyle(this.elementRef.nativeElement);
        const totalSize = this.type === SplitterType.Horizontal ? computed.getPropertyValue('width') : computed.getPropertyValue('height');
        return parseFloat(totalSize);
    }
    /**
     * @hidden @internal
     * This method inits panes with properties.
     */
    initPanes() {
        this.panes.forEach(pane => {
            pane.owner = this;
            if (this.type === SplitterType.Horizontal) {
                pane.minWidth = pane.minSize ?? '0';
                pane.maxWidth = pane.maxSize ?? '100%';
            }
            else {
                pane.minHeight = pane.minSize ?? '0';
                pane.maxHeight = pane.maxSize ?? '100%';
            }
        });
        this.assignFlexOrder();
        if (this.panes.filter(x => x.collapsed).length > 0) {
            // if any panes are collapsed, reset sizes.
            this.resetPaneSizes();
        }
    }
    /**
     * @hidden @internal
     * This method reset pane sizes.
     */
    resetPaneSizes() {
        if (this.panes) {
            // if type is changed runtime, should reset sizes.
            this.panes.forEach(x => {
                x.size = 'auto';
                x.minWidth = '0';
                x.maxWidth = '100%';
                x.minHeight = '0';
                x.maxHeight = '100%';
            });
        }
    }
    /**
     * @hidden @internal
     * This method assigns the order of each pane.
     */
    assignFlexOrder() {
        let k = 0;
        this.panes.forEach((pane) => {
            pane.order = k;
            k += 2;
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitterComponent, deps: [{ token: DOCUMENT }, { token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxSplitterComponent, isStandalone: true, selector: "igx-splitter", inputs: { type: "type" }, outputs: { resizeStart: "resizeStart", resizing: "resizing", resizeEnd: "resizeEnd" }, host: { properties: { "class.igx-splitter": "this.cssClass", "style.overflow": "this.overflow", "style.display": "this.display", "attr.aria-orientation": "this.orientation", "style.flex-direction": "this.direction" } }, queries: [{ propertyName: "panes", predicate: IgxSplitterPaneComponent, read: IgxSplitterPaneComponent }], ngImport: i0, template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\r\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\r\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\r\n                    [type]=\"type\"\r\n                    [pane]=\"pane\"\r\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\r\n                    (moveStart)=\"onMoveStart($event)\"\r\n                    (moving)=\"onMoving($event)\"\r\n                    (movingEnd)='onMoveEnd($event)'>\r\n    </igx-splitter-bar>\r\n</ng-container>\r\n", dependencies: [{ kind: "directive", type: i0.forwardRef(function () { return NgFor; }), selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i0.forwardRef(function () { return NgIf; }), selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "component", type: i0.forwardRef(function () { return IgxSplitBarComponent; }), selector: "igx-splitter-bar", inputs: ["type", "order", "pane", "siblings"], outputs: ["moveStart", "moving", "movingEnd"] }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitterComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter', standalone: true, imports: [NgFor, NgIf, forwardRef(() => IgxSplitBarComponent)], template: "<ng-content select=\"igx-splitter-pane\"></ng-content>\r\n<ng-container *ngFor=\"let pane of panes; let last = last; let index= index;\">\r\n    <igx-splitter-bar *ngIf=\"!last\" [order]='pane.order + 1' role='separator'\r\n                    [type]=\"type\"\r\n                    [pane]=\"pane\"\r\n                    [siblings]='getPaneSiblingsByOrder(pane.order + 1, index)'\r\n                    (moveStart)=\"onMoveStart($event)\"\r\n                    (moving)=\"onMoving($event)\"\r\n                    (movingEnd)='onMoveEnd($event)'>\r\n    </igx-splitter-bar>\r\n</ng-container>\r\n" }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: [DOCUMENT]
                }] }, { type: i0.ElementRef }]; }, propDecorators: { panes: [{
                type: ContentChildren,
                args: [IgxSplitterPaneComponent, { read: IgxSplitterPaneComponent }]
            }], cssClass: [{
                type: HostBinding,
                args: ['class.igx-splitter']
            }], overflow: [{
                type: HostBinding,
                args: ['style.overflow']
            }], display: [{
                type: HostBinding,
                args: ['style.display']
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }], resizeStart: [{
                type: Output
            }], resizing: [{
                type: Output
            }], resizeEnd: [{
                type: Output
            }], type: [{
                type: Input
            }], direction: [{
                type: HostBinding,
                args: ['style.flex-direction']
            }] } });
export const SPLITTER_INTERACTION_KEYS = new Set('right down left up arrowright arrowdown arrowleft arrowup'.split(' '));
/**
 * @hidden @internal
 * Represents the draggable bar that visually separates panes and allows for changing their sizes.
 */
export class IgxSplitBarComponent {
    constructor() {
        /**
         * Set css class to the host element.
         */
        this.cssClass = 'igx-splitter-bar-host';
        /**
         * Gets/Sets the orientation.
         */
        this.type = SplitterType.Horizontal;
        /**
         * An event that is emitted whenever we start dragging the current `SplitBarComponent`.
         */
        this.moveStart = new EventEmitter();
        /**
         * An event that is emitted while we are dragging the current `SplitBarComponent`.
         */
        this.moving = new EventEmitter();
        this.movingEnd = new EventEmitter();
    }
    /**
     * @hidden
     * @internal
     */
    get tabindex() {
        return this.resizeDisallowed ? null : 0;
    }
    /**
     * @hidden
     * @internal
     */
    get orientation() {
        return this.type === SplitterType.Horizontal ? 'horizontal' : 'vertical';
    }
    /**
     * @hidden
     * @internal
     */
    get cursor() {
        if (this.resizeDisallowed) {
            return '';
        }
        return this.type === SplitterType.Horizontal ? 'col-resize' : 'row-resize';
    }
    /**
     * @hidden @internal
     */
    get prevButtonHidden() {
        return this.siblings[0].collapsed && !this.siblings[1].collapsed;
    }
    /**
     * @hidden @internal
     */
    keyEvent(event) {
        const key = event.key.toLowerCase();
        const ctrl = event.ctrlKey;
        event.stopPropagation();
        if (SPLITTER_INTERACTION_KEYS.has(key)) {
            event.preventDefault();
        }
        switch (key) {
            case 'arrowup':
            case 'up':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowdown':
            case 'down':
                if (this.type === SplitterType.Vertical) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            case 'arrowleft':
            case 'left':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(false);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(10);
                    }
                }
                break;
            case 'arrowright':
            case 'right':
                if (this.type === SplitterType.Horizontal) {
                    if (ctrl) {
                        this.onCollapsing(true);
                        break;
                    }
                    if (!this.resizeDisallowed) {
                        event.preventDefault();
                        this.moveStart.emit(this.pane);
                        this.moving.emit(-10);
                    }
                }
                break;
            default:
                break;
        }
    }
    /**
     * @hidden @internal
     */
    get dragDir() {
        return this.type === SplitterType.Horizontal ? DragDirection.VERTICAL : DragDirection.HORIZONTAL;
    }
    /**
     * @hidden @internal
     */
    get nextButtonHidden() {
        return this.siblings[1].collapsed && !this.siblings[0].collapsed;
    }
    /**
     * @hidden @internal
     */
    onDragStart(event) {
        if (this.resizeDisallowed) {
            event.cancel = true;
            return;
        }
        this.startPoint = this.type === SplitterType.Horizontal ? event.startX : event.startY;
        this.moveStart.emit(this.pane);
    }
    /**
     * @hidden @internal
     */
    onDragMove(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.moving.emit(delta);
            event.cancel = true;
            event.owner.element.nativeElement.style.transform = '';
        }
    }
    onDragEnd(event) {
        const isHorizontal = this.type === SplitterType.Horizontal;
        const curr = isHorizontal ? event.pageX : event.pageY;
        const delta = this.startPoint - curr;
        if (delta !== 0) {
            this.movingEnd.emit(delta);
        }
    }
    get resizeDisallowed() {
        const relatedTabs = this.siblings;
        return !!relatedTabs.find(x => x.resizable === false || x.collapsed === true);
    }
    /**
     * @hidden @internal
     */
    onCollapsing(next) {
        const prevSibling = this.siblings[0];
        const nextSibling = this.siblings[1];
        let target;
        if (next) {
            // if next is clicked when prev pane is hidden, show prev pane, else hide next pane.
            target = prevSibling.collapsed ? prevSibling : nextSibling;
        }
        else {
            // if prev is clicked when next pane is hidden, show next pane, else hide prev pane.
            target = nextSibling.collapsed ? nextSibling : prevSibling;
        }
        target.toggle();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitBarComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxSplitBarComponent, isStandalone: true, selector: "igx-splitter-bar", inputs: { type: "type", order: "order", pane: "pane", siblings: "siblings" }, outputs: { moveStart: "moveStart", moving: "moving", movingEnd: "movingEnd" }, host: { listeners: { "keydown": "keyEvent($event)" }, properties: { "class.igx-splitter-bar-host": "this.cssClass", "style.order": "this.order", "attr.tabindex": "this.tabindex", "attr.aria-orientation": "this.orientation" } }, ngImport: i0, template: "<div class=\"igx-splitter-bar\"\r\n    [class.igx-splitter-bar--vertical]='type === 0'\r\n    [style.cursor]='cursor'\r\n    igxDrag\r\n    [ghost]=\"false\"\r\n    [dragDirection]='dragDir'\r\n    (dragStart)='onDragStart($event)'\r\n    (dragMove)=\"onDragMove($event)\"\r\n    (dragEnd)=\"onDragEnd($event)\"\r\n>\r\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\r\n    <div class=\"igx-splitter-bar__handle\" ></div>\r\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\r\n</div>\r\n", dependencies: [{ kind: "directive", type: IgxDragDirective, selector: "[igxDrag]", inputs: ["igxDrag", "dragTolerance", "dragDirection", "dragChannel", "ghost", "ghostClass", "ghostTemplate", "ghostHost", "scrollContainer", "ghostOffsetX", "ghostOffsetY"], outputs: ["dragStart", "dragMove", "dragEnd", "dragClick", "ghostCreate", "ghostDestroy", "transitioned"], exportAs: ["drag"] }, { kind: "directive", type: IgxDragIgnoreDirective, selector: "[igxDragIgnore]" }] }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitBarComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter-bar', standalone: true, imports: [IgxDragDirective, IgxDragIgnoreDirective], template: "<div class=\"igx-splitter-bar\"\r\n    [class.igx-splitter-bar--vertical]='type === 0'\r\n    [style.cursor]='cursor'\r\n    igxDrag\r\n    [ghost]=\"false\"\r\n    [dragDirection]='dragDir'\r\n    (dragStart)='onDragStart($event)'\r\n    (dragMove)=\"onDragMove($event)\"\r\n    (dragEnd)=\"onDragEnd($event)\"\r\n>\r\n    <div class=\"igx-splitter-bar__expander--start\" igxDragIgnore (click)='onCollapsing(false)' [hidden]='prevButtonHidden'></div>\r\n    <div class=\"igx-splitter-bar__handle\" ></div>\r\n    <div class=\"igx-splitter-bar__expander--end\" igxDragIgnore (click)='onCollapsing(true)' [hidden]='nextButtonHidden'></div>\r\n</div>\r\n" }]
        }], propDecorators: { cssClass: [{
                type: HostBinding,
                args: ['class.igx-splitter-bar-host']
            }], type: [{
                type: Input
            }], order: [{
                type: HostBinding,
                args: ['style.order']
            }, {
                type: Input
            }], tabindex: [{
                type: HostBinding,
                args: ['attr.tabindex']
            }], orientation: [{
                type: HostBinding,
                args: ['attr.aria-orientation']
            }], pane: [{
                type: Input
            }], siblings: [{
                type: Input
            }], moveStart: [{
                type: Output
            }], moving: [{
                type: Output
            }], movingEnd: [{
                type: Output
            }], keyEvent: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvaWduaXRldWktYW5ndWxhci9zcmMvbGliL3NwbGl0dGVyL3NwbGl0dGVyLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci5jb21wb25lbnQuaHRtbCIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci1iYXIuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFFBQVEsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDeEQsT0FBTyxFQUFvQixTQUFTLEVBQUUsZUFBZSxFQUFjLFlBQVksRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFhLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoTCxPQUFPLEVBQUUsYUFBYSxFQUEyQyxnQkFBZ0IsRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQy9KLE9BQU8sRUFBRSx3QkFBd0IsRUFBRSxNQUFNLHlDQUF5QyxDQUFDOztBQUVuRjs7R0FFRztBQUNILE1BQU0sQ0FBTixJQUFZLFlBR1g7QUFIRCxXQUFZLFlBQVk7SUFDcEIsMkRBQVUsQ0FBQTtJQUNWLHVEQUFRLENBQUE7QUFDWixDQUFDLEVBSFcsWUFBWSxLQUFaLFlBQVksUUFHdkI7QUFPRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXlCRztBQU9ILE1BQU0sT0FBTyxvQkFBb0I7SUFpQzdCOzs7T0FHRztJQUNILElBQ1csV0FBVztRQUNsQixPQUFPLElBQUksQ0FBQyxJQUFJLEtBQUssWUFBWSxDQUFDLFVBQVUs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QW1CQSxRQUFRO3NCQURkLFlBQVk7dUJBQUMsU0FBUyxFQUFFLENBQUMsUUFBUSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRE9DVU1FTlQsIE5nRm9yLCBOZ0lmIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENvbXBvbmVudCwgQ29udGVudENoaWxkcmVuLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIEhvc3RCaW5kaW5nLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5wdXQsIE91dHB1dCwgUXVlcnlMaXN0LCBmb3J3YXJkUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBEcmFnRGlyZWN0aW9uLCBJRHJhZ01vdmVFdmVudEFyZ3MsIElEcmFnU3RhcnRFdmVudEFyZ3MsIElneERyYWdEaXJlY3RpdmUsIElneERyYWdJZ25vcmVEaXJlY3RpdmUgfSBmcm9tICcuLi9kaXJlY3RpdmVzL2RyYWctZHJvcC9kcmFnLWRyb3AuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCB9IGZyb20gJy4vc3BsaXR0ZXItcGFuZS9zcGxpdHRlci1wYW5lLmNvbXBvbmVudCc7XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gdGhhdCBkZWZpbmVzIHRoZSBgU3BsaXR0ZXJDb21wb25lbnRgIHBhbmVzIG9yaWVudGF0aW9uLlxuICovXG5leHBvcnQgZW51bSBTcGxpdHRlclR5cGUge1xuICAgIEhvcml6b250YWwsXG4gICAgVmVydGljYWxcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncyB7XG4gICAgcGFuZTogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuICAgIHNpYmxpbmc6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcbn1cblxuLyoqXG4gKiBQcm92aWRlcyBhIGZyYW1ld29yayBmb3IgYSBzaW1wbGUgbGF5b3V0LCBzcGxpdHRpbmcgdGhlIHZpZXcgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHlcbiAqIGludG8gbXVsdGlwbGUgc21hbGxlciByZXNpemFibGUgYW5kIGNvbGxhcHNpYmxlIGFyZWFzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4U3BsaXR0ZXJNb2R1bGVcbiAqXG4gKiBAaWd4UGFyZW50IExheW91dHNcbiAqXG4gKiBAaWd4VGhlbWUgaWd4LXNwbGl0dGVyLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIHNwbGl0dGVyIHBhbmVzIGxheW91dFxuICpcbiAqIEBpZ3hHcm91cCBwcmVzZW50YXRpb25cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgaHRtbFxuICogPGlneC1zcGxpdHRlcj5cbiAqICA8aWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgICAgIC4uLlxuICogIDwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gKiAgPGlneC1zcGxpdHRlci1wYW5lPlxuICogICAgICAuLi5cbiAqICA8L2lneC1zcGxpdHRlci1wYW5lPlxuICogPC9pZ3gtc3BsaXR0ZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtc3BsaXR0ZXInLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zcGxpdHRlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZSxcbiAgICBpbXBvcnRzOiBbTmdGb3IsIE5nSWYsIGZvcndhcmRSZWYoKCkgPT4gSWd4U3BsaXRCYXJDb21wb25lbnQpXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTcGxpdHRlckNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3Qgb2Ygc3BsaXR0ZXIgcGFuZXMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCBwYW5lcyA9IHRoaXMuc3BsaXR0ZXIucGFuZXM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQsIHsgcmVhZDogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50IH0pXG4gICAgcHVibGljIHBhbmVzITogUXVlcnlMaXN0PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqIEBpbnRlcm5hbFxuICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtc3BsaXR0ZXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtc3BsaXR0ZXInO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzL1NldHMgdGhlIGBvdmVyZmxvd2AgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgc3BsaXR0ZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyZmxvdycpXG4gICAgcHVibGljIG92ZXJmbG93ID0gJ2hpZGRlbic7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFNldHMvR2V0cyB0aGUgYGRpc3BsYXlgIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHNwbGl0dGVyLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZGlzcGxheScpXG4gICAgcHVibGljIGRpc3BsYXkgPSAnZmxleCc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtb3JpZW50YXRpb24nKVxuICAgIHB1YmxpYyBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlc2l6aW5nIG9mIHBhbmVzIHN0YXJ0cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgKHJlc2l6ZVN0YXJ0KT0ncmVzaXplU3RhcnQoJGV2ZW50KSc+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZT4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXNpemVTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXI8SVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiByZXNpemluZyBvZiBwYW5lcyBpcyBpbiBwcm9ncmVzcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXIgKHJlc2l6aW5nKT0ncmVzaXppbmcoJGV2ZW50KSc+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZT4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXNpemluZyA9IG5ldyBFdmVudEVtaXR0ZXI8SVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzPigpO1xuXG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHJlc2l6aW5nIG9mIHBhbmVzIGVuZHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyIChyZXNpemVFbmQpPSdyZXNpemVFbmQoJGV2ZW50KSc+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZT4uLi48L2lneC1zcGxpdHRlci1wYW5lPlxuICAgICAqIDwvaWd4LXNwbGl0dGVyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyByZXNpemVFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncz4oKTtcblxuICAgIHByaXZhdGUgX3R5cGU6IFNwbGl0dGVyVHlwZSA9IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBBIGZpZWxkIHRoYXQgaG9sZHMgdGhlIGluaXRpYWwgc2l6ZSBvZiB0aGUgbWFpbiBgSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50YCBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIHNwbGl0dGVyIGJhci5cbiAgICAgKi9cbiAgICBwcml2YXRlIGluaXRpYWxQYW5lU2l6ZSE6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogQSBmaWVsZCB0aGF0IGhvbGRzIHRoZSBpbml0aWFsIHNpemUgb2YgdGhlIHNpYmxpbmcgcGFuZSBpbiBlYWNoIHBhaXIgb2YgcGFuZXMgZGl2aWRlZCBieSBhIGdyaXBwZXIuXG4gICAgICogQG1lbWJlcm9mIFNwbGl0dGVyQ29tcG9uZW50XG4gICAgICovXG4gICAgcHJpdmF0ZSBpbml0aWFsU2libGluZ1NpemUhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIFRoZSBtYWluIHBhbmUgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBncmlwcGVyLlxuICAgICAqL1xuICAgIHByaXZhdGUgcGFuZSE6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaWJsaW5nIHBhbmUgaW4gZWFjaCBwYWlyIG9mIHBhbmVzIGRpdmlkZWQgYnkgYSBzcGxpdHRlciBiYXIuXG4gICAgICovXG4gICAgcHJpdmF0ZSBzaWJsaW5nITogSWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50O1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChET0NVTUVOVCkgcHVibGljIGRvY3VtZW50LCBwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYpIHsgfVxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc3BsaXR0ZXIgb3JpZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyIFt0eXBlXT1cInR5cGVcIj4uLi48L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGU7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgdHlwZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90eXBlID0gdmFsdWU7XG4gICAgICAgIHRoaXMucmVzZXRQYW5lU2l6ZXMoKTtcbiAgICAgICAgdGhpcy5wYW5lcz8ubm90aWZ5T25DaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBgZmxleC1kaXJlY3Rpb25gIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGBTcGxpdHRlckNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4LWRpcmVjdGlvbicpXG4gICAgcHVibGljIGdldCBkaXJlY3Rpb24oKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAncm93JyA6ICdjb2x1bW4nO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuaW5pdFBhbmVzKCk7XG4gICAgICAgIHRoaXMucGFuZXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pbml0UGFuZXMoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyAgaW5pdGlhbGl6YXRpb24gbG9naWMgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHNwbGl0dGVyIGJhciBiZXR3ZWVuIGVhY2ggcGFpciBvZiBwYW5lcy5cbiAgICAgKiBAcGFyYW0gcGFuZSAtIHRoZSBtYWluIHBhbmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgZHJhZ2dlZCBiYXIuXG4gICAgICovXG4gICAgcHVibGljIG9uTW92ZVN0YXJ0KHBhbmU6IElneFNwbGl0dGVyUGFuZUNvbXBvbmVudCkge1xuICAgICAgICBjb25zdCBwYW5lcyA9IHRoaXMucGFuZXMudG9BcnJheSgpO1xuICAgICAgICB0aGlzLnBhbmUgPSBwYW5lO1xuICAgICAgICB0aGlzLnNpYmxpbmcgPSBwYW5lc1twYW5lcy5pbmRleE9mKHRoaXMucGFuZSkgKyAxXTtcblxuICAgICAgICBjb25zdCBwYW5lUmVjdCA9IHRoaXMucGFuZS5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxQYW5lU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBwYW5lUmVjdC53aWR0aCA6IHBhbmVSZWN0LmhlaWdodDtcblxuICAgICAgICBjb25zdCBzaWJsaW5nUmVjdCA9IHRoaXMuc2libGluZy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyBzaWJsaW5nUmVjdC53aWR0aCA6IHNpYmxpbmdSZWN0LmhlaWdodDtcbiAgICAgICAgY29uc3QgYXJnczogSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzID0geyBwYW5lOiB0aGlzLnBhbmUsIHNpYmxpbmc6IHRoaXMuc2libGluZyB9O1xuICAgICAgICB0aGlzLnJlc2l6ZVN0YXJ0LmVtaXQoYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyBjYWxjdWxhdGlvbnMgY29uY2VybmluZyB0aGUgc2l6ZXMgb2YgZWFjaCBwYWlyIG9mIHBhbmVzIHdoZW4gdGhlIGJhciBiZXR3ZWVuIHRoZW0gaXMgZHJhZ2dlZC5cbiAgICAgKiBAcGFyYW0gZGVsdGEgLSBUaGUgZGlmZmVyZW5jZSBhbG9uZyB0aGUgWCAob3IgWSkgYXhpcyBiZXR3ZWVuIHRoZSBpbml0aWFsIGFuZCB0aGUgY3VycmVudCBwb2ludCB3aGVuIGRyYWdnaW5nIHRoZSBiYXIuXG4gICAgICovXG4gICAgcHVibGljIG9uTW92aW5nKGRlbHRhOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgbWluID0gcGFyc2VJbnQodGhpcy5wYW5lLm1pblNpemUsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXggPSBwYXJzZUludCh0aGlzLnBhbmUubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG4gICAgICAgIGNvbnN0IG1pblNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWluU2l6ZSwgMTApIHx8IDA7XG4gICAgICAgIGNvbnN0IG1heFNpYmxpbmcgPSBwYXJzZUludCh0aGlzLnNpYmxpbmcubWF4U2l6ZSwgMTApIHx8IHRoaXMuaW5pdGlhbFBhbmVTaXplICsgdGhpcy5pbml0aWFsU2libGluZ1NpemU7XG5cbiAgICAgICAgY29uc3QgcGFuZVNpemUgPSB0aGlzLmluaXRpYWxQYW5lU2l6ZSAtIGRlbHRhO1xuICAgICAgICBjb25zdCBzaWJsaW5nU2l6ZSA9IHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplICsgZGVsdGE7XG4gICAgICAgIGlmIChwYW5lU2l6ZSA8IG1pbiB8fCBwYW5lU2l6ZSA+IG1heCB8fCBzaWJsaW5nU2l6ZSA8IG1pblNpYmxpbmcgfHwgc2libGluZ1NpemUgPiBtYXhTaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5lLmRyYWdTaXplID0gcGFuZVNpemUgKyAncHgnO1xuICAgICAgICB0aGlzLnNpYmxpbmcuZHJhZ1NpemUgPSBzaWJsaW5nU2l6ZSArICdweCc7XG5cbiAgICAgICAgY29uc3QgYXJnczogSVNwbGl0dGVyQmFyUmVzaXplRXZlbnRBcmdzID0geyBwYW5lOiB0aGlzLnBhbmUsIHNpYmxpbmc6IHRoaXMuc2libGluZyB9O1xuICAgICAgICB0aGlzLnJlc2l6aW5nLmVtaXQoYXJncyk7XG4gICAgfVxuXG4gICAgcHVibGljIG9uTW92ZUVuZChkZWx0YTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhcnNlSW50KHRoaXMucGFuZS5taW5TaXplLCAxMCkgfHwgMDtcbiAgICAgICAgY29uc3QgbWF4ID0gcGFyc2VJbnQodGhpcy5wYW5lLm1heFNpemUsIDEwKSB8fCB0aGlzLmluaXRpYWxQYW5lU2l6ZSArIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplO1xuICAgICAgICBjb25zdCBtaW5TaWJsaW5nID0gcGFyc2VJbnQodGhpcy5zaWJsaW5nLm1pblNpemUsIDEwKSB8fCAwO1xuICAgICAgICBjb25zdCBtYXhTaWJsaW5nID0gcGFyc2VJbnQodGhpcy5zaWJsaW5nLm1heFNpemUsIDEwKSB8fCB0aGlzLmluaXRpYWxQYW5lU2l6ZSArIHRoaXMuaW5pdGlhbFNpYmxpbmdTaXplO1xuXG4gICAgICAgIGNvbnN0IHBhbmVTaXplID0gdGhpcy5pbml0aWFsUGFuZVNpemUgLSBkZWx0YTtcbiAgICAgICAgY29uc3Qgc2libGluZ1NpemUgPSB0aGlzLmluaXRpYWxTaWJsaW5nU2l6ZSArIGRlbHRhO1xuXG4gICAgICAgIGlmIChwYW5lU2l6ZSA8IG1pbiB8fCBwYW5lU2l6ZSA+IG1heCB8fCBzaWJsaW5nU2l6ZSA8IG1pblNpYmxpbmcgfHwgc2libGluZ1NpemUgPiBtYXhTaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFuZS5pc1BlcmNlbnRhZ2VTaXplKSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgJSByZXNpemVzXG4gICAgICAgICAgICBjb25zdCB0b3RhbFNpemUgPSB0aGlzLmdldFRvdGFsU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudFBhbmVTaXplID0gKHBhbmVTaXplIC8gdG90YWxTaXplKSAqIDEwMDtcbiAgICAgICAgICAgIHRoaXMucGFuZS5zaXplID0gcGVyY2VudFBhbmVTaXplICsgJyUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcHggcmVzaXplXG4gICAgICAgICAgICB0aGlzLnBhbmUuc2l6ZSA9IHBhbmVTaXplICsgJ3B4JztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnNpYmxpbmcuaXNQZXJjZW50YWdlU2l6ZSkge1xuICAgICAgICAgICAgLy8gaGFuZGxlICUgcmVzaXplc1xuICAgICAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy5nZXRUb3RhbFNpemUoKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRTaWJsaW5nUGFuZVNpemUgPSAoc2libGluZ1NpemUgLyB0b3RhbFNpemUpICogMTAwO1xuICAgICAgICAgICAgdGhpcy5zaWJsaW5nLnNpemUgPSBwZXJjZW50U2libGluZ1BhbmVTaXplICsgJyUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcHggcmVzaXplXG4gICAgICAgICAgICB0aGlzLnNpYmxpbmcuc2l6ZSA9IHNpYmxpbmdTaXplICsgJ3B4JztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhbmUuZHJhZ1NpemUgPSBudWxsO1xuICAgICAgICB0aGlzLnNpYmxpbmcuZHJhZ1NpemUgPSBudWxsO1xuXG4gICAgICAgIGNvbnN0IGFyZ3M6IElTcGxpdHRlckJhclJlc2l6ZUV2ZW50QXJncyA9IHsgcGFuZTogdGhpcy5wYW5lLCBzaWJsaW5nOiB0aGlzLnNpYmxpbmcgfTtcbiAgICAgICAgdGhpcy5yZXNpemVFbmQuZW1pdChhcmdzKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwdWJsaWMgZ2V0UGFuZVNpYmxpbmdzQnlPcmRlcihvcmRlcjogbnVtYmVyLCBiYXJJbmRleDogbnVtYmVyKTogQXJyYXk8SWd4U3BsaXR0ZXJQYW5lQ29tcG9uZW50PiB7XG4gICAgICAgIGNvbnN0IHBhbmVzID0gdGhpcy5wYW5lcy50b0FycmF5KCk7XG4gICAgICAgIGNvbnN0IHByZXZQYW5lID0gcGFuZXNbb3JkZXIgLSBiYXJJbmRleCAtIDFdO1xuICAgICAgICBjb25zdCBuZXh0UGFuZSA9IHBhbmVzW29yZGVyIC0gYmFySW5kZXhdO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtwcmV2UGFuZSwgbmV4dFBhbmVdO1xuICAgICAgICByZXR1cm4gc2libGluZ3M7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRUb3RhbFNpemUoKSB7XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkID0gdGhpcy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgY29uc3QgdG90YWxTaXplID0gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJykgOiBjb21wdXRlZC5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG90YWxTaXplKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogVGhpcyBtZXRob2QgaW5pdHMgcGFuZXMgd2l0aCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgaW5pdFBhbmVzKCkge1xuICAgICAgICB0aGlzLnBhbmVzLmZvckVhY2gocGFuZSA9PiB7XG4gICAgICAgICAgICBwYW5lLm93bmVyID0gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgcGFuZS5taW5XaWR0aCA9IHBhbmUubWluU2l6ZSA/PyAnMCc7XG4gICAgICAgICAgICAgICAgcGFuZS5tYXhXaWR0aCA9IHBhbmUubWF4U2l6ZSA/PyAnMTAwJSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhbmUubWluSGVpZ2h0ID0gcGFuZS5taW5TaXplID8/ICcwJztcbiAgICAgICAgICAgICAgICBwYW5lLm1heEhlaWdodCA9IHBhbmUubWF4U2l6ZSA/PyAnMTAwJSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFzc2lnbkZsZXhPcmRlcigpO1xuICAgICAgICBpZiAodGhpcy5wYW5lcy5maWx0ZXIoeCA9PiB4LmNvbGxhcHNlZCkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gaWYgYW55IHBhbmVzIGFyZSBjb2xsYXBzZWQsIHJlc2V0IHNpemVzLlxuICAgICAgICAgICAgdGhpcy5yZXNldFBhbmVTaXplcygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCByZXNldCBwYW5lIHNpemVzLlxuICAgICAqL1xuICAgIHByaXZhdGUgcmVzZXRQYW5lU2l6ZXMoKSB7XG4gICAgICAgIGlmICh0aGlzLnBhbmVzKSB7XG4gICAgICAgICAgICAvLyBpZiB0eXBlIGlzIGNoYW5nZWQgcnVudGltZSwgc2hvdWxkIHJlc2V0IHNpemVzLlxuICAgICAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKHggPT4ge1xuICAgICAgICAgICAgICAgIHguc2l6ZSA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgIHgubWluV2lkdGggPSAnMCc7XG4gICAgICAgICAgICAgICAgeC5tYXhXaWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICB4Lm1pbkhlaWdodCA9ICcwJztcbiAgICAgICAgICAgICAgICB4Lm1heEhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBUaGlzIG1ldGhvZCBhc3NpZ25zIHRoZSBvcmRlciBvZiBlYWNoIHBhbmUuXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3NpZ25GbGV4T3JkZXIoKSB7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgdGhpcy5wYW5lcy5mb3JFYWNoKChwYW5lOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQpID0+IHtcbiAgICAgICAgICAgIHBhbmUub3JkZXIgPSBrO1xuICAgICAgICAgICAgayArPSAyO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCBTUExJVFRFUl9JTlRFUkFDVElPTl9LRVlTID0gbmV3IFNldCgncmlnaHQgZG93biBsZWZ0IHVwIGFycm93cmlnaHQgYXJyb3dkb3duIGFycm93bGVmdCBhcnJvd3VwJy5zcGxpdCgnICcpKTtcblxuLyoqXG4gKiBAaGlkZGVuIEBpbnRlcm5hbFxuICogUmVwcmVzZW50cyB0aGUgZHJhZ2dhYmxlIGJhciB0aGF0IHZpc3VhbGx5IHNlcGFyYXRlcyBwYW5lcyBhbmQgYWxsb3dzIGZvciBjaGFuZ2luZyB0aGVpciBzaXplcy5cbiAqL1xuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtc3BsaXR0ZXItYmFyJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BsaXR0ZXItYmFyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtJZ3hEcmFnRGlyZWN0aXZlLCBJZ3hEcmFnSWdub3JlRGlyZWN0aXZlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTcGxpdEJhckNvbXBvbmVudCB7XG4gICAgLyoqXG4gICAgICogU2V0IGNzcyBjbGFzcyB0byB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LXNwbGl0dGVyLWJhci1ob3N0JylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LXNwbGl0dGVyLWJhci1ob3N0JztcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgb3JpZW50YXRpb24uXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdHlwZTogU3BsaXR0ZXJUeXBlID0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGVsZW1lbnQgb3JkZXIuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vcmRlcicpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgb3JkZXIhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnRhYmluZGV4JylcbiAgICBwdWJsaWMgZ2V0IHRhYmluZGV4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNpemVEaXNhbGxvd2VkID8gbnVsbCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLW9yaWVudGF0aW9uJylcbiAgICBwdWJsaWMgZ2V0IG9yaWVudGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgY3Vyc29yKCkge1xuICAgICAgICBpZiAodGhpcy5yZXNpemVEaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWwgPyAnY29sLXJlc2l6ZScgOiAncm93LXJlc2l6ZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBgU3BsaXRQYW5lQ29tcG9uZW50YCBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgYFNwbGl0QmFyQ29tcG9uZW50YC5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBTcGxpdEJhckNvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHBhbmUhOiBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL0dldHMgdGhlIGBTcGxpdFBhbmVDb21wb25lbnRgIHNpYmxpbmcgY29tcG9uZW50cyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgYFNwbGl0QmFyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzaWJsaW5ncyE6IEFycmF5PElneFNwbGl0dGVyUGFuZUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hlbmV2ZXIgd2Ugc3RhcnQgZHJhZ2dpbmcgdGhlIGN1cnJlbnQgYFNwbGl0QmFyQ29tcG9uZW50YC5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgbW92ZVN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBldmVudCB0aGF0IGlzIGVtaXR0ZWQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIHRoZSBjdXJyZW50IGBTcGxpdEJhckNvbXBvbmVudGAuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG1vdmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG1vdmluZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gICAgLyoqXG4gICAgICogQSB0ZW1wb3JhcnkgaG9sZGVyIGZvciB0aGUgcG9pbnRlciBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlIHN0YXJ0UG9pbnQhOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgcHJldkJ1dHRvbkhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2libGluZ3NbMF0uY29sbGFwc2VkICYmICF0aGlzLnNpYmxpbmdzWzFdLmNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBrZXlFdmVudChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBjb25zdCBrZXkgPSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgY3RybCA9IGV2ZW50LmN0cmxLZXk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoU1BMSVRURVJfSU5URVJBQ1RJT05fS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgY2FzZSAnYXJyb3d1cCc6XG4gICAgICAgICAgICBjYXNlICd1cCc6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLlZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGFwc2luZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzaXplRGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0LmVtaXQodGhpcy5wYW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92aW5nLmVtaXQoMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYXJyb3dkb3duJzpcbiAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5WZXJ0aWNhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbGxhcHNpbmcodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMucmVzaXplRGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92ZVN0YXJ0LmVtaXQodGhpcy5wYW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW92aW5nLmVtaXQoLTEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fycm93bGVmdCc6XG4gICAgICAgICAgICBjYXNlICdsZWZ0JzpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3RybCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvbGxhcHNpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlc2l6ZURpc2FsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmVTdGFydC5lbWl0KHRoaXMucGFuZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1vdmluZy5lbWl0KDEwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Fycm93cmlnaHQnOlxuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdHJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ29sbGFwc2luZyh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZXNpemVEaXNhbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZlU3RhcnQuZW1pdCh0aGlzLnBhbmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb3ZpbmcuZW1pdCgtMTApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldCBkcmFnRGlyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTcGxpdHRlclR5cGUuSG9yaXpvbnRhbCA/IERyYWdEaXJlY3Rpb24uVkVSVElDQUwgOiBEcmFnRGlyZWN0aW9uLkhPUklaT05UQUw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG5leHRCdXR0b25IaWRkZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpYmxpbmdzWzFdLmNvbGxhcHNlZCAmJiAhdGhpcy5zaWJsaW5nc1swXS5jb2xsYXBzZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnU3RhcnQoZXZlbnQ6IElEcmFnU3RhcnRFdmVudEFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMucmVzaXplRGlzYWxsb3dlZCkge1xuICAgICAgICAgICAgZXZlbnQuY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXJ0UG9pbnQgPSB0aGlzLnR5cGUgPT09IFNwbGl0dGVyVHlwZS5Ib3Jpem9udGFsID8gZXZlbnQuc3RhcnRYIDogZXZlbnQuc3RhcnRZO1xuICAgICAgICB0aGlzLm1vdmVTdGFydC5lbWl0KHRoaXMucGFuZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnTW92ZShldmVudDogSURyYWdNb3ZlRXZlbnRBcmdzKSB7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG4gICAgICAgIGNvbnN0IGN1cnIgPSBpc0hvcml6b250YWwgPyBldmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VZO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuc3RhcnRQb2ludCAtIGN1cnI7XG4gICAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmcuZW1pdChkZWx0YSk7XG4gICAgICAgICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAgICAgICAgZXZlbnQub3duZXIuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIG9uRHJhZ0VuZChldmVudDogYW55KSB7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMudHlwZSA9PT0gU3BsaXR0ZXJUeXBlLkhvcml6b250YWw7XG4gICAgICAgIGNvbnN0IGN1cnIgPSBpc0hvcml6b250YWwgPyBldmVudC5wYWdlWCA6IGV2ZW50LnBhZ2VZO1xuICAgICAgICBjb25zdCBkZWx0YSA9IHRoaXMuc3RhcnRQb2ludCAtIGN1cnI7XG4gICAgICAgIGlmIChkZWx0YSAhPT0gMCkge1xuICAgICAgICAgICAgdGhpcy5tb3ZpbmdFbmQuZW1pdChkZWx0YSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IHJlc2l6ZURpc2FsbG93ZWQoKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYWJzID0gdGhpcy5zaWJsaW5ncztcbiAgICAgICAgcmV0dXJuICEhcmVsYXRlZFRhYnMuZmluZCh4ID0+IHgucmVzaXphYmxlID09PSBmYWxzZSB8fCB4LmNvbGxhcHNlZCA9PT0gdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Db2xsYXBzaW5nKG5leHQ6IGJvb2xlYW4pIHtcbiAgICAgICAgY29uc3QgcHJldlNpYmxpbmcgPSB0aGlzLnNpYmxpbmdzWzBdO1xuICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuc2libGluZ3NbMV07XG4gICAgICAgIGxldCB0YXJnZXQ7XG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgICAvLyBpZiBuZXh0IGlzIGNsaWNrZWQgd2hlbiBwcmV2IHBhbmUgaXMgaGlkZGVuLCBzaG93IHByZXYgcGFuZSwgZWxzZSBoaWRlIG5leHQgcGFuZS5cbiAgICAgICAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nLmNvbGxhcHNlZCA/IHByZXZTaWJsaW5nIDogbmV4dFNpYmxpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBwcmV2IGlzIGNsaWNrZWQgd2hlbiBuZXh0IHBhbmUgaXMgaGlkZGVuLCBzaG93IG5leHQgcGFuZSwgZWxzZSBoaWRlIHByZXYgcGFuZS5cbiAgICAgICAgICAgIHRhcmdldCA9IG5leHRTaWJsaW5nLmNvbGxhcHNlZCA/IG5leHRTaWJsaW5nIDogcHJldlNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnRvZ2dsZSgpO1xuICAgIH1cbn1cbiIsIjxuZy1jb250ZW50IHNlbGVjdD1cImlneC1zcGxpdHRlci1wYW5lXCI+PC9uZy1jb250ZW50PlxyXG48bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBwYW5lIG9mIHBhbmVzOyBsZXQgbGFzdCA9IGxhc3Q7IGxldCBpbmRleD0gaW5kZXg7XCI+XHJcbiAgICA8aWd4LXNwbGl0dGVyLWJhciAqbmdJZj1cIiFsYXN0XCIgW29yZGVyXT0ncGFuZS5vcmRlciArIDEnIHJvbGU9J3NlcGFyYXRvcidcclxuICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJ0eXBlXCJcclxuICAgICAgICAgICAgICAgICAgICBbcGFuZV09XCJwYW5lXCJcclxuICAgICAgICAgICAgICAgICAgICBbc2libGluZ3NdPSdnZXRQYW5lU2libGluZ3NCeU9yZGVyKHBhbmUub3JkZXIgKyAxLCBpbmRleCknXHJcbiAgICAgICAgICAgICAgICAgICAgKG1vdmVTdGFydCk9XCJvbk1vdmVTdGFydCgkZXZlbnQpXCJcclxuICAgICAgICAgICAgICAgICAgICAobW92aW5nKT1cIm9uTW92aW5nKCRldmVudClcIlxyXG4gICAgICAgICAgICAgICAgICAgIChtb3ZpbmdFbmQpPSdvbk1vdmVFbmQoJGV2ZW50KSc+XHJcbiAgICA8L2lneC1zcGxpdHRlci1iYXI+XHJcbjwvbmctY29udGFpbmVyPlxyXG4iLCI8ZGl2IGNsYXNzPVwiaWd4LXNwbGl0dGVyLWJhclwiXHJcbiAgICBbY2xhc3MuaWd4LXNwbGl0dGVyLWJhci0tdmVydGljYWxdPSd0eXBlID09PSAwJ1xyXG4gICAgW3N0eWxlLmN1cnNvcl09J2N1cnNvcidcclxuICAgIGlneERyYWdcclxuICAgIFtnaG9zdF09XCJmYWxzZVwiXHJcbiAgICBbZHJhZ0RpcmVjdGlvbl09J2RyYWdEaXInXHJcbiAgICAoZHJhZ1N0YXJ0KT0nb25EcmFnU3RhcnQoJGV2ZW50KSdcclxuICAgIChkcmFnTW92ZSk9XCJvbkRyYWdNb3ZlKCRldmVudClcIlxyXG4gICAgKGRyYWdFbmQpPVwib25EcmFnRW5kKCRldmVudClcIlxyXG4+XHJcbiAgICA8ZGl2IGNsYXNzPVwiaWd4LXNwbGl0dGVyLWJhcl9fZXhwYW5kZXItLXN0YXJ0XCIgaWd4RHJhZ0lnbm9yZSAoY2xpY2spPSdvbkNvbGxhcHNpbmcoZmFsc2UpJyBbaGlkZGVuXT0ncHJldkJ1dHRvbkhpZGRlbic+PC9kaXY+XHJcbiAgICA8ZGl2IGNsYXNzPVwiaWd4LXNwbGl0dGVyLWJhcl9faGFuZGxlXCIgPjwvZGl2PlxyXG4gICAgPGRpdiBjbGFzcz1cImlneC1zcGxpdHRlci1iYXJfX2V4cGFuZGVyLS1lbmRcIiBpZ3hEcmFnSWdub3JlIChjbGljayk9J29uQ29sbGFwc2luZyh0cnVlKScgW2hpZGRlbl09J25leHRCdXR0b25IaWRkZW4nPjwvZGl2PlxyXG48L2Rpdj5cclxuIl19
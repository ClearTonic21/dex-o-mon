import { Component, HostBinding, Input, Output, EventEmitter } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * Represents individual resizable/collapsible panes.
 *
 * @igxModule IgxSplitterModule
 *
 * @igxParent IgxSplitterComponent
 *
 * @igxKeywords pane
 *
 * @igxGroup presentation
 *
 * @remarks
 *  Users can control the resize behavior via the min and max size properties.
 */
export class IgxSplitterPaneComponent {
    /**
     * Gets/Sets the minimum allowed size of the current pane.
     *
     * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [minSize]='minSize'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get minSize() {
        return this._minSize;
    }
    set minSize(value) {
        this._minSize = value;
        if (this.owner) {
            this.owner.panes.notifyOnChanges();
        }
    }
    /**
     * Gets/Set the maximum allowed size of the current pane.
     *
     * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [maxSize]='maxSize'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get maxSize() {
        return this._maxSize;
    }
    set maxSize(value) {
        this._maxSize = value;
        if (this.owner) {
            this.owner.panes.notifyOnChanges();
        }
    }
    /**
     * Gets/Sets the size of the current pane.
     *  * @example
     * ```html
     * <igx-splitter>
     *  <igx-splitter-pane [size]='size'>...</igx-splitter-pane>
     * </igx-splitter>
     * ```
     */
    get size() {
        return this._size;
    }
    set size(value) {
        this._size = value;
        this.el.nativeElement.style.flex = this.flex;
    }
    /** @hidden @internal */
    get isPercentageSize() {
        return this.size === 'auto' || this.size.indexOf('%') !== -1;
    }
    /** @hidden @internal */
    get dragSize() {
        return this._dragSize;
    }
    set dragSize(val) {
        this._dragSize = val;
        this.el.nativeElement.style.flex = this.flex;
    }
    /**
     *
     * @hidden @internal
     * Gets the host native element.
     */
    get element() {
        return this.el.nativeElement;
    }
    /**
     * @hidden @internal
     * Gets the `flex` property of the current `IgxSplitterPaneComponent`.
     */
    get flex() {
        const isAuto = this.size === 'auto' && !this.dragSize;
        const grow = !isAuto ? 0 : 1;
        const size = this.dragSize || this.size;
        return `${grow} ${grow} ${size}`;
    }
    /**
     * Gets/Sets whether current pane is collapsed.
     *
     * @example
     * ```typescript
     * const isCollapsed = pane.collapsed;
     * ```
     */
    set collapsed(value) {
        if (this.owner) {
            // reset sibling sizes when pane collapse state changes.
            this._getSiblings().forEach(sibling => {
                sibling.size = 'auto';
                sibling.dragSize = null;
            });
        }
        this._collapsed = value;
        this.display = this._collapsed ? 'none' : 'flex';
        this.collapsedChange.emit(this._collapsed);
    }
    get collapsed() {
        return this._collapsed;
    }
    constructor(el) {
        this.el = el;
        /**
         * @hidden @internal
         * Gets/Sets the 'display' property of the current pane.
         */
        this.display = 'flex';
        /**
         * Gets/Sets whether pane is resizable.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane [resizable]='false'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         * @remarks
         * If pane is not resizable its related splitter bar cannot be dragged.
         */
        this.resizable = true;
        /**
         * Event fired when collapsed state of pane is changed.
         *
         * @example
         * ```html
         * <igx-splitter>
         *  <igx-splitter-pane (collapsedChange)='paneCollapsedChange($event)'>...</igx-splitter-pane>
         * </igx-splitter>
         * ```
         */
        this.collapsedChange = new EventEmitter();
        /**
         * @hidden @internal
         * Gets/Sets the `overflow`.
         */
        this.overflow = 'auto';
        /**
         * @hidden @internal
         * Get/Sets the `minWidth` properties of the current pane.
         */
        this.minWidth = '0';
        /**
         * @hidden @internal
         * Get/Sets the `maxWidth` properties of the current pane.
         */
        this.maxWidth = '100%';
        /**
         * @hidden @internal
         * Gets/Sets the `minHeight` properties of the current pane.
         */
        this.minHeight = '0';
        /**
         * @hidden @internal
         * Gets/Sets the `maxHeight` properties of the current `IgxSplitterPaneComponent`.
         */
        this.maxHeight = '100%';
        this._size = 'auto';
        this._collapsed = false;
    }
    /**
     * Toggles the collapsed state of the pane.
     *
     * @example
     * ```typescript
     * pane.toggle();
     * ```
     */
    toggle() {
        this.collapsed = !this.collapsed;
    }
    /** @hidden @internal */
    _getSiblings() {
        const panes = this.owner.panes.toArray();
        const index = panes.indexOf(this);
        const siblings = [];
        if (index !== 0) {
            siblings.push(panes[index - 1]);
        }
        if (index !== panes.length - 1) {
            siblings.push(panes[index + 1]);
        }
        return siblings;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitterPaneComponent, deps: [{ token: i0.ElementRef }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "16.1.2", type: IgxSplitterPaneComponent, isStandalone: true, selector: "igx-splitter-pane", inputs: { minSize: "minSize", maxSize: "maxSize", resizable: "resizable", size: "size", collapsed: "collapsed" }, outputs: { collapsedChange: "collapsedChange" }, host: { properties: { "style.display": "this.display", "style.order": "this.order", "style.overflow": "this.overflow", "style.min-width": "this.minWidth", "style.max-width": "this.maxWidth", "style.min-height": "this.minHeight", "style.max-height": "this.maxHeight", "style.flex": "this.flex" } }, ngImport: i0, template: "<ng-content></ng-content>" }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.1.2", ngImport: i0, type: IgxSplitterPaneComponent, decorators: [{
            type: Component,
            args: [{ selector: 'igx-splitter-pane', standalone: true, template: "<ng-content></ng-content>" }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }]; }, propDecorators: { display: [{
                type: HostBinding,
                args: ['style.display']
            }], minSize: [{
                type: Input
            }], maxSize: [{
                type: Input
            }], resizable: [{
                type: Input
            }], collapsedChange: [{
                type: Output
            }], order: [{
                type: HostBinding,
                args: ['style.order']
            }], overflow: [{
                type: HostBinding,
                args: ['style.overflow']
            }], minWidth: [{
                type: HostBinding,
                args: ['style.min-width']
            }], maxWidth: [{
                type: HostBinding,
                args: ['style.max-width']
            }], minHeight: [{
                type: HostBinding,
                args: ['style.min-height']
            }], maxHeight: [{
                type: HostBinding,
                args: ['style.max-height']
            }], size: [{
                type: Input
            }], flex: [{
                type: HostBinding,
                args: ['style.flex']
            }], collapsed: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3BsaXR0ZXItcGFuZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9pZ25pdGV1aS1hbmd1bGFyL3NyYy9saWIvc3BsaXR0ZXIvc3BsaXR0ZXItcGFuZS9zcGxpdHRlci1wYW5lLmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lnbml0ZXVpLWFuZ3VsYXIvc3JjL2xpYi9zcGxpdHRlci9zcGxpdHRlci1wYW5lL3NwbGl0dGVyLXBhbmUuY29tcG9uZW50Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFjLE1BQU0sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7O0FBRWhHOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFNSCxNQUFNLE9BQU8sd0JBQXdCO0lBV2pDOzs7Ozs7Ozs7T0FTRztJQUNILElBQ1csT0FBTztRQUNkLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN6QixDQUFDO0lBQ0QsSUFBVyxPQUFPLENBQUMsS0FBYTtRQUM1QixJQUFJLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztRQUN0QixJQUFJLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDWixJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxlQUFlLEVBQUUsQ0FBQztTQUN0QztJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSCxJQUNXLE9BQU87UUFDZCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDekIsQ0FBQztJQUNELElBQVcsT0FBTyxDQUFDLEtBQWE7UUFDNUIsSUFBSSxDQUFDLFFBQVEsR0FBRyxLQUFLLENBQUM7UUFDdEIsSUFBSSxJQUFJLENBQUMsS0FBSyxFQUFFO1lBQ1osSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsZUFBZSxFQUFFLENBQUM7U0FDdEM7SUFDTCxDQUFD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dEIsUUFBUTtzQkFEZCxXQUFXO3VCQUFDLGlCQUFpQjtnQkFRdkIsUUFBUTtzQkFEZCxXQUFXO3VCQUFDLGlCQUFpQjtnQkFRdkIsU0FBUztzQkFEZixXQUFXO3VCQUFDLGtCQUFrQjtnQkFReEIsU0FBUztzQkFEZixXQUFXO3VCQUFDLGtCQUFrQjtnQkFnQnBCLElBQUk7c0JBRGQsS0FBSztnQkFzQ0ssSUFBSTtzQkFEZCxXQUFXO3VCQUFDLFlBQVk7Z0JBaUJkLFNBQVM7c0JBRG5CLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIEhvc3RCaW5kaW5nLCBJbnB1dCwgRWxlbWVudFJlZiwgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBSZXByZXNlbnRzIGluZGl2aWR1YWwgcmVzaXphYmxlL2NvbGxhcHNpYmxlIHBhbmVzLlxuICpcbiAqIEBpZ3hNb2R1bGUgSWd4U3BsaXR0ZXJNb2R1bGVcbiAqXG4gKiBAaWd4UGFyZW50IElneFNwbGl0dGVyQ29tcG9uZW50XG4gKlxuICogQGlneEtleXdvcmRzIHBhbmVcbiAqXG4gKiBAaWd4R3JvdXAgcHJlc2VudGF0aW9uXG4gKlxuICogQHJlbWFya3NcbiAqICBVc2VycyBjYW4gY29udHJvbCB0aGUgcmVzaXplIGJlaGF2aW9yIHZpYSB0aGUgbWluIGFuZCBtYXggc2l6ZSBwcm9wZXJ0aWVzLlxuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1zcGxpdHRlci1wYW5lJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc3BsaXR0ZXItcGFuZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3RhbmRhbG9uZTogdHJ1ZVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnQge1xuICAgIHByaXZhdGUgX21pblNpemU6IHN0cmluZztcbiAgICBwcml2YXRlIF9tYXhTaXplOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgJ2Rpc3BsYXknIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5kaXNwbGF5JylcbiAgICBwdWJsaWMgZGlzcGxheSA9ICdmbGV4JztcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgbWluaW11bSBhbGxvd2VkIHNpemUgb2YgdGhlIGN1cnJlbnQgcGFuZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXI+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZSBbbWluU2l6ZV09J21pblNpemUnPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IG1pblNpemUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21pblNpemU7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgbWluU2l6ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21pblNpemUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMub3duZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIucGFuZXMubm90aWZ5T25DaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldCB0aGUgbWF4aW11bSBhbGxvd2VkIHNpemUgb2YgdGhlIGN1cnJlbnQgcGFuZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXI+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZSBbbWF4U2l6ZV09J21heFNpemUnPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IG1heFNpemUoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heFNpemU7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgbWF4U2l6ZSh2YWx1ZTogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX21heFNpemUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMub3duZXIpIHtcbiAgICAgICAgICAgIHRoaXMub3duZXIucGFuZXMubm90aWZ5T25DaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgd2hldGhlciBwYW5lIGlzIHJlc2l6YWJsZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXI+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZSBbcmVzaXphYmxlXT0nZmFsc2UnPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBwYW5lIGlzIG5vdCByZXNpemFibGUgaXRzIHJlbGF0ZWQgc3BsaXR0ZXIgYmFyIGNhbm5vdCBiZSBkcmFnZ2VkLlxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJlc2l6YWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIGNvbGxhcHNlZCBzdGF0ZSBvZiBwYW5lIGlzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNwbGl0dGVyPlxuICAgICAqICA8aWd4LXNwbGl0dGVyLXBhbmUgKGNvbGxhcHNlZENoYW5nZSk9J3BhbmVDb2xsYXBzZWRDaGFuZ2UoJGV2ZW50KSc+Li4uPC9pZ3gtc3BsaXR0ZXItcGFuZT5cbiAgICAgKiA8L2lneC1zcGxpdHRlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgY29sbGFwc2VkQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vcmRlcicpXG4gICAgcHVibGljIG9yZGVyITogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzL1NldHMgdGhlIGBvdmVyZmxvd2AuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vdmVyZmxvdycpXG4gICAgcHVibGljIG92ZXJmbG93ID0gJ2F1dG8nO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXQvU2V0cyB0aGUgYG1pbldpZHRoYCBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IHBhbmUuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5taW4td2lkdGgnKVxuICAgIHB1YmxpYyBtaW5XaWR0aCA9ICcwJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0L1NldHMgdGhlIGBtYXhXaWR0aGAgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWF4LXdpZHRoJylcbiAgICBwdWJsaWMgbWF4V2lkdGggPSAnMTAwJSc7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEdldHMvU2V0cyB0aGUgYG1pbkhlaWdodGAgcHJvcGVydGllcyBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWluLWhlaWdodCcpXG4gICAgcHVibGljIG1pbkhlaWdodCA9ICcwJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cy9TZXRzIHRoZSBgbWF4SGVpZ2h0YCBwcm9wZXJ0aWVzIG9mIHRoZSBjdXJyZW50IGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUubWF4LWhlaWdodCcpXG4gICAgcHVibGljIG1heEhlaWdodCA9ICcxMDAlJztcblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBvd25lcjtcblxuICAgIC8qKlxuICAgICAqIEdldHMvU2V0cyB0aGUgc2l6ZSBvZiB0aGUgY3VycmVudCBwYW5lLlxuICAgICAqICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc3BsaXR0ZXI+XG4gICAgICogIDxpZ3gtc3BsaXR0ZXItcGFuZSBbc2l6ZV09J3NpemUnPi4uLjwvaWd4LXNwbGl0dGVyLXBhbmU+XG4gICAgICogPC9pZ3gtc3BsaXR0ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgc2l6ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9zaXplID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5mbGV4ID0gdGhpcy5mbGV4O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgaXNQZXJjZW50YWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZSA9PT0gJ2F1dG8nIHx8IHRoaXMuc2l6ZS5pbmRleE9mKCclJykgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgZHJhZ1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmFnU2l6ZTtcbiAgICB9XG4gICAgcHVibGljIHNldCBkcmFnU2l6ZSh2YWwpIHtcbiAgICAgICAgdGhpcy5fZHJhZ1NpemUgPSB2YWw7XG4gICAgICAgIHRoaXMuZWwubmF0aXZlRWxlbWVudC5zdHlsZS5mbGV4ID0gdGhpcy5mbGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKiBHZXRzIHRoZSBob3N0IG5hdGl2ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZWxlbWVudCgpOiBhbnkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW4gQGludGVybmFsXG4gICAgICogR2V0cyB0aGUgYGZsZXhgIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGBJZ3hTcGxpdHRlclBhbmVDb21wb25lbnRgLlxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleCcpXG4gICAgcHVibGljIGdldCBmbGV4KCkge1xuICAgICAgICBjb25zdCBpc0F1dG8gPSB0aGlzLnNpemUgPT09ICdhdXRvJyAmJiAhdGhpcy5kcmFnU2l6ZTtcbiAgICAgICAgY29uc3QgZ3JvdyA9ICFpc0F1dG8gPyAwIDogMTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZHJhZ1NpemUgfHwgdGhpcy5zaXplO1xuICAgICAgICByZXR1cm4gYCR7Z3Jvd30gJHtncm93fSAke3NpemV9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzL1NldHMgd2hldGhlciBjdXJyZW50IHBhbmUgaXMgY29sbGFwc2VkLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgaXNDb2xsYXBzZWQgPSBwYW5lLmNvbGxhcHNlZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgY29sbGFwc2VkKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLm93bmVyKSB7XG4gICAgICAgICAgICAvLyByZXNldCBzaWJsaW5nIHNpemVzIHdoZW4gcGFuZSBjb2xsYXBzZSBzdGF0ZSBjaGFuZ2VzLlxuICAgICAgICAgICAgdGhpcy5fZ2V0U2libGluZ3MoKS5mb3JFYWNoKHNpYmxpbmcgPT4ge1xuICAgICAgICAgICAgICAgIHNpYmxpbmcuc2l6ZSA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgIHNpYmxpbmcuZHJhZ1NpemUgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29sbGFwc2VkID0gdmFsdWU7XG4gICAgICAgIHRoaXMuZGlzcGxheSA9IHRoaXMuX2NvbGxhcHNlZCA/ICdub25lJyA6ICdmbGV4JztcbiAgICAgICAgdGhpcy5jb2xsYXBzZWRDaGFuZ2UuZW1pdCh0aGlzLl9jb2xsYXBzZWQpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgY29sbGFwc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGFwc2VkO1xuICAgIH1cblxuICAgIHByaXZhdGUgX3NpemUgPSAnYXV0byc7XG4gICAgcHJpdmF0ZSBfZHJhZ1NpemU7XG4gICAgcHJpdmF0ZSBfY29sbGFwc2VkID0gZmFsc2U7XG5cblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZWw6IEVsZW1lbnRSZWYpIHsgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgY29sbGFwc2VkIHN0YXRlIG9mIHRoZSBwYW5lLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcGFuZS50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKCkge1xuICAgICAgICB0aGlzLmNvbGxhcHNlZCA9ICF0aGlzLmNvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBwcml2YXRlIF9nZXRTaWJsaW5ncygpIHtcbiAgICAgICAgY29uc3QgcGFuZXMgPSB0aGlzLm93bmVyLnBhbmVzLnRvQXJyYXkoKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYW5lcy5pbmRleE9mKHRoaXMpO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IFtdO1xuICAgICAgICBpZiAoaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIHNpYmxpbmdzLnB1c2gocGFuZXNbaW5kZXggLSAxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4ICE9PSBwYW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzaWJsaW5ncy5wdXNoKHBhbmVzW2luZGV4ICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWJsaW5ncztcbiAgICB9XG59XG4iLCI8bmctY29udGVudD48L25nLWNvbnRlbnQ+Il19